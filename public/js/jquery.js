/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/jquery.js":
/*!********************************!*\
  !*** ./resources/js/jquery.js ***!
  \********************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v1.9.1\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-2-4\n */\n(function (window, undefined) {\n  // Can't do this because several apps including ASP.NET trace\n  // the stack via arguments.caller.callee and Firefox dies if\n  // you try to trace through \"use strict\" call chains. (#13335)\n  // Support: Firefox 18+\n  //\"use strict\";\n  var // The deferred used on DOM ready\n  readyList,\n      // A central reference to the root jQuery(document)\n  rootjQuery,\n      // Support: IE<9\n  // For `typeof node.method` instead of `node.method !== undefined`\n  core_strundefined = _typeof(undefined),\n      // Use the correct document accordingly with window argument (sandbox)\n  document = window.document,\n      location = window.location,\n      // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$,\n      // [[Class]] -> type pairs\n  class2type = {},\n      // List of deleted data cache ids, so we can reuse them\n  core_deletedIds = [],\n      core_version = \"1.9.1\",\n      // Save a reference to some core methods\n  core_concat = core_deletedIds.concat,\n      core_push = core_deletedIds.push,\n      core_slice = core_deletedIds.slice,\n      core_indexOf = core_deletedIds.indexOf,\n      core_toString = class2type.toString,\n      core_hasOwn = class2type.hasOwnProperty,\n      core_trim = core_version.trim,\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    return new jQuery.fn.init(selector, context, rootjQuery);\n  },\n      // Used for matching numbers\n  core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      // Used for splitting on whitespace\n  core_rnotwhite = /\\S+/g,\n      // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  rquickExpr = /^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      // Match a standalone tag\n  rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      // JSON RegExp\n  rvalidchars = /^[\\],:{}\\s]*$/,\n      rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n      rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n      rvalidtokens = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,\n      // Matches dashed string for camelizing\n  rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([\\da-z])/gi,\n      // Used by jQuery.camelCase as callback to replace()\n  fcamelCase = function fcamelCase(all, letter) {\n    return letter.toUpperCase();\n  },\n      // The ready event handler\n  completed = function completed(event) {\n    // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n    if (document.addEventListener || event.type === \"load\" || document.readyState === \"complete\") {\n      detach();\n      jQuery.ready();\n    }\n  },\n      // Clean-up method for dom ready events\n  detach = function detach() {\n    if (document.addEventListener) {\n      document.removeEventListener(\"DOMContentLoaded\", completed, false);\n      window.removeEventListener(\"load\", completed, false);\n    } else {\n      document.detachEvent(\"onreadystatechange\", completed);\n      window.detachEvent(\"onload\", completed);\n    }\n  };\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: core_version,\n    constructor: jQuery,\n    init: function init(selector, context, rootjQuery) {\n      var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n      if (!selector) {\n        return this;\n      } // Handle HTML strings\n\n\n      if (typeof selector === \"string\") {\n        if (selector.charAt(0) === \"<\" && selector.charAt(selector.length - 1) === \">\" && selector.length >= 3) {\n          // Assume that strings that start and end with <> are HTML and skip the regex check\n          match = [null, selector, null];\n        } else {\n          match = rquickExpr.exec(selector);\n        } // Match html or make sure no context is specified for #id\n\n\n        if (match && (match[1] || !context)) {\n          // HANDLE: $(html) -> $(array)\n          if (match[1]) {\n            context = context instanceof jQuery ? context[0] : context; // scripts is true for back-compat\n\n            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n              for (match in context) {\n                // Properties of context are called as methods if possible\n                if (jQuery.isFunction(this[match])) {\n                  this[match](context[match]); // ...and otherwise set as attributes\n                } else {\n                  this.attr(match, context[match]);\n                }\n              }\n            }\n\n            return this; // HANDLE: $(#id)\n          } else {\n            elem = document.getElementById(match[2]); // Check parentNode to catch when Blackberry 4.6 returns\n            // nodes that are no longer in the document #6963\n\n            if (elem && elem.parentNode) {\n              // Handle the case where IE and Opera return items\n              // by name instead of ID\n              if (elem.id !== match[2]) {\n                return rootjQuery.find(selector);\n              } // Otherwise, we inject the element directly into the jQuery object\n\n\n              this.length = 1;\n              this[0] = elem;\n            }\n\n            this.context = document;\n            this.selector = selector;\n            return this;\n          } // HANDLE: $(expr, $(...))\n\n        } else if (!context || context.jquery) {\n          return (context || rootjQuery).find(selector); // HANDLE: $(expr, context)\n          // (which is just equivalent to: $(context).find(expr)\n        } else {\n          return this.constructor(context).find(selector);\n        } // HANDLE: $(DOMElement)\n\n      } else if (selector.nodeType) {\n        this.context = this[0] = selector;\n        this.length = 1;\n        return this; // HANDLE: $(function)\n        // Shortcut for document ready\n      } else if (jQuery.isFunction(selector)) {\n        return rootjQuery.ready(selector);\n      }\n\n      if (selector.selector !== undefined) {\n        this.selector = selector.selector;\n        this.context = selector.context;\n      }\n\n      return jQuery.makeArray(selector, this);\n    },\n    // Start with an empty selector\n    selector: \"\",\n    // The default length of a jQuery object is 0\n    length: 0,\n    // The number of elements contained in the matched element set\n    size: function size() {\n      return this.length;\n    },\n    toArray: function toArray() {\n      return core_slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      return num == null ? // Return a 'clean' array\n      this.toArray() : // Return just the object\n      num < 0 ? this[this.length + num] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this;\n      ret.context = this.context; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    // (You can seed the arguments with an array of args, but this is\n    // only used internally.)\n    each: function each(callback, args) {\n      return jQuery.each(this, callback, args);\n    },\n    ready: function ready(fn) {\n      // Add the callback\n      jQuery.ready.promise().done(fn);\n      return this;\n    },\n    slice: function slice() {\n      return this.pushStack(core_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    end: function end() {\n      return this.prevObject || this.constructor(null);\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: core_push,\n    sort: [].sort,\n    splice: [].splice\n  }; // Give the init function the jQuery prototype for later instantiation\n\n  jQuery.fn.init.prototype = jQuery.fn;\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var src,\n        copyIsArray,\n        copy,\n        name,\n        options,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target;\n      target = arguments[1] || {}; // skip the boolean and the target\n\n      i = 2;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !jQuery.isFunction(target)) {\n      target = {};\n    } // extend jQuery itself if only one argument is passed\n\n\n    if (length === i) {\n      target = this;\n      --i;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          src = target[name];\n          copy = options[name]; // Prevent never-ending loop\n\n          if (target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && jQuery.isArray(src) ? src : [];\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    noConflict: function noConflict(deep) {\n      if (window.$ === jQuery) {\n        window.$ = _$;\n      }\n\n      if (deep && window.jQuery === jQuery) {\n        window.jQuery = _jQuery;\n      }\n\n      return jQuery;\n    },\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Hold (or release) the ready event\n    holdReady: function holdReady(hold) {\n      if (hold) {\n        jQuery.readyWait++;\n      } else {\n        jQuery.ready(true);\n      }\n    },\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\n\n      if (!document.body) {\n        return setTimeout(jQuery.ready);\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]); // Trigger any bound ready events\n\n      if (jQuery.fn.trigger) {\n        jQuery(document).trigger(\"ready\").off(\"ready\");\n      }\n    },\n    // See test/unit/core.js for details concerning isFunction.\n    // Since version 1.3, DOM methods and functions like alert\n    // aren't supported. They return false on IE (#2968).\n    isFunction: function isFunction(obj) {\n      return jQuery.type(obj) === \"function\";\n    },\n    isArray: Array.isArray || function (obj) {\n      return jQuery.type(obj) === \"array\";\n    },\n    isWindow: function isWindow(obj) {\n      return obj != null && obj == obj.window;\n    },\n    isNumeric: function isNumeric(obj) {\n      return !isNaN(parseFloat(obj)) && isFinite(obj);\n    },\n    type: function type(obj) {\n      if (obj == null) {\n        return String(obj);\n      }\n\n      return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[core_toString.call(obj)] || \"object\" : _typeof(obj);\n    },\n    isPlainObject: function isPlainObject(obj) {\n      // Must be an Object.\n      // Because of IE, we also have to check the presence of the constructor property.\n      // Make sure that DOM nodes and window objects don't pass through, as well\n      if (!obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\n        return false;\n      }\n\n      try {\n        // Not own constructor property must be Object\n        if (obj.constructor && !core_hasOwn.call(obj, \"constructor\") && !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n          return false;\n        }\n      } catch (e) {\n        // IE8,9 Will throw exceptions on certain host objects #9897\n        return false;\n      } // Own properties are enumerated firstly, so to speed up,\n      // if last one is own, then all properties are own.\n\n\n      var key;\n\n      for (key in obj) {}\n\n      return key === undefined || core_hasOwn.call(obj, key);\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    // data: string of html\n    // context (optional): If specified, the fragment will be created in this context, defaults to document\n    // keepScripts (optional): If true, will include scripts passed in the html string\n    parseHTML: function parseHTML(data, context, keepScripts) {\n      if (!data || typeof data !== \"string\") {\n        return null;\n      }\n\n      if (typeof context === \"boolean\") {\n        keepScripts = context;\n        context = false;\n      }\n\n      context = context || document;\n      var parsed = rsingleTag.exec(data),\n          scripts = !keepScripts && []; // Single tag\n\n      if (parsed) {\n        return [context.createElement(parsed[1])];\n      }\n\n      parsed = jQuery.buildFragment([data], context, scripts);\n\n      if (scripts) {\n        jQuery(scripts).remove();\n      }\n\n      return jQuery.merge([], parsed.childNodes);\n    },\n    parseJSON: function parseJSON(data) {\n      // Attempt to parse using the native JSON parser first\n      if (window.JSON && window.JSON.parse) {\n        return window.JSON.parse(data);\n      }\n\n      if (data === null) {\n        return data;\n      }\n\n      if (typeof data === \"string\") {\n        // Make sure leading/trailing whitespace is removed (IE can't handle it)\n        data = jQuery.trim(data);\n\n        if (data) {\n          // Make sure the incoming data is actual JSON\n          // Logic borrowed from http://json.org/json2.js\n          if (rvalidchars.test(data.replace(rvalidescape, \"@\").replace(rvalidtokens, \"]\").replace(rvalidbraces, \"\"))) {\n            return new Function(\"return \" + data)();\n          }\n        }\n      }\n\n      jQuery.error(\"Invalid JSON: \" + data);\n    },\n    // Cross-browser xml parsing\n    parseXML: function parseXML(data) {\n      var xml, tmp;\n\n      if (!data || typeof data !== \"string\") {\n        return null;\n      }\n\n      try {\n        if (window.DOMParser) {\n          // Standard\n          tmp = new DOMParser();\n          xml = tmp.parseFromString(data, \"text/xml\");\n        } else {\n          // IE\n          xml = new ActiveXObject(\"Microsoft.XMLDOM\");\n          xml.async = \"false\";\n          xml.loadXML(data);\n        }\n      } catch (e) {\n        xml = undefined;\n      }\n\n      if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length) {\n        jQuery.error(\"Invalid XML: \" + data);\n      }\n\n      return xml;\n    },\n    noop: function noop() {},\n    // Evaluates a script in a global context\n    // Workarounds based on findings by Jim Driscoll\n    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n    globalEval: function globalEval(data) {\n      if (data && jQuery.trim(data)) {\n        // We use execScript on Internet Explorer\n        // We use an anonymous function so that context is window\n        // rather than jQuery in Firefox\n        (window.execScript || function (data) {\n          window[\"eval\"].call(window, data);\n        })(data);\n      }\n    },\n    // Convert dashed to camelCase; used by the css and data modules\n    // Microsoft forgot to hump their vendor prefix (#9572)\n    camelCase: function camelCase(string) {\n      return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n    },\n    nodeName: function nodeName(elem, name) {\n      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    },\n    // args is for internal usage only\n    each: function each(obj, callback, args) {\n      var value,\n          i = 0,\n          length = obj.length,\n          isArray = isArraylike(obj);\n\n      if (args) {\n        if (isArray) {\n          for (; i < length; i++) {\n            value = callback.apply(obj[i], args);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } else {\n          for (i in obj) {\n            value = callback.apply(obj[i], args);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } // A special, fast, case for the most common use of each\n\n      } else {\n        if (isArray) {\n          for (; i < length; i++) {\n            value = callback.call(obj[i], i, obj[i]);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } else {\n          for (i in obj) {\n            value = callback.call(obj[i], i, obj[i]);\n\n            if (value === false) {\n              break;\n            }\n          }\n        }\n      }\n\n      return obj;\n    },\n    // Use native String.trim function wherever possible\n    trim: core_trim && !core_trim.call(\"\\uFEFF\\xA0\") ? function (text) {\n      return text == null ? \"\" : core_trim.call(text);\n    } : // Otherwise use our own trimming functionality\n    function (text) {\n      return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArraylike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          core_push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      var len;\n\n      if (arr) {\n        if (core_indexOf) {\n          return core_indexOf.call(arr, elem, i);\n        }\n\n        len = arr.length;\n        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n\n        for (; i < len; i++) {\n          // Skip accessing in sparse arrays\n          if (i in arr && arr[i] === elem) {\n            return i;\n          }\n        }\n      }\n\n      return -1;\n    },\n    merge: function merge(first, second) {\n      var l = second.length,\n          i = first.length,\n          j = 0;\n\n      if (typeof l === \"number\") {\n        for (; j < l; j++) {\n          first[i++] = second[j];\n        }\n      } else {\n        while (second[j] !== undefined) {\n          first[i++] = second[j++];\n        }\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, inv) {\n      var retVal,\n          ret = [],\n          i = 0,\n          length = elems.length;\n      inv = !!inv; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        retVal = !!callback(elems[i], i);\n\n        if (inv !== retVal) {\n          ret.push(elems[i]);\n        }\n      }\n\n      return ret;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var value,\n          i = 0,\n          length = elems.length,\n          isArray = isArraylike(elems),\n          ret = []; // Go through the array, translating each of the items to their\n\n      if (isArray) {\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret[ret.length] = value;\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret[ret.length] = value;\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return core_concat.apply([], ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    proxy: function proxy(fn, context) {\n      var args, proxy, tmp;\n\n      if (typeof context === \"string\") {\n        tmp = fn[context];\n        context = fn;\n        fn = tmp;\n      } // Quick check to determine if target is callable, in the spec\n      // this throws a TypeError, but we will just return undefined.\n\n\n      if (!jQuery.isFunction(fn)) {\n        return undefined;\n      } // Simulated bind\n\n\n      args = core_slice.call(arguments, 2);\n\n      proxy = function proxy() {\n        return fn.apply(context || this, args.concat(core_slice.call(arguments)));\n      }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n      proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n      return proxy;\n    },\n    // Multifunctional method to get and set values of a collection\n    // The value/s can optionally be executed if it's a function\n    access: function access(elems, fn, key, value, chainable, emptyGet, raw) {\n      var i = 0,\n          length = elems.length,\n          bulk = key == null; // Sets many values\n\n      if (jQuery.type(key) === \"object\") {\n        chainable = true;\n\n        for (i in key) {\n          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);\n        } // Sets one value\n\n      } else if (value !== undefined) {\n        chainable = true;\n\n        if (!jQuery.isFunction(value)) {\n          raw = true;\n        }\n\n        if (bulk) {\n          // Bulk operations run against the entire set\n          if (raw) {\n            fn.call(elems, value);\n            fn = null; // ...except when executing function values\n          } else {\n            bulk = fn;\n\n            fn = function fn(elem, key, value) {\n              return bulk.call(jQuery(elem), value);\n            };\n          }\n        }\n\n        if (fn) {\n          for (; i < length; i++) {\n            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n          }\n        }\n      }\n\n      return chainable ? elems : // Gets\n      bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;\n    },\n    now: function now() {\n      return new Date().getTime();\n    }\n  });\n\n  jQuery.ready.promise = function (obj) {\n    if (!readyList) {\n      readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred.\n      // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\n      if (document.readyState === \"complete\") {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        setTimeout(jQuery.ready); // Standards-based browsers support DOMContentLoaded\n      } else if (document.addEventListener) {\n        // Use the handy event callback\n        document.addEventListener(\"DOMContentLoaded\", completed, false); // A fallback to window.onload, that will always work\n\n        window.addEventListener(\"load\", completed, false); // If IE event model is used\n      } else {\n        // Ensure firing before onload, maybe late but safe also for iframes\n        document.attachEvent(\"onreadystatechange\", completed); // A fallback to window.onload, that will always work\n\n        window.attachEvent(\"onload\", completed); // If IE and not a frame\n        // continually check to see if the document is ready\n\n        var top = false;\n\n        try {\n          top = window.frameElement == null && document.documentElement;\n        } catch (e) {}\n\n        if (top && top.doScroll) {\n          (function doScrollCheck() {\n            if (!jQuery.isReady) {\n              try {\n                // Use the trick by Diego Perini\n                // http://javascript.nwbox.com/IEContentLoaded/\n                top.doScroll(\"left\");\n              } catch (e) {\n                return setTimeout(doScrollCheck, 50);\n              } // detach all dom ready events\n\n\n              detach(); // and execute any waiting functions\n\n              jQuery.ready();\n            }\n          })();\n        }\n      }\n    }\n\n    return readyList.promise(obj);\n  }; // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArraylike(obj) {\n    var length = obj.length,\n        type = jQuery.type(obj);\n\n    if (jQuery.isWindow(obj)) {\n      return false;\n    }\n\n    if (obj.nodeType === 1 && length) {\n      return true;\n    }\n\n    return type === \"array\" || type !== \"function\" && (length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj);\n  } // All jQuery objects should point back to these\n\n\n  rootjQuery = jQuery(document); // String to Object options format cache\n\n  var optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache\n\n  function createOptions(options) {\n    var object = optionsCache[options] = {};\n    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value (for non-forgettable lists)\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // End of the loop when firing\n    firingLength,\n        // Index of currently firing callback (modified by remove if needed)\n    firingIndex,\n        // First callback to fire (used internally by add and fireWith)\n    firingStart,\n        // Actual callback list\n    list = [],\n        // Stack of fire calls for repeatable lists\n    stack = !options.once && [],\n        // Fire callbacks\n    fire = function fire(data) {\n      memory = options.memory && data;\n      _fired = true;\n      firingIndex = firingStart || 0;\n      firingStart = 0;\n      firingLength = list.length;\n      firing = true;\n\n      for (; list && firingIndex < firingLength; firingIndex++) {\n        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n          memory = false; // To prevent further calls using add\n\n          break;\n        }\n      }\n\n      firing = false;\n\n      if (list) {\n        if (stack) {\n          if (stack.length) {\n            fire(stack.shift());\n          }\n        } else if (memory) {\n          list = [];\n        } else {\n          self.disable();\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // First, we save the current length\n          var start = list.length;\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              var type = jQuery.type(arg);\n\n              if (type === \"function\") {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && type !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments); // Do we need to add the callbacks to the\n          // current firing batch?\n\n\n          if (firing) {\n            firingLength = list.length; // With memory, if we're not firing then\n            // we should call right away\n          } else if (memory) {\n            firingStart = start;\n            fire(memory);\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        if (list) {\n          jQuery.each(arguments, function (_, arg) {\n            var index;\n\n            while ((index = jQuery.inArray(arg, list, index)) > -1) {\n              list.splice(index, 1); // Handle firing indexes\n\n              if (firing) {\n                if (index <= firingLength) {\n                  firingLength--;\n                }\n\n                if (index <= firingIndex) {\n                  firingIndex--;\n                }\n              }\n            }\n          });\n        }\n\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        list = [];\n        return this;\n      },\n      // Have the list do nothing anymore\n      disable: function disable() {\n        list = stack = memory = undefined;\n        return this;\n      },\n      // Is it disabled?\n      disabled: function disabled() {\n        return !list;\n      },\n      // Lock the list in its current state\n      lock: function lock() {\n        stack = undefined;\n\n        if (!memory) {\n          self.disable();\n        }\n\n        return this;\n      },\n      // Is it locked?\n      locked: function locked() {\n        return !stack;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        args = args || [];\n        args = [context, args.slice ? args.slice() : args];\n\n        if (list && (!_fired || stack)) {\n          if (firing) {\n            stack.push(args);\n          } else {\n            fire(args);\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, listener list, final state\n      [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        then: function\n          /* fnDone, fnFail, fnProgress */\n        then() {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (i, tuple) {\n              var action = tuple[0],\n                  fn = jQuery.isFunction(fns[i]) && fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && jQuery.isFunction(returned.promise)) {\n                  returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n                } else {\n                  newDefer[action + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Keep pipe for back-compat\n\n      _promise.pipe = _promise.then; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = [ resolved | rejected ]\n            _state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n        } // deferred[ resolve | reject | notify ]\n\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n          return this;\n        };\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(subordinate\n    /* , ..., subordinateN */\n    ) {\n      var i = 0,\n          resolveValues = core_slice.call(arguments),\n          length = resolveValues.length,\n          // the count of uncompleted subordinates\n      remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n          // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n          // Update function for both resolve and progress values\n      updateFunc = function updateFunc(i, contexts, values) {\n        return function (value) {\n          contexts[i] = this;\n          values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;\n\n          if (values === progressValues) {\n            deferred.notifyWith(contexts, values);\n          } else if (! --remaining) {\n            deferred.resolveWith(contexts, values);\n          }\n        };\n      },\n          progressValues,\n          progressContexts,\n          resolveContexts; // add listeners to Deferred subordinates; treat others as resolved\n\n\n      if (length > 1) {\n        progressValues = new Array(length);\n        progressContexts = new Array(length);\n        resolveContexts = new Array(length);\n\n        for (; i < length; i++) {\n          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n          } else {\n            --remaining;\n          }\n        }\n      } // if we're not waiting on anything, resolve the master\n\n\n      if (!remaining) {\n        deferred.resolveWith(resolveContexts, resolveValues);\n      }\n\n      return deferred.promise();\n    }\n  });\n\n  jQuery.support = function () {\n    var support,\n        all,\n        a,\n        input,\n        select,\n        fragment,\n        opt,\n        eventName,\n        isSupported,\n        i,\n        div = document.createElement(\"div\"); // Setup\n\n    div.setAttribute(\"className\", \"t\");\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\"; // Support tests won't run in some limited or non-browser environments\n\n    all = div.getElementsByTagName(\"*\");\n    a = div.getElementsByTagName(\"a\")[0];\n\n    if (!all || !a || !all.length) {\n      return {};\n    } // First batch of tests\n\n\n    select = document.createElement(\"select\");\n    opt = select.appendChild(document.createElement(\"option\"));\n    input = div.getElementsByTagName(\"input\")[0];\n    a.style.cssText = \"top:1px;float:left;opacity:.5\";\n    support = {\n      // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n      getSetAttribute: div.className !== \"t\",\n      // IE strips leading whitespace when .innerHTML is used\n      leadingWhitespace: div.firstChild.nodeType === 3,\n      // Make sure that tbody elements aren't automatically inserted\n      // IE will insert them into empty tables\n      tbody: !div.getElementsByTagName(\"tbody\").length,\n      // Make sure that link elements get serialized correctly by innerHTML\n      // This requires a wrapper element in IE\n      htmlSerialize: !!div.getElementsByTagName(\"link\").length,\n      // Get the style information from getAttribute\n      // (IE uses .cssText instead)\n      style: /top/.test(a.getAttribute(\"style\")),\n      // Make sure that URLs aren't manipulated\n      // (IE normalizes it by default)\n      hrefNormalized: a.getAttribute(\"href\") === \"/a\",\n      // Make sure that element opacity exists\n      // (IE uses filter instead)\n      // Use a regex to work around a WebKit issue. See #5145\n      opacity: /^0.5/.test(a.style.opacity),\n      // Verify style float existence\n      // (IE uses styleFloat instead of cssFloat)\n      cssFloat: !!a.style.cssFloat,\n      // Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n      checkOn: !!input.value,\n      // Make sure that a selected-by-default option has a working selected property.\n      // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n      optSelected: opt.selected,\n      // Tests for enctype support on a form (#6743)\n      enctype: !!document.createElement(\"form\").enctype,\n      // Makes sure cloning an html5 element does not cause problems\n      // Where outerHTML is undefined, this still works\n      html5Clone: document.createElement(\"nav\").cloneNode(true).outerHTML !== \"<:nav></:nav>\",\n      // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode\n      boxModel: document.compatMode === \"CSS1Compat\",\n      // Will be defined later\n      deleteExpando: true,\n      noCloneEvent: true,\n      inlineBlockNeedsLayout: false,\n      shrinkWrapBlocks: false,\n      reliableMarginRight: true,\n      boxSizingReliable: true,\n      pixelPosition: false\n    }; // Make sure checked status is properly cloned\n\n    input.checked = true;\n    support.noCloneChecked = input.cloneNode(true).checked; // Make sure that the options inside disabled selects aren't marked as disabled\n    // (WebKit marks them as disabled)\n\n    select.disabled = true;\n    support.optDisabled = !opt.disabled; // Support: IE<9\n\n    try {\n      delete div.test;\n    } catch (e) {\n      support.deleteExpando = false;\n    } // Check if we can trust getAttribute(\"value\")\n\n\n    input = document.createElement(\"input\");\n    input.setAttribute(\"value\", \"\");\n    support.input = input.getAttribute(\"value\") === \"\"; // Check if an input maintains its value after becoming a radio\n\n    input.value = \"t\";\n    input.setAttribute(\"type\", \"radio\");\n    support.radioValue = input.value === \"t\"; // #11217 - WebKit loses check when the name is after the checked attribute\n\n    input.setAttribute(\"checked\", \"t\");\n    input.setAttribute(\"name\", \"t\");\n    fragment = document.createDocumentFragment();\n    fragment.appendChild(input); // Check if a disconnected checkbox will retain its checked\n    // value of true after appended to the DOM (IE6/7)\n\n    support.appendChecked = input.checked; // WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE<9\n    // Opera does not clone events (and typeof div.attachEvent === undefined).\n    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\n    if (div.attachEvent) {\n      div.attachEvent(\"onclick\", function () {\n        support.noCloneEvent = false;\n      });\n      div.cloneNode(true).click();\n    } // Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)\n    // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php\n\n\n    for (i in {\n      submit: true,\n      change: true,\n      focusin: true\n    }) {\n      div.setAttribute(eventName = \"on\" + i, \"t\");\n      support[i + \"Bubbles\"] = eventName in window || div.attributes[eventName].expando === false;\n    }\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\"; // Run tests that need a body at doc ready\n\n    jQuery(function () {\n      var container,\n          marginDiv,\n          tds,\n          divReset = \"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",\n          body = document.getElementsByTagName(\"body\")[0];\n\n      if (!body) {\n        // Return for frameset docs that don't have a body\n        return;\n      }\n\n      container = document.createElement(\"div\");\n      container.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n      body.appendChild(container).appendChild(div); // Support: IE8\n      // Check if table cells still have offsetWidth/Height when they are set\n      // to display:none and there are still other visible table cells in a\n      // table row; if so, offsetWidth/Height are not reliable for use when\n      // determining if an element has been hidden directly using\n      // display:none (it is still safe to use offsets if a parent element is\n      // hidden; don safety goggles and see bug #4512 for more information).\n\n      div.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n      tds = div.getElementsByTagName(\"td\");\n      tds[0].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n      isSupported = tds[0].offsetHeight === 0;\n      tds[0].style.display = \"\";\n      tds[1].style.display = \"none\"; // Support: IE8\n      // Check if empty table cells still have offsetWidth/Height\n\n      support.reliableHiddenOffsets = isSupported && tds[0].offsetHeight === 0; // Check box-sizing and margin behavior\n\n      div.innerHTML = \"\";\n      div.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\";\n      support.boxSizing = div.offsetWidth === 4;\n      support.doesNotIncludeMarginInBodyOffset = body.offsetTop !== 1; // Use window.getComputedStyle because jsdom on node.js will break without it.\n\n      if (window.getComputedStyle) {\n        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== \"1%\";\n        support.boxSizingReliable = (window.getComputedStyle(div, null) || {\n          width: \"4px\"\n        }).width === \"4px\"; // Check if div with explicit width and no margin-right incorrectly\n        // gets computed margin-right based on width of container. (#3333)\n        // Fails in WebKit before Feb 2011 nightlies\n        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\n        marginDiv = div.appendChild(document.createElement(\"div\"));\n        marginDiv.style.cssText = div.style.cssText = divReset;\n        marginDiv.style.marginRight = marginDiv.style.width = \"0\";\n        div.style.width = \"1px\";\n        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);\n      }\n\n      if (_typeof(div.style.zoom) !== core_strundefined) {\n        // Support: IE<8\n        // Check if natively block-level elements act like inline-block\n        // elements when setting their display to 'inline' and giving\n        // them layout\n        div.innerHTML = \"\";\n        div.style.cssText = divReset + \"width:1px;padding:1px;display:inline;zoom:1\";\n        support.inlineBlockNeedsLayout = div.offsetWidth === 3; // Support: IE6\n        // Check if elements with layout shrink-wrap their children\n\n        div.style.display = \"block\";\n        div.innerHTML = \"<div></div>\";\n        div.firstChild.style.width = \"5px\";\n        support.shrinkWrapBlocks = div.offsetWidth !== 3;\n\n        if (support.inlineBlockNeedsLayout) {\n          // Prevent IE 6 from affecting layout for positioned elements #11048\n          // Prevent IE from shrinking the body in IE 7 mode #12869\n          // Support: IE<8\n          body.style.zoom = 1;\n        }\n      }\n\n      body.removeChild(container); // Null elements to avoid leaks in IE\n\n      container = div = tds = marginDiv = null;\n    }); // Null elements to avoid leaks in IE\n\n    all = select = fragment = opt = a = input = null;\n    return support;\n  }();\n\n  var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n      rmultiDash = /([A-Z])/g;\n\n  function internalData(elem, name, data, pvt\n  /* Internal Use Only */\n  ) {\n    if (!jQuery.acceptData(elem)) {\n      return;\n    }\n\n    var thisCache,\n        ret,\n        internalKey = jQuery.expando,\n        getByName = typeof name === \"string\",\n        // We have to handle DOM nodes and JS objects differently because IE6-7\n    // can't GC object references properly across the DOM-JS boundary\n    isNode = elem.nodeType,\n        // Only DOM nodes need the global jQuery cache; JS object data is\n    // attached directly to the object so GC can occur automatically\n    cache = isNode ? jQuery.cache : elem,\n        // Only defining an ID for JS objects if its cache already exists allows\n    // the code to shortcut on the same path as a DOM node with no cache\n    id = isNode ? elem[internalKey] : elem[internalKey] && internalKey; // Avoid doing any more work than we need to when trying to get data on an\n    // object that has no data at all\n\n    if ((!id || !cache[id] || !pvt && !cache[id].data) && getByName && data === undefined) {\n      return;\n    }\n\n    if (!id) {\n      // Only DOM nodes need a new unique ID for each element since their data\n      // ends up in the global cache\n      if (isNode) {\n        elem[internalKey] = id = core_deletedIds.pop() || jQuery.guid++;\n      } else {\n        id = internalKey;\n      }\n    }\n\n    if (!cache[id]) {\n      cache[id] = {}; // Avoids exposing jQuery metadata on plain JS objects when the object\n      // is serialized using JSON.stringify\n\n      if (!isNode) {\n        cache[id].toJSON = jQuery.noop;\n      }\n    } // An object can be passed to jQuery.data instead of a key/value pair; this gets\n    // shallow copied over onto the existing cache\n\n\n    if (_typeof(name) === \"object\" || typeof name === \"function\") {\n      if (pvt) {\n        cache[id] = jQuery.extend(cache[id], name);\n      } else {\n        cache[id].data = jQuery.extend(cache[id].data, name);\n      }\n    }\n\n    thisCache = cache[id]; // jQuery data() is stored in a separate object inside the object's internal data\n    // cache in order to avoid key collisions between internal data and user-defined\n    // data.\n\n    if (!pvt) {\n      if (!thisCache.data) {\n        thisCache.data = {};\n      }\n\n      thisCache = thisCache.data;\n    }\n\n    if (data !== undefined) {\n      thisCache[jQuery.camelCase(name)] = data;\n    } // Check for both converted-to-camel and non-converted data property names\n    // If a data property was specified\n\n\n    if (getByName) {\n      // First Try to find as-is property data\n      ret = thisCache[name]; // Test for null|undefined property data\n\n      if (ret == null) {\n        // Try to find the camelCased property\n        ret = thisCache[jQuery.camelCase(name)];\n      }\n    } else {\n      ret = thisCache;\n    }\n\n    return ret;\n  }\n\n  function internalRemoveData(elem, name, pvt) {\n    if (!jQuery.acceptData(elem)) {\n      return;\n    }\n\n    var i,\n        l,\n        thisCache,\n        isNode = elem.nodeType,\n        // See jQuery.data for more information\n    cache = isNode ? jQuery.cache : elem,\n        id = isNode ? elem[jQuery.expando] : jQuery.expando; // If there is already no cache entry for this object, there is no\n    // purpose in continuing\n\n    if (!cache[id]) {\n      return;\n    }\n\n    if (name) {\n      thisCache = pvt ? cache[id] : cache[id].data;\n\n      if (thisCache) {\n        // Support array or space separated string names for data keys\n        if (!jQuery.isArray(name)) {\n          // try the string as a key before any manipulation\n          if (name in thisCache) {\n            name = [name];\n          } else {\n            // split the camel cased version by spaces unless a key with the spaces exists\n            name = jQuery.camelCase(name);\n\n            if (name in thisCache) {\n              name = [name];\n            } else {\n              name = name.split(\" \");\n            }\n          }\n        } else {\n          // If \"name\" is an array of keys...\n          // When data is initially created, via (\"key\", \"val\") signature,\n          // keys will be converted to camelCase.\n          // Since there is no way to tell _how_ a key was added, remove\n          // both plain key and camelCase key. #12786\n          // This will only penalize the array argument path.\n          name = name.concat(jQuery.map(name, jQuery.camelCase));\n        }\n\n        for (i = 0, l = name.length; i < l; i++) {\n          delete thisCache[name[i]];\n        } // If there is no data left in the cache, we want to continue\n        // and let the cache object itself get destroyed\n\n\n        if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {\n          return;\n        }\n      }\n    } // See jQuery.data for more information\n\n\n    if (!pvt) {\n      delete cache[id].data; // Don't destroy the parent cache unless the internal data object\n      // had been the only thing left in it\n\n      if (!isEmptyDataObject(cache[id])) {\n        return;\n      }\n    } // Destroy the cache\n\n\n    if (isNode) {\n      jQuery.cleanData([elem], true); // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n    } else if (jQuery.support.deleteExpando || cache != cache.window) {\n      delete cache[id]; // When all else fails, null\n    } else {\n      cache[id] = null;\n    }\n  }\n\n  jQuery.extend({\n    cache: {},\n    // Unique for each copy of jQuery on the page\n    // Non-digits removed to match rinlinejQuery\n    expando: \"jQuery\" + (core_version + Math.random()).replace(/\\D/g, \"\"),\n    // The following elements throw uncatchable exceptions if you\n    // attempt to add expando properties to them.\n    noData: {\n      \"embed\": true,\n      // Ban all objects except for Flash (which handle expandos)\n      \"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n      \"applet\": true\n    },\n    hasData: function hasData(elem) {\n      elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];\n      return !!elem && !isEmptyDataObject(elem);\n    },\n    data: function data(elem, name, _data) {\n      return internalData(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      return internalRemoveData(elem, name);\n    },\n    // For internal use only.\n    _data: function _data(elem, name, data) {\n      return internalData(elem, name, data, true);\n    },\n    _removeData: function _removeData(elem, name) {\n      return internalRemoveData(elem, name, true);\n    },\n    // A method for determining if a DOM node can handle the data expando\n    acceptData: function acceptData(elem) {\n      // Do not set data on non-element because it will not be cleared (#8335).\n      if (elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9) {\n        return false;\n      }\n\n      var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]; // nodes accept data unless otherwise specified; rejection can be conditional\n\n      return !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var attrs,\n          name,\n          elem = this[0],\n          i = 0,\n          data = null; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = jQuery.data(elem);\n\n          if (elem.nodeType === 1 && !jQuery._data(elem, \"parsedAttrs\")) {\n            attrs = elem.attributes;\n\n            for (; i < attrs.length; i++) {\n              name = attrs[i].name;\n\n              if (!name.indexOf(\"data-\")) {\n                name = jQuery.camelCase(name.slice(5));\n                dataAttr(elem, name, data[name]);\n              }\n            }\n\n            jQuery._data(elem, \"parsedAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          jQuery.data(this, key);\n        });\n      }\n\n      return jQuery.access(this, function (value) {\n        if (value === undefined) {\n          // Try to fetch any internally stored data first\n          return elem ? dataAttr(elem, key, jQuery.data(elem, key)) : null;\n        }\n\n        this.each(function () {\n          jQuery.data(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        jQuery.removeData(this, key);\n      });\n    }\n  });\n\n  function dataAttr(elem, key, data) {\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if (data === undefined && elem.nodeType === 1) {\n      var name = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null : // Only convert to a number if it doesn't change the string\n          +data + \"\" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        jQuery.data(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  } // checks a cache object for emptiness\n\n\n  function isEmptyDataObject(obj) {\n    var name;\n\n    for (name in obj) {\n      // if the public data object is empty, the private is still empty\n      if (name === \"data\" && jQuery.isEmptyObject(obj[name])) {\n        continue;\n      }\n\n      if (name !== \"toJSON\") {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = jQuery._data(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || jQuery.isArray(data)) {\n            queue = jQuery._data(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      hooks.cur = fn;\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // not intended for public consumption - generates a queueHooks object, or returns the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return jQuery._data(elem, key) || jQuery._data(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          jQuery._removeData(elem, type + \"queue\");\n\n          jQuery._removeData(elem, key);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    // Based off of the plugin by Clint Helfers, with permission.\n    // http://blindsignals.com/index.php/2009/07/jquery-delay/\n    delay: function delay(time, type) {\n      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n      type = type || \"fx\";\n      return this.queue(type, function (next, hooks) {\n        var timeout = setTimeout(next, time);\n\n        hooks.stop = function () {\n          clearTimeout(timeout);\n        };\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = jQuery._data(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var nodeHook,\n      boolHook,\n      rclass = /[\\t\\r\\n]/g,\n      rreturn = /\\r/g,\n      rfocusable = /^(?:input|select|textarea|button|object)$/i,\n      rclickable = /^(?:a|area)$/i,\n      rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,\n      ruseDefault = /^(?:checked|selected)$/i,\n      getSetAttribute = jQuery.support.getSetAttribute,\n      getSetInput = jQuery.support.input;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    },\n    prop: function prop(name, value) {\n      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      name = jQuery.propFix[name] || name;\n      return this.each(function () {\n        // try/catch handles cases where IE balks (such as removing a property on window)\n        try {\n          this[name] = undefined;\n          delete this[name];\n        } catch (e) {}\n      });\n    },\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          clazz,\n          j,\n          i = 0,\n          len = this.length,\n          proceed = typeof value === \"string\" && value;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, this.className));\n        });\n      }\n\n      if (proceed) {\n        // The disjunction here is for better compressibility (see removeClass)\n        classes = (value || \"\").match(core_rnotwhite) || [];\n\n        for (; i < len; i++) {\n          elem = this[i];\n          cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \" \");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            }\n\n            elem.className = jQuery.trim(cur);\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          clazz,\n          j,\n          i = 0,\n          len = this.length,\n          proceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, this.className));\n        });\n      }\n\n      if (proceed) {\n        classes = (value || \"\").match(core_rnotwhite) || [];\n\n        for (; i < len; i++) {\n          elem = this[i]; // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \"\");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") >= 0) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            }\n\n            elem.className = value ? jQuery.trim(cur) : \"\";\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value),\n          isBool = typeof stateVal === \"boolean\";\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        if (type === \"string\") {\n          // toggle individual class names\n          var className,\n              i = 0,\n              self = jQuery(this),\n              state = stateVal,\n              classNames = value.match(core_rnotwhite) || [];\n\n          while (className = classNames[i++]) {\n            // check each className given, space separated list\n            state = isBool ? state : !self.hasClass(className);\n            self[state ? \"addClass\" : \"removeClass\"](className);\n          } // Toggle whole class name\n\n        } else if (type === core_strundefined || type === \"boolean\") {\n          if (this.className) {\n            // store className if set\n            jQuery._data(this, \"__className__\", this.className);\n          } // If the element has a class name or if we're passed \"false\",\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          this.className = this.className || value === false ? \"\" : jQuery._data(this, \"__className__\") || \"\";\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className = \" \" + selector + \" \",\n          i = 0,\n          l = this.length;\n\n      for (; i < l; i++) {\n        if (this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf(className) >= 0) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    val: function val(value) {\n      var ret,\n          hooks,\n          isFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value;\n          return typeof ret === \"string\" ? // handle most common string cases\n          ret.replace(rreturn, \"\") : // handle cases where value is null/undef or number\n          ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      isFunction = jQuery.isFunction(value);\n      return this.each(function (i) {\n        var val,\n            self = jQuery(this);\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (isFunction) {\n          val = value.call(this, i, self.val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (jQuery.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          // attributes.value is undefined in Blackberry 4.7 but\n          // uses .value. See #6932\n          var val = elem.attributes.value;\n          return !val || val.specified ? elem.value : elem.text;\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\" || index < 0,\n              values = one ? null : [],\n              max = one ? index + 1 : options.length,\n              i = index < 0 ? max : one ? index : 0; // Loop through all the selected options\n\n          for (; i < max; i++) {\n            option = options[i]; // oldIE doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && ( // Don't return options that are disabled or in a disabled optgroup\n            jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var values = jQuery.makeArray(value);\n          jQuery(elem).find(\"option\").each(function () {\n            this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;\n          });\n\n          if (!values.length) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    },\n    attr: function attr(elem, name, value) {\n      var hooks,\n          notxml,\n          ret,\n          nType = elem.nodeType; // don't get/set attributes on text, comment and attribute nodes\n\n      if (!elem || nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (_typeof(elem.getAttribute) === core_strundefined) {\n        return jQuery.prop(elem, name, value);\n      }\n\n      notxml = nType !== 1 || !jQuery.isXMLDoc(elem); // All attributes are lowercase\n      // Grab necessary hook if one is defined\n\n      if (notxml) {\n        name = name.toLowerCase();\n        hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n        } else if (hooks && notxml && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        } else {\n          elem.setAttribute(name, value + \"\");\n          return value;\n        }\n      } else if (hooks && notxml && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      } else {\n        // In IE9+, Flash objects don't have .getAttribute (#12945)\n        // Support: IE9+\n        if (_typeof(elem.getAttribute) !== core_strundefined) {\n          ret = elem.getAttribute(name);\n        } // Non-existent attributes return null, we normalize to undefined\n\n\n        return ret == null ? undefined : ret;\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          propName,\n          i = 0,\n          attrNames = value && value.match(core_rnotwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          propName = jQuery.propFix[name] || name; // Boolean attributes get special treatment (#10870)\n\n          if (rboolean.test(name)) {\n            // Set corresponding property to false for boolean attributes\n            // Also clear defaultChecked/defaultSelected (if appropriate) for IE<8\n            if (!getSetAttribute && ruseDefault.test(name)) {\n              elem[jQuery.camelCase(\"default-\" + name)] = elem[propName] = false;\n            } else {\n              elem[propName] = false;\n            } // See #9699 for explanation of this approach (setting first, then removal)\n\n          } else {\n            jQuery.attr(elem, name, \"\");\n          }\n\n          elem.removeAttribute(getSetAttribute ? name : propName);\n        }\n      }\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\n            // Setting the type on a radio button after the value resets the value in IE6-9\n            // Reset value to default in case type is set after value during creation\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    propFix: {\n      tabindex: \"tabIndex\",\n      readonly: \"readOnly\",\n      \"for\": \"htmlFor\",\n      \"class\": \"className\",\n      maxlength: \"maxLength\",\n      cellspacing: \"cellSpacing\",\n      cellpadding: \"cellPadding\",\n      rowspan: \"rowSpan\",\n      colspan: \"colSpan\",\n      usemap: \"useMap\",\n      frameborder: \"frameBorder\",\n      contenteditable: \"contentEditable\"\n    },\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          notxml,\n          nType = elem.nodeType; // don't get/set properties on text, comment and attribute nodes\n\n      if (!elem || nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);\n\n      if (notxml) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        } else {\n          return elem[name] = value;\n        }\n      } else {\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n          return ret;\n        } else {\n          return elem[name];\n        }\n      }\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          var attributeNode = elem.getAttributeNode(\"tabindex\");\n          return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : undefined;\n        }\n      }\n    }\n  }); // Hook for boolean attributes\n\n  boolHook = {\n    get: function get(elem, name) {\n      var // Use .prop to determine if this attribute is understood as boolean\n      prop = jQuery.prop(elem, name),\n          // Fetch it accordingly\n      attr = typeof prop === \"boolean\" && elem.getAttribute(name),\n          detail = typeof prop === \"boolean\" ? getSetInput && getSetAttribute ? attr != null : // oldIE fabricates an empty string for missing boolean attributes\n      // and conflates checked/selected into attroperties\n      ruseDefault.test(name) ? elem[jQuery.camelCase(\"default-\" + name)] : !!attr : // fetch an attribute node for properties not recognized as boolean\n      elem.getAttributeNode(name);\n      return detail && detail.value !== false ? name.toLowerCase() : undefined;\n    },\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {\n        // IE<8 needs the *property* name\n        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name); // Use defaultChecked and defaultSelected for oldIE\n      } else {\n        elem[jQuery.camelCase(\"default-\" + name)] = elem[name] = true;\n      }\n\n      return name;\n    }\n  }; // fix oldIE value attroperty\n\n  if (!getSetInput || !getSetAttribute) {\n    jQuery.attrHooks.value = {\n      get: function get(elem, name) {\n        var ret = elem.getAttributeNode(name);\n        return jQuery.nodeName(elem, \"input\") ? // Ignore the value *property* by using defaultValue\n        elem.defaultValue : ret && ret.specified ? ret.value : undefined;\n      },\n      set: function set(elem, value, name) {\n        if (jQuery.nodeName(elem, \"input\")) {\n          // Does not return so that setAttribute is also used\n          elem.defaultValue = value;\n        } else {\n          // Use nodeHook if defined (#1954); otherwise setAttribute is fine\n          return nodeHook && nodeHook.set(elem, value, name);\n        }\n      }\n    };\n  } // IE6/7 do not support getting/setting some attributes with get/setAttribute\n\n\n  if (!getSetAttribute) {\n    // Use this for any attribute in IE6/7\n    // This fixes almost every IE6/7 issue\n    nodeHook = jQuery.valHooks.button = {\n      get: function get(elem, name) {\n        var ret = elem.getAttributeNode(name);\n        return ret && (name === \"id\" || name === \"name\" || name === \"coords\" ? ret.value !== \"\" : ret.specified) ? ret.value : undefined;\n      },\n      set: function set(elem, value, name) {\n        // Set the existing or create a new attribute node\n        var ret = elem.getAttributeNode(name);\n\n        if (!ret) {\n          elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));\n        }\n\n        ret.value = value += \"\"; // Break association with cloned elements by also using setAttribute (#9646)\n\n        return name === \"value\" || value === elem.getAttribute(name) ? value : undefined;\n      }\n    }; // Set contenteditable to false on removals(#10429)\n    // Setting to empty string throws an error as an invalid value\n\n    jQuery.attrHooks.contenteditable = {\n      get: nodeHook.get,\n      set: function set(elem, value, name) {\n        nodeHook.set(elem, value === \"\" ? false : value, name);\n      }\n    }; // Set width and height to auto instead of 0 on empty string( Bug #8150 )\n    // This is for removals\n\n    jQuery.each([\"width\", \"height\"], function (i, name) {\n      jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {\n        set: function set(elem, value) {\n          if (value === \"\") {\n            elem.setAttribute(name, \"auto\");\n            return value;\n          }\n        }\n      });\n    });\n  } // Some attributes require a special call on IE\n  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n\n  if (!jQuery.support.hrefNormalized) {\n    jQuery.each([\"href\", \"src\", \"width\", \"height\"], function (i, name) {\n      jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {\n        get: function get(elem) {\n          var ret = elem.getAttribute(name, 2);\n          return ret == null ? undefined : ret;\n        }\n      });\n    }); // href/src property should get the full normalized URL (#10299/#12915)\n\n    jQuery.each([\"href\", \"src\"], function (i, name) {\n      jQuery.propHooks[name] = {\n        get: function get(elem) {\n          return elem.getAttribute(name, 4);\n        }\n      };\n    });\n  }\n\n  if (!jQuery.support.style) {\n    jQuery.attrHooks.style = {\n      get: function get(elem) {\n        // Return undefined in the case of empty string\n        // Note: IE uppercases css property names, but if we were to .toLowerCase()\n        // .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n        return elem.style.cssText || undefined;\n      },\n      set: function set(elem, value) {\n        return elem.style.cssText = value + \"\";\n      }\n    };\n  } // Safari mis-reports the default selected property of an option\n  // Accessing the parent's selectedIndex property fixes it\n\n\n  if (!jQuery.support.optSelected) {\n    jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {\n      get: function get(elem) {\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex; // Make sure that it also works with optgroups, see #5701\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n\n        return null;\n      }\n    });\n  } // IE6/7 call enctype encoding\n\n\n  if (!jQuery.support.enctype) {\n    jQuery.propFix.enctype = \"encoding\";\n  } // Radios and checkboxes getter/setter\n\n\n  if (!jQuery.support.checkOn) {\n    jQuery.each([\"radio\", \"checkbox\"], function () {\n      jQuery.valHooks[this] = {\n        get: function get(elem) {\n          // Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n          return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n        }\n      };\n    });\n  }\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {\n      set: function set(elem, value) {\n        if (jQuery.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;\n        }\n      }\n    });\n  });\n  var rformElems = /^(?:input|select|textarea)$/i,\n      rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|contextmenu)|click/,\n      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var tmp,\n          events,\n          t,\n          handleObjIn,\n          special,\n          eventHandle,\n          handleObj,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = jQuery._data(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)\n\n\n      if (!elemData) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = {};\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return _typeof(jQuery) !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;\n        }; // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\n\n        eventHandle.elem = elem;\n      } // Handle multiple events separated by a space\n      // jQuery(...).bind(\"mouseover mouseout\", fn);\n\n\n      types = (types || \"\").match(core_rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // If event changes its type, use the special event handlers for the changed type\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener/attachEvent if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            // Bind the global event handler to the element\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle, false);\n            } else if (elem.attachEvent) {\n              elem.attachEvent(\"on\" + type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      } // Nullify elem to prevent memory leaks in IE\n\n\n      elem = null;\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          handleObj,\n          tmp,\n          origCount,\n          t,\n          events,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = jQuery.hasData(elem) && jQuery._data(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(core_rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        delete elemData.handle; // removeData also checks for emptiness and clears the expando if empty\n        // so use it instead of delete\n\n        jQuery._removeData(elem, \"events\");\n      }\n    },\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var handle,\n          ontype,\n          cur,\n          bubbleType,\n          special,\n          tmp,\n          i,\n          eventPath = [elem || document],\n          type = core_hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = core_hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") >= 0) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event);\n      event.isTrigger = true;\n      event.namespace = namespaces.join(\".\");\n      event.namespace_re = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (jQuery._data(cur, \"events\") || {})[event.type] && jQuery._data(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {\n          event.preventDefault();\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) && !(type === \"click\" && jQuery.nodeName(elem, \"a\")) && jQuery.acceptData(elem)) {\n          // Call a native DOM method on the target with the same name name as the event.\n          // Can't use an .isFunction() check here because IE6/7 fails that test.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && elem[type] && !jQuery.isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            try {\n              elem[type]();\n            } catch (e) {// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n              // only reproducible on winXP IE8 native, not IE9 in IE8 mode\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    dispatch: function dispatch(event) {\n      // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(event);\n      var i,\n          ret,\n          handleObj,\n          matched,\n          j,\n          handlerQueue = [],\n          args = core_slice.call(arguments),\n          handlers = (jQuery._data(this, \"events\") || {})[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n      args[0] = event;\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // Triggered event must either 1) have no namespace, or\n          // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var sel,\n          handleObj,\n          matches,\n          i,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n      // Black-hole SVG <use> instance trees (#13180)\n      // Avoid non-left-click bubbling in Firefox (#3861)\n\n      if (delegateCount && cur.nodeType && (!event.button || event.type !== \"click\")) {\n        for (; cur != this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\")) {\n            matches = [];\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matches[sel] === undefined) {\n                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matches[sel]) {\n                matches.push(handleObj);\n              }\n            }\n\n            if (matches.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matches\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: this,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    fix: function fix(event) {\n      if (event[jQuery.expando]) {\n        return event;\n      } // Create a writable copy of the event object and normalize some properties\n\n\n      var i,\n          prop,\n          copy,\n          type = event.type,\n          originalEvent = event,\n          fixHook = this.fixHooks[type];\n\n      if (!fixHook) {\n        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};\n      }\n\n      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n      event = new jQuery.Event(originalEvent);\n      i = copy.length;\n\n      while (i--) {\n        prop = copy[i];\n        event[prop] = originalEvent[prop];\n      } // Support: IE<9\n      // Fix target property (#1925)\n\n\n      if (!event.target) {\n        event.target = originalEvent.srcElement || document;\n      } // Support: Chrome 23+, Safari?\n      // Target should not be a text node (#504, #13143)\n\n\n      if (event.target.nodeType === 3) {\n        event.target = event.target.parentNode;\n      } // Support: IE<9\n      // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\n\n      event.metaKey = !!event.metaKey;\n      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;\n    },\n    // Includes some event props shared by KeyEvent and MouseEvent\n    props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n    fixHooks: {},\n    keyHooks: {\n      props: \"char charCode key keyCode\".split(\" \"),\n      filter: function filter(event, original) {\n        // Add which for key events\n        if (event.which == null) {\n          event.which = original.charCode != null ? original.charCode : original.keyCode;\n        }\n\n        return event;\n      }\n    },\n    mouseHooks: {\n      props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n      filter: function filter(event, original) {\n        var body,\n            eventDoc,\n            doc,\n            button = original.button,\n            fromElement = original.fromElement; // Calculate pageX/Y if missing and clientX/Y available\n\n        if (event.pageX == null && original.clientX != null) {\n          eventDoc = event.target.ownerDocument || document;\n          doc = eventDoc.documentElement;\n          body = eventDoc.body;\n          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n        } // Add relatedTarget, if necessary\n\n\n        if (!event.relatedTarget && fromElement) {\n          event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n        } // Add which for click: 1 === left; 2 === middle; 3 === right\n        // Note: button is not normalized, so don't use it\n\n\n        if (!event.which && button !== undefined) {\n          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n        }\n\n        return event;\n      }\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // For checkbox, fire native event so checked state will be right\n        trigger: function trigger() {\n          if (jQuery.nodeName(this, \"input\") && this.type === \"checkbox\" && this.click) {\n            this.click();\n            return false;\n          }\n        }\n      },\n      focus: {\n        // Fire native event if possible so blur/focus sequence is correct\n        trigger: function trigger() {\n          if (this !== document.activeElement && this.focus) {\n            try {\n              this.focus();\n              return false;\n            } catch (e) {// Support: IE<9\n              // If we error on focus to hidden element (#1486, #12518),\n              // let .trigger() run the handlers\n            }\n          }\n        },\n        delegateType: \"focusin\"\n      },\n      blur: {\n        trigger: function trigger() {\n          if (this === document.activeElement && this.blur) {\n            this.blur();\n            return false;\n          }\n        },\n        delegateType: \"focusout\"\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Even when returnValue equals to undefined Firefox will still show alert\n          if (event.result !== undefined) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    },\n    simulate: function simulate(type, elem, event, bubble) {\n      // Piggyback on a donor event to simulate a different one.\n      // Fake originalEvent to avoid donor's stopPropagation, but if the\n      // simulated event prevents default then we do the same on the donor.\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true,\n        originalEvent: {}\n      });\n\n      if (bubble) {\n        jQuery.event.trigger(e, null, elem);\n      } else {\n        jQuery.event.dispatch.call(elem, e);\n      }\n\n      if (e.isDefaultPrevented()) {\n        event.preventDefault();\n      }\n    }\n  };\n  jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle, false);\n    }\n  } : function (elem, type, handle) {\n    var name = \"on\" + type;\n\n    if (elem.detachEvent) {\n      // #8545, #7054, preventing memory leaks for custom events in IE6-8\n      // detachEvent needed property on element, by name of that event, to properly expose it to GC\n      if (_typeof(elem[name]) === core_strundefined) {\n        elem[name] = null;\n      }\n\n      elem.detachEvent(name, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (!e) {\n        return;\n      } // If preventDefault exists, run it on the original event\n\n\n      if (e.preventDefault) {\n        e.preventDefault(); // Support: IE\n        // Otherwise set the returnValue property of the original event to false\n      } else {\n        e.returnValue = false;\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (!e) {\n        return;\n      } // If stopPropagation exists, run it on the original event\n\n\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } // Support: IE\n      // Set the cancelBubble property of the original event to true\n\n\n      e.cancelBubble = true;\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      this.isImmediatePropagationStopped = returnTrue;\n      this.stopPropagation();\n    }\n  }; // Create mouseenter/leave events using mouseover/out and event-time checks\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mousenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  }); // IE submit delegation\n\n  if (!jQuery.support.submitBubbles) {\n    jQuery.event.special.submit = {\n      setup: function setup() {\n        // Only need this for delegated form submit events\n        if (jQuery.nodeName(this, \"form\")) {\n          return false;\n        } // Lazy-add a submit handler when a descendant form may potentially be submitted\n\n\n        jQuery.event.add(this, \"click._submit keypress._submit\", function (e) {\n          // Node name check avoids a VML-related crash in IE (#9807)\n          var elem = e.target,\n              form = jQuery.nodeName(elem, \"input\") || jQuery.nodeName(elem, \"button\") ? elem.form : undefined;\n\n          if (form && !jQuery._data(form, \"submitBubbles\")) {\n            jQuery.event.add(form, \"submit._submit\", function (event) {\n              event._submit_bubble = true;\n            });\n\n            jQuery._data(form, \"submitBubbles\", true);\n          }\n        }); // return undefined since we don't need an event listener\n      },\n      postDispatch: function postDispatch(event) {\n        // If form was submitted by the user, bubble the event up the tree\n        if (event._submit_bubble) {\n          delete event._submit_bubble;\n\n          if (this.parentNode && !event.isTrigger) {\n            jQuery.event.simulate(\"submit\", this.parentNode, event, true);\n          }\n        }\n      },\n      teardown: function teardown() {\n        // Only need this for delegated form submit events\n        if (jQuery.nodeName(this, \"form\")) {\n          return false;\n        } // Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\n\n        jQuery.event.remove(this, \"._submit\");\n      }\n    };\n  } // IE change delegation and checkbox/radio fix\n\n\n  if (!jQuery.support.changeBubbles) {\n    jQuery.event.special.change = {\n      setup: function setup() {\n        if (rformElems.test(this.nodeName)) {\n          // IE doesn't fire change on a check/radio until blur; trigger it on click\n          // after a propertychange. Eat the blur-change in special.change.handle.\n          // This still fires onchange a second time for check/radio after blur.\n          if (this.type === \"checkbox\" || this.type === \"radio\") {\n            jQuery.event.add(this, \"propertychange._change\", function (event) {\n              if (event.originalEvent.propertyName === \"checked\") {\n                this._just_changed = true;\n              }\n            });\n            jQuery.event.add(this, \"click._change\", function (event) {\n              if (this._just_changed && !event.isTrigger) {\n                this._just_changed = false;\n              } // Allow triggered, simulated change events (#11500)\n\n\n              jQuery.event.simulate(\"change\", this, event, true);\n            });\n          }\n\n          return false;\n        } // Delegated event; lazy-add a change handler on descendant inputs\n\n\n        jQuery.event.add(this, \"beforeactivate._change\", function (e) {\n          var elem = e.target;\n\n          if (rformElems.test(elem.nodeName) && !jQuery._data(elem, \"changeBubbles\")) {\n            jQuery.event.add(elem, \"change._change\", function (event) {\n              if (this.parentNode && !event.isSimulated && !event.isTrigger) {\n                jQuery.event.simulate(\"change\", this.parentNode, event, true);\n              }\n            });\n\n            jQuery._data(elem, \"changeBubbles\", true);\n          }\n        });\n      },\n      handle: function handle(event) {\n        var elem = event.target; // Swallow native change events from checkbox/radio, we already triggered them above\n\n        if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== \"radio\" && elem.type !== \"checkbox\") {\n          return event.handleObj.handler.apply(this, arguments);\n        }\n      },\n      teardown: function teardown() {\n        jQuery.event.remove(this, \"._change\");\n        return !rformElems.test(this.nodeName);\n      }\n    };\n  } // Create \"bubbling\" focus and blur events\n\n\n  if (!jQuery.support.focusinBubbles) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler while someone wants focusin/focusout\n      var attaches = 0,\n          handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          if (attaches++ === 0) {\n            document.addEventListener(orig, handler, true);\n          }\n        },\n        teardown: function teardown() {\n          if (--attaches === 0) {\n            document.removeEventListener(orig, handler, true);\n          }\n        }\n      };\n    });\n  }\n\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn,\n    /*INTERNAL*/\n    one) {\n      var type, origFn; // Types can be a map of types/handlers\n\n      if (_typeof(types) === \"object\") {\n        // ( types-Object, selector, data )\n        if (typeof selector !== \"string\") {\n          // ( types-Object, data )\n          data = data || selector;\n          selector = undefined;\n        }\n\n        for (type in types) {\n          this.on(type, selector, data, types[type], one);\n        }\n\n        return this;\n      }\n\n      if (data == null && fn == null) {\n        // ( types, fn )\n        fn = selector;\n        data = selector = undefined;\n      } else if (fn == null) {\n        if (typeof selector === \"string\") {\n          // ( types, selector, fn )\n          fn = data;\n          data = undefined;\n        } else {\n          // ( types, data, fn )\n          fn = data;\n          data = selector;\n          selector = undefined;\n        }\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      } else if (!fn) {\n        return this;\n      }\n\n      if (one === 1) {\n        origFn = fn;\n\n        fn = function fn(event) {\n          // Can use an empty set, since event contains the info\n          jQuery().off(event);\n          return origFn.apply(this, arguments);\n        }; // Use same guid so caller can remove using origFn\n\n\n        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n      }\n\n      return this.each(function () {\n        jQuery.event.add(this, types, fn, data, selector);\n      });\n    },\n    one: function one(types, selector, data, fn) {\n      return this.on(types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    },\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    },\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  });\n  /*!\n   * Sizzle CSS Selector Engine\n   * Copyright 2012 jQuery Foundation and other contributors\n   * Released under the MIT license\n   * http://sizzlejs.com/\n   */\n\n  (function (window, undefined) {\n    var i,\n        cachedruns,\n        Expr,\n        getText,\n        isXML,\n        compile,\n        hasDuplicate,\n        outermostContext,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsXML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        sortOrder,\n        // Instance-specific data\n    expando = \"sizzle\" + -new Date(),\n        preferredDoc = window.document,\n        support = {},\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        // General-purpose constants\n    strundefined = _typeof(undefined),\n        MAX_NEGATIVE = 1 << 31,\n        // Array methods\n    arr = [],\n        pop = arr.pop,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf if we can't use a native one\n    indexOf = arr.indexOf || function (elem) {\n      var i = 0,\n          len = this.length;\n\n      for (; i < len; i++) {\n        if (this[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        // Regular expressions\n    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // http://www.w3.org/TR/css3-syntax/#characters\n    characterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        // Loosely modeled on CSS identifier characters\n    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = characterEncoding.replace(\"w\", \"w#\"),\n        // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n    operators = \"([*^$|!~]?=)\",\n        attributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace + \"*(?:\" + operators + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n        // Prefer arguments quoted,\n    //   then not containing pseudos/brackets,\n    //   then attribute selectors/non-parenthetical expressions,\n    //   then anything else\n    // These preferences are here to reduce the number of selectors\n    //   needing tokenize in the PSEUDO preFilter\n    pseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace(3, 8) + \")*)|.*)\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([\\\\x20\\\\t\\\\r\\\\n\\\\f>+~])\" + whitespace + \"*\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + characterEncoding + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + characterEncoding + \")\"),\n      \"NAME\": new RegExp(\"^\\\\[name=['\\\"]?(\" + characterEncoding + \")['\\\"]?\\\\]\"),\n      \"TAG\": new RegExp(\"^(\" + characterEncoding.replace(\"w\", \"w*\") + \")\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rsibling = /[\\x20\\t\\r\\n\\f]*[+~]/,\n        rnative = /^[^{]+\\{\\s*\\[native code/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rescape = /'|\\\\/g,\n        rattributeQuotes = /\\=[\\x20\\t\\r\\n\\f]*([^'\"\\]]*)[\\x20\\t\\r\\n\\f]*\\]/g,\n        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n        funescape = function funescape(_, escaped) {\n      var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n\n      return high !== high ? escaped : // BMP codepoint\n      high < 0 ? String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    }; // Use a stripped-down slice if we can't use a native one\n\n\n    try {\n      slice.call(preferredDoc.documentElement.childNodes, 0)[0].nodeType;\n    } catch (e) {\n      slice = function slice(i) {\n        var elem,\n            results = [];\n\n        while (elem = this[i++]) {\n          results.push(elem);\n        }\n\n        return results;\n      };\n    }\n    /**\n     * For feature detection\n     * @param {Function} fn The function to test for native support\n     */\n\n\n    function isNative(fn) {\n      return rnative.test(fn + \"\");\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var _cache,\n          keys = [];\n\n      return _cache = function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key += \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete _cache[keys.shift()];\n        }\n\n        return _cache[key] = value;\n      };\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created div and expects a boolean result\n     */\n\n\n    function assert(fn) {\n      var div = document.createElement(\"div\");\n\n      try {\n        return fn(div);\n      } catch (e) {\n        return false;\n      } finally {\n        // release memory in IE\n        div = null;\n      }\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var match, elem, m, nodeType, // QSA vars\n      i, groups, old, nid, newContext, newSelector;\n\n      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n        setDocument(context);\n      }\n\n      context = context || document;\n      results = results || [];\n\n      if (!selector || typeof selector !== \"string\") {\n        return results;\n      }\n\n      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {\n        return [];\n      }\n\n      if (!documentIsXML && !seed) {\n        // Shortcuts\n        if (match = rquickExpr.exec(selector)) {\n          // Speed-up: Sizzle(\"#ID\")\n          if (m = match[1]) {\n            if (nodeType === 9) {\n              elem = context.getElementById(m); // Check parentNode to catch when Blackberry 4.6 returns\n              // nodes that are no longer in the document #6963\n\n              if (elem && elem.parentNode) {\n                // Handle the case where IE, Opera, and Webkit return items\n                // by name instead of ID\n                if (elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } else {\n                return results;\n              }\n            } else {\n              // Context is not a document\n              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                results.push(elem);\n                return results;\n              }\n            } // Speed-up: Sizzle(\"TAG\")\n\n          } else if (match[2]) {\n            push.apply(results, slice.call(context.getElementsByTagName(selector), 0));\n            return results; // Speed-up: Sizzle(\".CLASS\")\n          } else if ((m = match[3]) && support.getByClassName && context.getElementsByClassName) {\n            push.apply(results, slice.call(context.getElementsByClassName(m), 0));\n            return results;\n          }\n        } // QSA path\n\n\n        if (support.qsa && !rbuggyQSA.test(selector)) {\n          old = true;\n          nid = expando;\n          newContext = context;\n          newSelector = nodeType === 9 && selector; // qSA works strangely on Element-rooted queries\n          // We can work around this by specifying an extra ID on the root\n          // and working up from there (Thanks to Andrew Dupont for the technique)\n          // IE 8 doesn't work on object elements\n\n          if (nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\n            groups = tokenize(selector);\n\n            if (old = context.getAttribute(\"id\")) {\n              nid = old.replace(rescape, \"\\\\$&\");\n            } else {\n              context.setAttribute(\"id\", nid);\n            }\n\n            nid = \"[id='\" + nid + \"'] \";\n            i = groups.length;\n\n            while (i--) {\n              groups[i] = nid + toSelector(groups[i]);\n            }\n\n            newContext = rsibling.test(selector) && context.parentNode || context;\n            newSelector = groups.join(\",\");\n          }\n\n          if (newSelector) {\n            try {\n              push.apply(results, slice.call(newContext.querySelectorAll(newSelector), 0));\n              return results;\n            } catch (qsaError) {} finally {\n              if (!old) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Detect xml\n     * @param {Element|Object} elem An element or a document\n     */\n\n\n    isXML = Sizzle.isXML = function (elem) {\n      // documentElement is verified for cases where it doesn't yet exist\n      // (such as loading iframes in IE - #4833)\n      var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n      return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var doc = node ? node.ownerDocument || node : preferredDoc; // If no document and documentElement is available, return\n\n      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Set our document\n\n\n      document = doc;\n      docElem = doc.documentElement; // Support tests\n\n      documentIsXML = isXML(doc); // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.tagNameNoComments = assert(function (div) {\n        div.appendChild(doc.createComment(\"\"));\n        return !div.getElementsByTagName(\"*\").length;\n      }); // Check if attributes should be retrieved by attribute nodes\n\n      support.attributes = assert(function (div) {\n        div.innerHTML = \"<select></select>\";\n\n        var type = _typeof(div.lastChild.getAttribute(\"multiple\")); // IE8 returns a string for some attributes even when not present\n\n\n        return type !== \"boolean\" && type !== \"string\";\n      }); // Check if getElementsByClassName can be trusted\n\n      support.getByClassName = assert(function (div) {\n        // Opera can't find a second classname (in 9.6)\n        div.innerHTML = \"<div class='hidden e'></div><div class='hidden'></div>\";\n\n        if (!div.getElementsByClassName || !div.getElementsByClassName(\"e\").length) {\n          return false;\n        } // Safari 3.2 caches class attributes and doesn't catch changes\n\n\n        div.lastChild.className = \"e\";\n        return div.getElementsByClassName(\"e\").length === 2;\n      }); // Check if getElementById returns elements by name\n      // Check if getElementsByName privileges form controls or returns elements by ID\n\n      support.getByName = assert(function (div) {\n        // Inject content\n        div.id = expando + 0;\n        div.innerHTML = \"<a name='\" + expando + \"'></a><div name='\" + expando + \"'></div>\";\n        docElem.insertBefore(div, docElem.firstChild); // Test\n\n        var pass = doc.getElementsByName && // buggy browsers will return fewer than the correct 2\n        doc.getElementsByName(expando).length === 2 + // buggy browsers will return more than the correct 0\n        doc.getElementsByName(expando + 0).length;\n        support.getIdNotName = !doc.getElementById(expando); // Cleanup\n\n        docElem.removeChild(div);\n        return pass;\n      }); // IE6/7 return modified attributes\n\n      Expr.attrHandle = assert(function (div) {\n        div.innerHTML = \"<a href='#'></a>\";\n        return div.firstChild && _typeof(div.firstChild.getAttribute) !== strundefined && div.firstChild.getAttribute(\"href\") === \"#\";\n      }) ? {} : {\n        \"href\": function href(elem) {\n          return elem.getAttribute(\"href\", 2);\n        },\n        \"type\": function type(elem) {\n          return elem.getAttribute(\"type\");\n        }\n      }; // ID find and filter\n\n      if (support.getIdNotName) {\n        Expr.find[\"ID\"] = function (id, context) {\n          if (_typeof(context.getElementById) !== strundefined && !documentIsXML) {\n            var m = context.getElementById(id); // Check parentNode to catch when Blackberry 4.6 returns\n            // nodes that are no longer in the document #6963\n\n            return m && m.parentNode ? [m] : [];\n          }\n        };\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n      } else {\n        Expr.find[\"ID\"] = function (id, context) {\n          if (_typeof(context.getElementById) !== strundefined && !documentIsXML) {\n            var m = context.getElementById(id);\n            return m ? m.id === id || _typeof(m.getAttributeNode) !== strundefined && m.getAttributeNode(\"id\").value === id ? [m] : undefined : [];\n          }\n        };\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = _typeof(elem.getAttributeNode) !== strundefined && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.tagNameNoComments ? function (tag, context) {\n        if (_typeof(context.getElementsByTagName) !== strundefined) {\n          return context.getElementsByTagName(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Name\n\n      Expr.find[\"NAME\"] = support.getByName && function (tag, context) {\n        if (_typeof(context.getElementsByName) !== strundefined) {\n          return context.getElementsByName(name);\n        }\n      }; // Class\n\n\n      Expr.find[\"CLASS\"] = support.getByClassName && function (className, context) {\n        if (_typeof(context.getElementsByClassName) !== strundefined && !documentIsXML) {\n          return context.getElementsByClassName(className);\n        }\n      }; // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21),\n      // no need to also add to buggyMatches since matches checks buggyQSA\n      // A support test would require too much code (would include document ready)\n\n      rbuggyQSA = [\":focus\"];\n\n      if (support.qsa = isNative(doc.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (div) {\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explictly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // http://bugs.jquery.com/ticket/12359\n          div.innerHTML = \"<select><option selected=''></option></select>\"; // IE8 - Some boolean attributes are not treated correctly\n\n          if (!div.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:checked|disabled|ismap|multiple|readonly|selected|value)\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          }\n        });\n        assert(function (div) {\n          // Opera 10-12/IE8 - ^= $= *= and empty values\n          // Should not select anything\n          div.innerHTML = \"<input type='hidden' i=''/>\";\n\n          if (div.querySelectorAll(\"[i^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:\\\"\\\"|'')\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":enabled\").length) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          div.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = isNative(matches = docElem.matchesSelector || docElem.mozMatchesSelector || docElem.webkitMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (div) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(div, \"div\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(div, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = new RegExp(rbuggyMatches.join(\"|\")); // Element contains another\n      // Purposefully does not implement inclusive descendent\n      // As in, an element does not contain itself\n\n      contains = isNative(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }; // Document order sorting\n\n      sortOrder = docElem.compareDocumentPosition ? function (a, b) {\n        var compare;\n\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        if (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b)) {\n          if (compare & 1 || a.parentNode && a.parentNode.nodeType === 11) {\n            if (a === doc || contains(preferredDoc, a)) {\n              return -1;\n            }\n\n            if (b === doc || contains(preferredDoc, b)) {\n              return 1;\n            }\n\n            return 0;\n          }\n\n          return compare & 4 ? -1 : 1;\n        }\n\n        return a.compareDocumentPosition ? -1 : 1;\n      } : function (a, b) {\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Exit early if the nodes are identical\n\n        if (a === b) {\n          hasDuplicate = true;\n          return 0; // Parentless nodes are either documents or disconnected\n        } else if (!aup || !bup) {\n          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n      }; // Always assume the presence of duplicates if sort doesn't\n      // pass them to our comparison function (as in Google Chrome).\n\n      hasDuplicate = false;\n      [0, 0].sort(sortOrder);\n      support.detectDuplicates = hasDuplicate;\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      } // Make sure that attribute selectors are quoted\n\n\n      expr = expr.replace(rattributeQuotes, \"='$1']\"); // rbuggyQSA always contains :focus, so no need for an existence check\n\n      if (support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr)) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {}\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      if ((context.ownerDocument || context) !== document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      var val; // Set document vars if needed\n\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      if (!documentIsXML) {\n        name = name.toLowerCase();\n      }\n\n      if (val = Expr.attrHandle[name]) {\n        return val(elem);\n      }\n\n      if (documentIsXML || support.attributes) {\n        return elem.getAttribute(name);\n      }\n\n      return ((val = elem.getAttributeNode(name)) || elem.getAttribute(name)) && elem[name] === true ? name : val && val.specified ? val.value : null;\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    }; // Document sorting and removing duplicates\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          i = 1,\n          j = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        for (; elem = results[i]; i++) {\n          if (elem === results[i - 1]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      }\n\n      return results;\n    };\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    } // Returns a function to use in pseudos for input types\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    } // Returns a function to use in pseudos for buttons\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    } // Returns a function to use in pseudos for positionals\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        for (; node = elem[i]; i++) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (see #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n              1 type (only|nth|...)\n              2 what (child|of-type)\n              3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n              4 xn-component of xn+y argument ([+-]?\\d*n|)\n              5 sign of xn-component\n              6 x of xn-component\n              7 sign of y-component\n              8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[5] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[4]) {\n            match[2] = match[4]; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeName) {\n          if (nodeName === \"*\") {\n            return function () {\n              return true;\n            };\n          }\n\n          nodeName = nodeName.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(elem.className || _typeof(elem.getAttribute) !== strundefined && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n          };\n        },\n        \"CHILD\": function CHILD(type, what, argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, context, xml) {\n            var cache,\n                outerCache,\n                node,\n                diff,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                outerCache = parent[expando] || (parent[expando] = {});\n                cache = outerCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = cache[0] === dirruns && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    outerCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                } // Use previously-cached element index if available\n\n              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {\n                diff = cache[1]; // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n              } else {\n                // Use the same loop as above to seek `elem` from the start\n                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                    // Cache the index of each encountered element\n                    if (useCache) {\n                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];\n                    }\n\n                    if (node === elem) {\n                      break;\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf.call(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results);\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          return function (elem) {\n            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifider\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsXML ? elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\") : elem.lang) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": function enabled(elem) {\n          return elem.disabled === false;\n        },\n        \"disabled\": function disabled(elem) {\n          return elem.disabled === true;\n        },\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n          //   not comment, processing instructions, or others\n          // Thanks to Diego Perini for the nodeName shortcut\n          //   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr; // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n          // use getAttribute instead to test this case\n\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ((attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type);\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    }; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    }\n\n    function tokenize(selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    }\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          checkNonElements = base && dir === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var data,\n            cache,\n            outerCache,\n            dirkey = dirruns + \" \" + doneName; // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {});\n\n              if ((cache = outerCache[dir]) && cache[0] === dirkey) {\n                if ((data = cache[1]) === true || data === cachedruns) {\n                  return data === true;\n                }\n              } else {\n                cache = outerCache[dir] = [dirkey];\n                cache[1] = matcher(elem, context, xml) || cachedruns;\n\n                if (cache[1] === true) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf.call(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1)).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      // A counter to specify which element is currently being matched\n      var matcherCachedRuns = 0,\n          bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, expandContext) {\n        var elem,\n            j,\n            matcher,\n            setMatched = [],\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            outermost = expandContext != null,\n            contextBackup = outermostContext,\n            // We must always have either seed elements or context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", expandContext && context.parentNode || context),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;\n\n        if (outermost) {\n          outermostContext = context !== document && context;\n          cachedruns = matcherCachedRuns;\n        } // Add elements passing elementMatchers directly to results\n        // Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\n\n        for (; (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0;\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n              cachedruns = ++matcherCachedRuns;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // Apply set filters to unmatched elements\n\n\n        matchedCount += i;\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, group\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!group) {\n          group = tokenize(selector);\n        }\n\n        i = group.length;\n\n        while (i--) {\n          cached = matcherFromTokens(group[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n      }\n\n      return cached;\n    };\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function select(selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          match = tokenize(selector);\n\n      if (!seed) {\n        // Try to minimize operations if there is only one group\n        if (match.length === 1) {\n          // Take a shortcut and set the context if the root selector is an ID\n          tokens = match[0] = match[0].slice(0);\n\n          if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && !documentIsXML && Expr.relative[tokens[1].type]) {\n            context = Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context)[0];\n\n            if (!context) {\n              return results;\n            }\n\n            selector = selector.slice(tokens.shift().value.length);\n          } // Fetch a seed set for right-to-left matching\n\n\n          i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n          while (i--) {\n            token = tokens[i]; // Abort if we hit a combinator\n\n            if (Expr.relative[type = token.type]) {\n              break;\n            }\n\n            if (find = Expr.find[type]) {\n              // Search, expanding context for leading sibling combinators\n              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {\n                // If seed is empty or no tokens remain, we can return early\n                tokens.splice(i, 1);\n                selector = seed.length && toSelector(tokens);\n\n                if (!selector) {\n                  push.apply(results, slice.call(seed, 0));\n                  return results;\n                }\n\n                break;\n              }\n            }\n          }\n        }\n      } // Compile and execute a filtering function\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      compile(selector, match)(seed, context, documentIsXML, results, rsibling.test(selector));\n      return results;\n    } // Deprecated\n\n\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Easy API for creating new setFilters\n\n    function setFilters() {}\n\n    Expr.filters = setFilters.prototype = Expr.pseudos;\n    Expr.setFilters = new setFilters(); // Initialize with the default document\n\n    setDocument(); // Override sizzle attribute retrieval\n\n    Sizzle.attr = jQuery.attr;\n    jQuery.find = Sizzle;\n    jQuery.expr = Sizzle.selectors;\n    jQuery.expr[\":\"] = jQuery.expr.pseudos;\n    jQuery.unique = Sizzle.uniqueSort;\n    jQuery.text = Sizzle.getText;\n    jQuery.isXMLDoc = Sizzle.isXML;\n    jQuery.contains = Sizzle.contains;\n  })(window);\n\n  var runtil = /Until$/,\n      rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      isSimple = /^.[^:#\\[\\.,]*$/,\n      rneedsContext = jQuery.expr.match.needsContext,\n      // methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret,\n          self,\n          len = this.length;\n\n      if (typeof selector !== \"string\") {\n        self = this;\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = [];\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, this[i], ret);\n      } // Needed because $( selector, context ) becomes $( context ).find( selector )\n\n\n      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);\n      ret.selector = (this.selector ? this.selector + \" \" : \"\") + selector;\n      return ret;\n    },\n    has: function has(target) {\n      var i,\n          targets = jQuery(target, this),\n          len = targets.length;\n      return this.filter(function () {\n        for (i = 0; i < len; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector, false));\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector, true));\n    },\n    is: function is(selector) {\n      return !!selector && (typeof selector === \"string\" ? // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      rneedsContext.test(selector) ? jQuery(selector, this.context).index(this[0]) >= 0 : jQuery.filter(selector, this).length > 0 : this.filter(selector).length > 0);\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          ret = [],\n          pos = rneedsContext.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\n\n      for (; i < l; i++) {\n        cur = this[i];\n\n        while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {\n          if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {\n            ret.push(cur);\n            break;\n          }\n\n          cur = cur.parentNode;\n        }\n      }\n\n      return this.pushStack(ret.length > 1 ? jQuery.unique(ret) : ret);\n    },\n    // Determine the position of an element within\n    // the matched set of elements\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // index in selector\n\n\n      if (typeof elem === \"string\") {\n        return jQuery.inArray(this[0], jQuery(elem));\n      } // Locate the position of the desired element\n\n\n      return jQuery.inArray( // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem, this);\n    },\n    add: function add(selector, context) {\n      var set = typeof selector === \"string\" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),\n          all = jQuery.merge(this.get(), set);\n      return this.pushStack(jQuery.unique(all));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n  jQuery.fn.andSelf = jQuery.fn.addBack;\n\n  function sibling(cur, dir) {\n    do {\n      cur = cur[dir];\n    } while (cur && cur.nodeType !== 1);\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return jQuery.dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, i, until) {\n      return jQuery.dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return jQuery.dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return jQuery.dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, i, until) {\n      return jQuery.dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, i, until) {\n      return jQuery.dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return jQuery.sibling(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      return jQuery.nodeName(elem, \"iframe\") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var ret = jQuery.map(this, fn, until);\n\n      if (!runtil.test(name)) {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        ret = jQuery.filter(selector, ret);\n      }\n\n      ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;\n\n      if (this.length > 1 && rparentsprev.test(name)) {\n        ret = ret.reverse();\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  jQuery.extend({\n    filter: function filter(expr, elems, not) {\n      if (not) {\n        expr = \":not(\" + expr + \")\";\n      }\n\n      return elems.length === 1 ? jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] : jQuery.find.matches(expr, elems);\n    },\n    dir: function dir(elem, _dir, until) {\n      var matched = [],\n          cur = elem[_dir];\n\n      while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {\n        if (cur.nodeType === 1) {\n          matched.push(cur);\n        }\n\n        cur = cur[_dir];\n      }\n\n      return matched;\n    },\n    sibling: function sibling(n, elem) {\n      var r = [];\n\n      for (; n; n = n.nextSibling) {\n        if (n.nodeType === 1 && n !== elem) {\n          r.push(n);\n        }\n      }\n\n      return r;\n    }\n  }); // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, keep) {\n    // Can't pass null or undefined to indexOf in Firefox 4\n    // Set to 0 to skip string check\n    qualifier = qualifier || 0;\n\n    if (jQuery.isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        var retVal = !!qualifier.call(elem, i, elem);\n        return retVal === keep;\n      });\n    } else if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier === keep;\n      });\n    } else if (typeof qualifier === \"string\") {\n      var filtered = jQuery.grep(elements, function (elem) {\n        return elem.nodeType === 1;\n      });\n\n      if (isSimple.test(qualifier)) {\n        return jQuery.filter(qualifier, filtered, !keep);\n      } else {\n        qualifier = jQuery.filter(qualifier, filtered);\n      }\n    }\n\n    return jQuery.grep(elements, function (elem) {\n      return jQuery.inArray(elem, qualifier) >= 0 === keep;\n    });\n  }\n\n  function createSafeFragment(document) {\n    var list = nodeNames.split(\"|\"),\n        safeFrag = document.createDocumentFragment();\n\n    if (safeFrag.createElement) {\n      while (list.length) {\n        safeFrag.createElement(list.pop());\n      }\n    }\n\n    return safeFrag;\n  }\n\n  var nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" + \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n      rinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n      rnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n      rleadingWhitespace = /^\\s+/,\n      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n      rtagName = /<([\\w:]+)/,\n      rtbody = /<tbody/i,\n      rhtml = /<|&#?\\w+;/,\n      rnoInnerhtml = /<(?:script|style|link)/i,\n      manipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rscriptType = /^$|\\/(?:java|ecma)script/i,\n      rscriptTypeMasked = /^true\\/(.*)/,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n      // We have to close these tags to support XHTML (#13200)\n  wrapMap = {\n    option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n    legend: [1, \"<fieldset>\", \"</fieldset>\"],\n    area: [1, \"<map>\", \"</map>\"],\n    param: [1, \"<object>\", \"</object>\"],\n    thead: [1, \"<table>\", \"</table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    col: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n    // unless wrapped in a div with non-breaking characters in front of it.\n    _default: jQuery.support.htmlSerialize ? [0, \"\", \"\"] : [1, \"X<div>\", \"</div>\"]\n  },\n      safeFragment = createSafeFragment(document),\n      fragmentDiv = safeFragment.appendChild(document.createElement(\"div\"));\n  wrapMap.optgroup = wrapMap.option;\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td;\n  jQuery.fn.extend({\n    text: function text(value) {\n      return jQuery.access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));\n      }, null, value, arguments.length);\n    },\n    wrapAll: function wrapAll(html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapAll(html.call(this, i));\n        });\n      }\n\n      if (this[0]) {\n        // The elements to wrap the target around\n        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstChild && elem.firstChild.nodeType === 1) {\n            elem = elem.firstChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var isFunction = jQuery.isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap() {\n      return this.parent().each(function () {\n        if (!jQuery.nodeName(this, \"body\")) {\n          jQuery(this).replaceWith(this.childNodes);\n        }\n      }).end();\n    },\n    append: function append() {\n      return this.domManip(arguments, true, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          this.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return this.domManip(arguments, true, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          this.insertBefore(elem, this.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return this.domManip(arguments, false, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return this.domManip(arguments, false, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    // keepData is for internal use only--do not document\n    remove: function remove(selector, keepData) {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (!selector || jQuery.filter(selector, [elem]).length > 0) {\n          if (!keepData && elem.nodeType === 1) {\n            jQuery.cleanData(getAll(elem));\n          }\n\n          if (elem.parentNode) {\n            if (keepData && jQuery.contains(elem.ownerDocument, elem)) {\n              setGlobalEval(getAll(elem, \"script\"));\n            }\n\n            elem.parentNode.removeChild(elem);\n          }\n        }\n      }\n\n      return this;\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        // Remove element nodes and prevent memory leaks\n        if (elem.nodeType === 1) {\n          jQuery.cleanData(getAll(elem, false));\n        } // Remove any remaining nodes\n\n\n        while (elem.firstChild) {\n          elem.removeChild(elem.firstChild);\n        } // If this is a select, ensure that it displays empty (#12336)\n        // Support: IE<9\n\n\n        if (elem.options && jQuery.nodeName(elem, \"select\")) {\n          elem.options.length = 0;\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return jQuery.access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined) {\n          return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, \"\") : undefined;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && (jQuery.support.htmlSerialize || !rnoshimcache.test(value)) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = value.replace(rxhtmlTag, \"<$1></$2>\");\n\n          try {\n            for (; i < l; i++) {\n              // Remove element nodes and prevent memory leaks\n              elem = this[i] || {};\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith(value) {\n      var isFunc = jQuery.isFunction(value); // Make sure that the elements are removed from the DOM before they are inserted\n      // this can help fix replacing a parent with child elements\n\n      if (!isFunc && typeof value !== \"string\") {\n        value = jQuery(value).not(this).detach();\n      }\n\n      return this.domManip([value], true, function (elem) {\n        var next = this.nextSibling,\n            parent = this.parentNode;\n\n        if (parent) {\n          jQuery(this).remove();\n          parent.insertBefore(elem, next);\n        }\n      });\n    },\n    detach: function detach(selector) {\n      return this.remove(selector, true);\n    },\n    domManip: function domManip(args, table, callback) {\n      // Flatten any nested arrays\n      args = core_concat.apply([], args);\n      var first,\n          node,\n          hasScripts,\n          scripts,\n          doc,\n          fragment,\n          i = 0,\n          l = this.length,\n          set = this,\n          iNoClone = l - 1,\n          value = args[0],\n          isFunction = jQuery.isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n      if (isFunction || !(l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test(value))) {\n        return this.each(function (index) {\n          var self = set.eq(index);\n\n          if (isFunction) {\n            args[0] = value.call(this, index, table ? self.html() : undefined);\n          }\n\n          self.domManip(args, table, callback);\n        });\n      }\n\n      if (l) {\n        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);\n        first = fragment.firstChild;\n\n        if (fragment.childNodes.length === 1) {\n          fragment = first;\n        }\n\n        if (first) {\n          table = table && jQuery.nodeName(first, \"tr\");\n          scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n          hasScripts = scripts.length; // Use the original fragment for the last item instead of the first because it can end up\n          // being emptied incorrectly in certain situations (#8070).\n\n          for (; i < l; i++) {\n            node = fragment;\n\n            if (i !== iNoClone) {\n              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n              if (hasScripts) {\n                jQuery.merge(scripts, getAll(node, \"script\"));\n              }\n            }\n\n            callback.call(table && jQuery.nodeName(this[i], \"table\") ? findOrAppend(this[i], \"tbody\") : this[i], node, i);\n          }\n\n          if (hasScripts) {\n            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n            for (i = 0; i < hasScripts; i++) {\n              node = scripts[i];\n\n              if (rscriptType.test(node.type || \"\") && !jQuery._data(node, \"globalEval\") && jQuery.contains(doc, node)) {\n                if (node.src) {\n                  // Hope ajax is available...\n                  jQuery.ajax({\n                    url: node.src,\n                    type: \"GET\",\n                    dataType: \"script\",\n                    async: false,\n                    global: false,\n                    \"throws\": true\n                  });\n                } else {\n                  jQuery.globalEval((node.text || node.textContent || node.innerHTML || \"\").replace(rcleanScript, \"\"));\n                }\n              }\n            }\n          } // Fix #11809: Avoid leaking memory\n\n\n          fragment = first = null;\n        }\n      }\n\n      return this;\n    }\n  });\n\n  function findOrAppend(elem, tag) {\n    return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    var attr = elem.getAttributeNode(\"type\");\n    elem.type = (attr && attr.specified) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    var match = rscriptTypeMasked.exec(elem.type);\n\n    if (match) {\n      elem.type = match[1];\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var elem,\n        i = 0;\n\n    for (; (elem = elems[i]) != null; i++) {\n      jQuery._data(elem, \"globalEval\", !refElements || jQuery._data(refElements[i], \"globalEval\"));\n    }\n  }\n\n  function cloneCopyEvent(src, dest) {\n    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {\n      return;\n    }\n\n    var type,\n        i,\n        l,\n        oldData = jQuery._data(src),\n        curData = jQuery._data(dest, oldData),\n        events = oldData.events;\n\n    if (events) {\n      delete curData.handle;\n      curData.events = {};\n\n      for (type in events) {\n        for (i = 0, l = events[type].length; i < l; i++) {\n          jQuery.event.add(dest, type, events[type][i]);\n        }\n      }\n    } // make the cloned public data object a copy from the original\n\n\n    if (curData.data) {\n      curData.data = jQuery.extend({}, curData.data);\n    }\n  }\n\n  function fixCloneNodeIssues(src, dest) {\n    var nodeName, e, data; // We do not need to do anything for non-Elements\n\n    if (dest.nodeType !== 1) {\n      return;\n    }\n\n    nodeName = dest.nodeName.toLowerCase(); // IE6-8 copies events bound via attachEvent when using cloneNode.\n\n    if (!jQuery.support.noCloneEvent && dest[jQuery.expando]) {\n      data = jQuery._data(dest);\n\n      for (e in data.events) {\n        jQuery.removeEvent(dest, e, data.handle);\n      } // Event data gets referenced instead of copied if the expando gets copied too\n\n\n      dest.removeAttribute(jQuery.expando);\n    } // IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\n\n    if (nodeName === \"script\" && dest.text !== src.text) {\n      disableScript(dest).text = src.text;\n      restoreScript(dest); // IE6-10 improperly clones children of object elements using classid.\n      // IE10 throws NoModificationAllowedError if parent is null, #12132.\n    } else if (nodeName === \"object\") {\n      if (dest.parentNode) {\n        dest.outerHTML = src.outerHTML;\n      } // This path appears unavoidable for IE9. When cloning an object\n      // element in IE9, the outerHTML strategy above is not sufficient.\n      // If the src has innerHTML and the destination does not,\n      // copy the src.innerHTML into the dest.innerHTML. #10324\n\n\n      if (jQuery.support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {\n        dest.innerHTML = src.innerHTML;\n      }\n    } else if (nodeName === \"input\" && manipulation_rcheckableType.test(src.type)) {\n      // IE6-8 fails to persist the checked state of a cloned checkbox\n      // or radio button. Worse, IE6-7 fail to give the cloned element\n      // a checked appearance if the defaultChecked value isn't also set\n      dest.defaultChecked = dest.checked = src.checked; // IE6-7 get confused and end up setting the value of a cloned\n      // checkbox/radio button to an empty string instead of \"on\"\n\n      if (dest.value !== src.value) {\n        dest.value = src.value;\n      } // IE6-8 fails to return the selected option to the default selected\n      // state when cloning options\n\n    } else if (nodeName === \"option\") {\n      dest.defaultSelected = dest.selected = src.defaultSelected; // IE6-8 fails to set the defaultValue to the correct value when\n      // cloning other types of input fields\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          i = 0,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\n        core_push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n\n  function getAll(context, tag) {\n    var elems,\n        elem,\n        i = 0,\n        found = _typeof(context.getElementsByTagName) !== core_strundefined ? context.getElementsByTagName(tag || \"*\") : _typeof(context.querySelectorAll) !== core_strundefined ? context.querySelectorAll(tag || \"*\") : undefined;\n\n    if (!found) {\n      for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {\n        if (!tag || jQuery.nodeName(elem, tag)) {\n          found.push(elem);\n        } else {\n          jQuery.merge(found, getAll(elem, tag));\n        }\n      }\n    }\n\n    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;\n  } // Used in buildFragment, fixes the defaultChecked property\n\n\n  function fixDefaultChecked(elem) {\n    if (manipulation_rcheckableType.test(elem.type)) {\n      elem.defaultChecked = elem.checked;\n    }\n  }\n\n  jQuery.extend({\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var destElements,\n          node,\n          clone,\n          i,\n          srcElements,\n          inPage = jQuery.contains(elem.ownerDocument, elem);\n\n      if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test(\"<\" + elem.nodeName + \">\")) {\n        clone = elem.cloneNode(true); // IE<=8 does not properly clone detached, unknown element nodes\n      } else {\n        fragmentDiv.innerHTML = elem.outerHTML;\n        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);\n      }\n\n      if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem); // Fix all IE cloning issues\n\n        for (i = 0; (node = srcElements[i]) != null; ++i) {\n          // Ensure that the destination node is not null; Fixes #9587\n          if (destElements[i]) {\n            fixCloneNodeIssues(node, destElements[i]);\n          }\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0; (node = srcElements[i]) != null; i++) {\n            cloneCopyEvent(node, destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      }\n\n      destElements = srcElements = node = null; // Return the cloned set\n\n      return clone;\n    },\n    buildFragment: function buildFragment(elems, context, scripts, selection) {\n      var j,\n          elem,\n          contains,\n          tmp,\n          tag,\n          tbody,\n          wrap,\n          l = elems.length,\n          // Ensure a safe fragment\n      safe = createSafeFragment(context),\n          nodes = [],\n          i = 0;\n\n      for (; i < l; i++) {\n        elem = elems[i];\n\n        if (elem || elem === 0) {\n          // Add nodes directly\n          if (jQuery.type(elem) === \"object\") {\n            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n          } else if (!rhtml.test(elem)) {\n            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n          } else {\n            tmp = tmp || safe.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n            tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n            wrap = wrapMap[tag] || wrapMap._default;\n            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, \"<$1></$2>\") + wrap[2]; // Descend through wrappers to the right content\n\n            j = wrap[0];\n\n            while (j--) {\n              tmp = tmp.lastChild;\n            } // Manually add leading whitespace removed by IE\n\n\n            if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {\n              nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));\n            } // Remove IE's autoinserted <tbody> from table fragments\n\n\n            if (!jQuery.support.tbody) {\n              // String was a <table>, *may* have spurious <tbody>\n              elem = tag === \"table\" && !rtbody.test(elem) ? tmp.firstChild : // String was a bare <thead> or <tfoot>\n              wrap[1] === \"<table>\" && !rtbody.test(elem) ? tmp : 0;\n              j = elem && elem.childNodes.length;\n\n              while (j--) {\n                if (jQuery.nodeName(tbody = elem.childNodes[j], \"tbody\") && !tbody.childNodes.length) {\n                  elem.removeChild(tbody);\n                }\n              }\n            }\n\n            jQuery.merge(nodes, tmp.childNodes); // Fix #12392 for WebKit and IE > 9\n\n            tmp.textContent = \"\"; // Fix #12392 for oldIE\n\n            while (tmp.firstChild) {\n              tmp.removeChild(tmp.firstChild);\n            } // Remember the top-level container for proper cleanup\n\n\n            tmp = safe.lastChild;\n          }\n        }\n      } // Fix #11356: Clear elements from fragment\n\n\n      if (tmp) {\n        safe.removeChild(tmp);\n      } // Reset defaultChecked for any radios and checkboxes\n      // about to be appended to the DOM in IE 6/7 (#8060)\n\n\n      if (!jQuery.support.appendChecked) {\n        jQuery.grep(getAll(nodes, \"input\"), fixDefaultChecked);\n      }\n\n      i = 0;\n\n      while (elem = nodes[i++]) {\n        // #4087 - If origin and destination elements are the same, and this is\n        // that element, do not do anything\n        if (selection && jQuery.inArray(elem, selection) !== -1) {\n          continue;\n        }\n\n        contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment\n\n        tmp = getAll(safe.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n        if (contains) {\n          setGlobalEval(tmp);\n        } // Capture executables\n\n\n        if (scripts) {\n          j = 0;\n\n          while (elem = tmp[j++]) {\n            if (rscriptType.test(elem.type || \"\")) {\n              scripts.push(elem);\n            }\n          }\n        }\n      }\n\n      tmp = null;\n      return safe;\n    },\n    cleanData: function cleanData(elems,\n    /* internal */\n    acceptData) {\n      var elem,\n          type,\n          id,\n          data,\n          i = 0,\n          internalKey = jQuery.expando,\n          cache = jQuery.cache,\n          deleteExpando = jQuery.support.deleteExpando,\n          special = jQuery.event.special;\n\n      for (; (elem = elems[i]) != null; i++) {\n        if (acceptData || jQuery.acceptData(elem)) {\n          id = elem[internalKey];\n          data = id && cache[id];\n\n          if (data) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Remove cache only if it was not already removed by jQuery.event.remove\n\n\n            if (cache[id]) {\n              delete cache[id]; // IE does not allow us to delete expando properties from nodes,\n              // nor does it have a removeAttribute function on Document nodes;\n              // we must handle all of these cases\n\n              if (deleteExpando) {\n                delete elem[internalKey];\n              } else if (_typeof(elem.removeAttribute) !== core_strundefined) {\n                elem.removeAttribute(internalKey);\n              } else {\n                elem[internalKey] = null;\n              }\n\n              core_deletedIds.push(id);\n            }\n          }\n        }\n      }\n    }\n  });\n  var iframe,\n      getStyles,\n      curCSS,\n      ralpha = /alpha\\([^)]*\\)/i,\n      ropacity = /opacity\\s*=\\s*([^)]*)/,\n      rposition = /^(top|right|bottom|left)$/,\n      // swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n  // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rmargin = /^margin/,\n      rnumsplit = new RegExp(\"^(\" + core_pnum + \")(.*)$\", \"i\"),\n      rnumnonpx = new RegExp(\"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\"),\n      rrelNum = new RegExp(\"^([+-])=(\" + core_pnum + \")\", \"i\"),\n      elemdisplay = {\n    BODY: \"block\"\n  },\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: 0,\n    fontWeight: 400\n  },\n      cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"]; // return a css property mapped to a potentially vendor prefixed property\n\n  function vendorPropName(style, name) {\n    // shortcut for names that are not vendor prefixed\n    if (name in style) {\n      return name;\n    } // check for vendor prefixed names\n\n\n    var capName = name.charAt(0).toUpperCase() + name.slice(1),\n        origName = name,\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in style) {\n        return name;\n      }\n    }\n\n    return origName;\n  }\n\n  function isHidden(elem, el) {\n    // isHidden might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem;\n    return jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument, elem);\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        hidden,\n        values = [],\n        index = 0,\n        length = elements.length;\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      values[index] = jQuery._data(elem, \"olddisplay\");\n      display = elem.style.display;\n\n      if (show) {\n        // Reset the inline display of this element to learn if it is\n        // being hidden by cascaded rules or not\n        if (!values[index] && display === \"none\") {\n          elem.style.display = \"\";\n        } // Set elements which have been overridden with display: none\n        // in a stylesheet to whatever the default browser style is\n        // for such an element\n\n\n        if (elem.style.display === \"\" && isHidden(elem)) {\n          values[index] = jQuery._data(elem, \"olddisplay\", css_defaultDisplay(elem.nodeName));\n        }\n      } else {\n        if (!values[index]) {\n          hidden = isHidden(elem);\n\n          if (display && display !== \"none\" || !hidden) {\n            jQuery._data(elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\"));\n          }\n        }\n      }\n    } // Set the display of most of the elements in a second loop\n    // to avoid the constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      if (!show || elem.style.display === \"none\" || elem.style.display === \"\") {\n        elem.style.display = show ? values[index] || \"\" : \"none\";\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return jQuery.access(this, function (elem, name, value) {\n        var len,\n            styles,\n            map = {},\n            i = 0;\n\n        if (jQuery.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    },\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      var bool = typeof state === \"boolean\";\n      return this.each(function () {\n        if (bool ? state : isHidden(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Exclude the following css properties to add px\n    cssNumber: {\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"fontWeight\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {\n      // normalize float css property\n      \"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n    },\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = jQuery.camelCase(name),\n          style = elem.style;\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)); // gets hook for the prefixed version\n      // followed by the unprefixed version\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // convert relative number strings (+= or -=) to relative numbers. #7345\n\n        if (type === \"string\" && (ret = rrelNum.exec(value))) {\n          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that NaN and null values aren't set. See: #7116\n\n\n        if (value == null || type === \"number\" && isNaN(value)) {\n          return;\n        } // If a number was passed in, add 'px' to the (except for certain CSS properties)\n\n\n        if (type === \"number\" && !jQuery.cssNumber[origName]) {\n          value += \"px\";\n        } // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n        // but it would mean to define eight (for every problematic property) identical functions\n\n\n        if (!jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          // Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n          // Fixes bug #5509\n          try {\n            style[name] = value;\n          } catch (e) {}\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var num,\n          val,\n          hooks,\n          origName = jQuery.camelCase(name); // Make sure that we're working with the right name\n\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)); // gets hook for the prefixed version\n      // followed by the unprefixed version\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } //convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Return, converting to number if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;\n      }\n\n      return val;\n    },\n    // A method for quickly swapping in/out CSS properties to get correct calculations\n    swap: function swap(elem, options, callback, args) {\n      var ret,\n          name,\n          old = {}; // Remember the old values, and insert the new ones\n\n      for (name in options) {\n        old[name] = elem.style[name];\n        elem.style[name] = options[name];\n      }\n\n      ret = callback.apply(elem, args || []); // Revert the old values\n\n      for (name in options) {\n        elem.style[name] = old[name];\n      }\n\n      return ret;\n    }\n  }); // NOTE: we've included the \"window\" in window.getComputedStyle\n  // because jsdom on node.js will break without it.\n\n  if (window.getComputedStyle) {\n    getStyles = function getStyles(elem) {\n      return window.getComputedStyle(elem, null);\n    };\n\n    curCSS = function curCSS(elem, name, _computed) {\n      var width,\n          minWidth,\n          maxWidth,\n          computed = _computed || getStyles(elem),\n          // getPropertyValue is only needed for .css('filter') in IE9, see #12537\n      ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined,\n          style = elem.style;\n\n      if (computed) {\n        if (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n          ret = jQuery.style(elem, name);\n        } // A tribute to the \"awesome hack by Dean Edwards\"\n        // Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\n\n        if (rnumnonpx.test(ret) && rmargin.test(name)) {\n          // Remember the original values\n          width = style.width;\n          minWidth = style.minWidth;\n          maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n          style.minWidth = style.maxWidth = style.width = ret;\n          ret = computed.width; // Revert the changed values\n\n          style.width = width;\n          style.minWidth = minWidth;\n          style.maxWidth = maxWidth;\n        }\n      }\n\n      return ret;\n    };\n  } else if (document.documentElement.currentStyle) {\n    getStyles = function getStyles(elem) {\n      return elem.currentStyle;\n    };\n\n    curCSS = function curCSS(elem, name, _computed) {\n      var left,\n          rs,\n          rsLeft,\n          computed = _computed || getStyles(elem),\n          ret = computed ? computed[name] : undefined,\n          style = elem.style; // Avoid setting ret to empty string here\n      // so we don't default to auto\n\n\n      if (ret == null && style && style[name]) {\n        ret = style[name];\n      } // From the awesome hack by Dean Edwards\n      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n      // If we're not dealing with a regular pixel number\n      // but a number that has a weird ending, we need to convert it to pixels\n      // but not position css attributes, as those are proportional to the parent element instead\n      // and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\n\n      if (rnumnonpx.test(ret) && !rposition.test(name)) {\n        // Remember the original values\n        left = style.left;\n        rs = elem.runtimeStyle;\n        rsLeft = rs && rs.left; // Put in the new values to get a computed value out\n\n        if (rsLeft) {\n          rs.left = elem.currentStyle.left;\n        }\n\n        style.left = name === \"fontSize\" ? \"1em\" : ret;\n        ret = style.pixelLeft + \"px\"; // Revert the changed values\n\n        style.left = left;\n\n        if (rsLeft) {\n          rs.left = rsLeft;\n        }\n      }\n\n      return ret === \"\" ? \"auto\" : ret;\n    };\n  }\n\n  function setPositiveNumber(elem, value, subtract) {\n    var matches = rnumsplit.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || \"px\") : value;\n  }\n\n  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n    var i = extra === (isBorderBox ? \"border\" : \"content\") ? // If we already have the right measurement, avoid augmentation\n    4 : // Otherwise initialize for horizontal or vertical properties\n    name === \"width\" ? 1 : 0,\n        val = 0;\n\n    for (; i < 4; i += 2) {\n      // both box models exclude margin, so add it if we want it\n      if (extra === \"margin\") {\n        val += jQuery.css(elem, extra + cssExpand[i], true, styles);\n      }\n\n      if (isBorderBox) {\n        // border-box includes padding, so remove it if we want content\n        if (extra === \"content\") {\n          val -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // at this point, extra isn't border nor margin, so remove border\n\n\n        if (extra !== \"margin\") {\n          val -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      } else {\n        // at this point, extra isn't content, so add padding\n        val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // at this point, extra isn't content nor padding, so add border\n\n        if (extra !== \"padding\") {\n          val += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    }\n\n    return val;\n  }\n\n  function getWidthOrHeight(elem, name, extra) {\n    // Start with offset property, which is equivalent to the border-box value\n    var valueIsBorderBox = true,\n        val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n        styles = getStyles(elem),\n        isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // some non-html elements return undefined for offsetWidth, so check for null/undefined\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\n    if (val <= 0 || val == null) {\n      // Fall back to computed then uncomputed css if necessary\n      val = curCSS(elem, name, styles);\n\n      if (val < 0 || val == null) {\n        val = elem.style[name];\n      } // Computed unit is not pixels. Stop here and return.\n\n\n      if (rnumnonpx.test(val)) {\n        return val;\n      } // we need the check for style in case a browser which returns unreliable values\n      // for getComputedStyle silently falls back to the reliable elem.style\n\n\n      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]); // Normalize \"\", auto, and prepare for extra\n\n      val = parseFloat(val) || 0;\n    } // use the active box-sizing model to add/subtract irrelevant styles\n\n\n    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles) + \"px\";\n  } // Try to determine the default display value of an element\n\n\n  function css_defaultDisplay(nodeName) {\n    var doc = document,\n        display = elemdisplay[nodeName];\n\n    if (!display) {\n      display = actualDisplay(nodeName, doc); // If the simple way fails, read from inside an iframe\n\n      if (display === \"none\" || !display) {\n        // Use the already-created iframe if possible\n        iframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\").css(\"cssText\", \"display:block !important\")).appendTo(doc.documentElement); // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\n        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;\n        doc.write(\"<!doctype html><html><body>\");\n        doc.close();\n        display = actualDisplay(nodeName, doc);\n        iframe.detach();\n      } // Store the correct default display\n\n\n      elemdisplay[nodeName] = display;\n    }\n\n    return display;\n  } // Called ONLY from within css_defaultDisplay\n\n\n  function actualDisplay(name, doc) {\n    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),\n        display = jQuery.css(elem[0], \"display\");\n    elem.remove();\n    return display;\n  }\n\n  jQuery.each([\"height\", \"width\"], function (i, name) {\n    jQuery.cssHooks[name] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // certain elements can have dimension info if we invisibly show them\n          // however, it must have a current display style that would benefit from this\n          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, \"display\")) ? jQuery.swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, name, extra);\n          }) : getWidthOrHeight(elem, name, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var styles = extra && getStyles(elem);\n        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles) : 0);\n      }\n    };\n  });\n\n  if (!jQuery.support.opacity) {\n    jQuery.cssHooks.opacity = {\n      get: function get(elem, computed) {\n        // IE uses filters for opacity\n        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\") ? 0.01 * parseFloat(RegExp.$1) + \"\" : computed ? \"1\" : \"\";\n      },\n      set: function set(elem, value) {\n        var style = elem.style,\n            currentStyle = elem.currentStyle,\n            opacity = jQuery.isNumeric(value) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n            filter = currentStyle && currentStyle.filter || style.filter || \"\"; // IE has trouble with opacity if it does not have layout\n        // Force it by setting the zoom level\n\n        style.zoom = 1; // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n        // if value === \"\", then remove inline opacity #12685\n\n        if ((value >= 1 || value === \"\") && jQuery.trim(filter.replace(ralpha, \"\")) === \"\" && style.removeAttribute) {\n          // Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n          // if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n          // style.removeAttribute is IE Only, but so apparently is this code path...\n          style.removeAttribute(\"filter\"); // if there is no filter style applied in a css rule or unset inline opacity, we are done\n\n          if (value === \"\" || currentStyle && !currentStyle.filter) {\n            return;\n          }\n        } // otherwise, set new filter values\n\n\n        style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + \" \" + opacity;\n      }\n    };\n  } // These hooks cannot be added until DOM ready because the support test\n  // for it is not run until after DOM ready\n\n\n  jQuery(function () {\n    if (!jQuery.support.reliableMarginRight) {\n      jQuery.cssHooks.marginRight = {\n        get: function get(elem, computed) {\n          if (computed) {\n            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n            // Work around by temporarily setting element display to inline-block\n            return jQuery.swap(elem, {\n              \"display\": \"inline-block\"\n            }, curCSS, [elem, \"marginRight\"]);\n          }\n        }\n      };\n    } // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n    // getComputedStyle returns percent when specified for top/left/bottom/right\n    // rather than make the css module depend on the offset module, we just check for it here\n\n\n    if (!jQuery.support.pixelPosition && jQuery.fn.position) {\n      jQuery.each([\"top\", \"left\"], function (i, prop) {\n        jQuery.cssHooks[prop] = {\n          get: function get(elem, computed) {\n            if (computed) {\n              computed = curCSS(elem, prop); // if curCSS returns percentage, fallback to offset\n\n              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n            }\n          }\n        };\n      });\n    }\n  });\n\n  if (jQuery.expr && jQuery.expr.filters) {\n    jQuery.expr.filters.hidden = function (elem) {\n      // Support: Opera <= 12.12\n      // Opera reports offsetWidths and offsetHeights less than zero on some elements\n      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !jQuery.support.reliableHiddenOffsets && (elem.style && elem.style.display || jQuery.css(elem, \"display\")) === \"none\";\n    };\n\n    jQuery.expr.filters.visible = function (elem) {\n      return !jQuery.expr.filters.hidden(elem);\n    };\n  } // These hooks are used by animate to expand properties\n\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (!rmargin.test(prefix)) {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  var r20 = /%20/g,\n      rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is(\":disabled\") so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));\n      }).map(function (i, elem) {\n        var val = jQuery(this).val();\n        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {\n          return {\n            name: elem.name,\n            value: val.replace(rCRLF, \"\\r\\n\")\n          };\n        }) : {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  }); //Serialize an array of form elements or a set of\n  //key/values into a query string\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, value) {\n      // If value is a function, invoke it and return its value\n      value = jQuery.isFunction(value) ? value() : value == null ? \"\" : value;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n    }; // Set traditional to true for jQuery <= 1.3.2 behavior.\n\n\n    if (traditional === undefined) {\n      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\").replace(r20, \"+\");\n  };\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (jQuery.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && jQuery.type(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  }\n\n  jQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n\n  jQuery.fn.hover = function (fnOver, fnOut) {\n    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n  };\n\n  var // Document location\n  ajaxLocParts,\n      ajaxLocation,\n      ajax_nonce = jQuery.now(),\n      ajax_rquery = /\\?/,\n      rhash = /#.*$/,\n      rts = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n      // IE leaves an \\r character at EOL\n  // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n      rurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n      // Keep a copy of the old load method\n  _load = jQuery.fn.load,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"); // #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n\n  try {\n    ajaxLocation = location.href;\n  } catch (e) {\n    // Use the href attribute of an A element\n    // since IE will modify it given document.location\n    ajaxLocation = document.createElement(\"a\");\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  } // Segment location into parts\n\n\n  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];\n\n      if (jQuery.isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var deep,\n        key,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n\n  jQuery.fn.load = function (url, params, callback) {\n    if (typeof url !== \"string\" && _load) {\n      return _load.apply(this, arguments);\n    }\n\n    var selector,\n        response,\n        type,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off >= 0) {\n      selector = url.slice(off, url.length);\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (jQuery.isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // if \"type\" variable is undefined, then \"GET\" method will be used\n        type: type,\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText);\n      }).complete(callback && function (jqXHR, status) {\n        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);\n      });\n    }\n\n    return this;\n  }; // Attach a bunch of functions for handling common AJAX events\n\n\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n  jQuery.each([\"get\", \"post\"], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // shift arguments if data argument was omitted\n      if (jQuery.isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      }\n\n      return jQuery.ajax({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      });\n    };\n  });\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: ajaxLocation,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(ajaxLocParts[1]),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /xml/,\n        html: /html/,\n        json: /json/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": window.String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": jQuery.parseJSON,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var // Cross-domain detection vars\n      parts,\n          // Loop variable\n      i,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers as string\n      responseHeadersString,\n          // timeout handle\n      timeoutTimer,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          transport,\n          // Response headers\n      responseHeaders,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // The jqXHR state\n      state = 0,\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (state === 2) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase()] = match[2];\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase()];\n          }\n\n          return match == null ? null : match;\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return state === 2 ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          var lname = name.toLowerCase();\n\n          if (!state) {\n            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (!state) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (state < 2) {\n              for (code in map) {\n                // Lazy-add the new callback in a way that preserves old ones\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            } else {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR).complete = completeDeferred.add;\n      jqXHR.success = jqXHR.done;\n      jqXHR.error = jqXHR.fail; // Remove hash character (#7531: and string promotion)\n      // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(core_rnotwhite) || [\"\"]; // A cross-domain request is in order when we have a protocol:host:port mismatch\n\n      if (s.crossDomain == null) {\n        parts = rurl.exec(s.url.toLowerCase());\n        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443))));\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (state === 2) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n\n\n      fireGlobals = s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n\n      cacheURL = s.url; // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // If data is available, append data to url\n        if (s.data) {\n          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add anti-cache in url if needed\n\n\n        if (s.cache === false) {\n          s.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value\n          cacheURL.replace(rts, \"$1_=\" + ajax_nonce++) : // Otherwise add one to the end\n          cacheURL + (ajax_rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + ajax_nonce++;\n        }\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      for (i in {\n        success: 1,\n        error: 1,\n        complete: 1\n      }) {\n        jqXHR[i](s[i]);\n      } // Get transport\n\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          state = 1;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Propagate exception as error if not done\n          if (state < 2) {\n            done(-1, e); // Simply rethrow otherwise\n          } else {\n            throw e;\n          }\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Called once\n\n        if (state === 2) {\n          return;\n        } // State is \"done\" now\n\n\n        state = 2; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // If successful, handle type chaining\n\n\n        if (status >= 200 && status < 300 || status === 304) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204) {\n            isSuccess = true;\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            isSuccess = true;\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            isSuccess = ajaxConvert(s, response);\n            statusText = isSuccess.state;\n            success = isSuccess.data;\n            error = isSuccess.error;\n            isSuccess = !error;\n          }\n        } else {\n          // We extract error from statusText\n          // then normalize statusText and status for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    }\n  });\n  /* Handles responses to an ajax request:\n   * - sets all responseXXX fields accordingly\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var firstDataType,\n        ct,\n        finalDataType,\n        type,\n        contents = s.contents,\n        dataTypes = s.dataTypes,\n        responseFields = s.responseFields; // Fill responseXXX fields\n\n    for (type in responseFields) {\n      if (type in responses) {\n        jqXHR[responseFields[type]] = responses[type];\n      }\n    } // Remove auto dataType and get content-type in the process\n\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  } // Chain conversions given the request and the original response\n\n\n  function ajaxConvert(s, response) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        converters = {},\n        i = 0,\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(),\n        prev = dataTypes[0]; // Apply the dataFilter if provided\n\n    if (s.dataFilter) {\n      response = s.dataFilter(response, s.dataType);\n    } // Create converters map with lowercased keys\n\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    } // Convert to each sequential dataType, tolerating list modification\n\n\n    for (; current = dataTypes[++i];) {\n      // There's only work to do if current dataType is non-auto\n      if (current !== \"*\") {\n        // Convert response if prev dataType is non-auto and differs from current\n        if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.splice(i--, 0, current);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        } // Update prev for next iteration\n\n\n        prev = current;\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  } // Install script dataType\n\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /(?:java|ecma)script/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and global\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n      s.global = false;\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain requests\n    if (s.crossDomain) {\n      var script,\n          head = document.head || jQuery(\"head\")[0] || document.documentElement;\n      return {\n        send: function send(_, callback) {\n          script = document.createElement(\"script\");\n          script.async = true;\n\n          if (s.scriptCharset) {\n            script.charset = s.scriptCharset;\n          }\n\n          script.src = s.url; // Attach handlers for all browsers\n\n          script.onload = script.onreadystatechange = function (_, isAbort) {\n            if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n              // Handle memory leak in IE\n              script.onload = script.onreadystatechange = null; // Remove the script\n\n              if (script.parentNode) {\n                script.parentNode.removeChild(script);\n              } // Dereference the script\n\n\n              script = null; // Callback if not abort\n\n              if (!isAbort) {\n                callback(200, \"success\");\n              }\n            }\n          }; // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n\n          head.insertBefore(script, head.firstChild);\n        },\n        abort: function abort() {\n          if (script) {\n            script.onload(undefined, true);\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + ajax_nonce++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && !(s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (ajax_rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // Restore preexisting value\n        window[callbackName] = overwritten; // Save back as free\n\n        if (s[callbackName]) {\n          // make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && jQuery.isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  });\n\n  var xhrCallbacks,\n      xhrSupported,\n      xhrId = 0,\n      // #5280: Internet Explorer will keep connections alive if we don't abort on unload\n  xhrOnUnloadAbort = window.ActiveXObject && function () {\n    // Abort all pending requests\n    var key;\n\n    for (key in xhrCallbacks) {\n      xhrCallbacks[key](undefined, true);\n    }\n  }; // Functions to create xhrs\n\n\n  function createStandardXHR() {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  }\n\n  function createActiveXHR() {\n    try {\n      return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n    } catch (e) {}\n  } // Create the request object\n  // (This is still attached to ajaxSettings for backward compatibility)\n\n\n  jQuery.ajaxSettings.xhr = window.ActiveXObject ?\n  /* Microsoft failed to properly\n   * implement the XMLHttpRequest in IE7 (can't request local files),\n   * so we use the ActiveXObject when it is available\n   * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n   * we need a fallback.\n   */\n  function () {\n    return !this.isLocal && createStandardXHR() || createActiveXHR();\n  } : // For all other browsers, use the standard XMLHttpRequest object\n  createStandardXHR; // Determine support properties\n\n  xhrSupported = jQuery.ajaxSettings.xhr();\n  jQuery.support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  xhrSupported = jQuery.support.ajax = !!xhrSupported; // Create transport if the browser can provide an xhr\n\n  if (xhrSupported) {\n    jQuery.ajaxTransport(function (s) {\n      // Cross domain only allowed if supported through XMLHttpRequest\n      if (!s.crossDomain || jQuery.support.cors) {\n        var _callback;\n\n        return {\n          send: function send(headers, complete) {\n            // Get a new xhr\n            var handle,\n                i,\n                xhr = s.xhr(); // Open the socket\n            // Passing null username, generates a login popup on Opera (#2865)\n\n            if (s.username) {\n              xhr.open(s.type, s.url, s.async, s.username, s.password);\n            } else {\n              xhr.open(s.type, s.url, s.async);\n            } // Apply custom fields if provided\n\n\n            if (s.xhrFields) {\n              for (i in s.xhrFields) {\n                xhr[i] = s.xhrFields[i];\n              }\n            } // Override mime type if needed\n\n\n            if (s.mimeType && xhr.overrideMimeType) {\n              xhr.overrideMimeType(s.mimeType);\n            } // X-Requested-With header\n            // For cross-domain requests, seeing as conditions for a preflight are\n            // akin to a jigsaw puzzle, we simply never set it to be sure.\n            // (it can always be set on a per-request basis or even using ajaxSetup)\n            // For same-domain requests, won't change header if already provided.\n\n\n            if (!s.crossDomain && !headers[\"X-Requested-With\"]) {\n              headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n            } // Need an extra try/catch for cross domain requests in Firefox 3\n\n\n            try {\n              for (i in headers) {\n                xhr.setRequestHeader(i, headers[i]);\n              }\n            } catch (err) {} // Do send the request\n            // This may raise an exception which is actually\n            // handled in jQuery.ajax (so no try/catch here)\n\n\n            xhr.send(s.hasContent && s.data || null); // Listener\n\n            _callback = function callback(_, isAbort) {\n              var status, responseHeaders, statusText, responses; // Firefox throws exceptions when accessing properties\n              // of an xhr when a network error occurred\n              // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\n              try {\n                // Was never called and is aborted or complete\n                if (_callback && (isAbort || xhr.readyState === 4)) {\n                  // Only called once\n                  _callback = undefined; // Do not keep as active anymore\n\n                  if (handle) {\n                    xhr.onreadystatechange = jQuery.noop;\n\n                    if (xhrOnUnloadAbort) {\n                      delete xhrCallbacks[handle];\n                    }\n                  } // If it's an abort\n\n\n                  if (isAbort) {\n                    // Abort it manually if needed\n                    if (xhr.readyState !== 4) {\n                      xhr.abort();\n                    }\n                  } else {\n                    responses = {};\n                    status = xhr.status;\n                    responseHeaders = xhr.getAllResponseHeaders(); // When requesting binary data, IE6-9 will throw an exception\n                    // on any attempt to access responseText (#11426)\n\n                    if (typeof xhr.responseText === \"string\") {\n                      responses.text = xhr.responseText;\n                    } // Firefox throws an exception when accessing\n                    // statusText for faulty cross-domain requests\n\n\n                    try {\n                      statusText = xhr.statusText;\n                    } catch (e) {\n                      // We normalize with Webkit giving an empty statusText\n                      statusText = \"\";\n                    } // Filter status for non standard behaviors\n                    // If the request is local and we have data: assume a success\n                    // (success with no data won't get notified, that's the best we\n                    // can do given current implementations)\n\n\n                    if (!status && s.isLocal && !s.crossDomain) {\n                      status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204\n                    } else if (status === 1223) {\n                      status = 204;\n                    }\n                  }\n                }\n              } catch (firefoxAccessException) {\n                if (!isAbort) {\n                  complete(-1, firefoxAccessException);\n                }\n              } // Call complete if needed\n\n\n              if (responses) {\n                complete(status, statusText, responses, responseHeaders);\n              }\n            };\n\n            if (!s.async) {\n              // if we're in sync mode we fire the callback\n              _callback();\n            } else if (xhr.readyState === 4) {\n              // (IE6 & IE7) if it's in cache and has been\n              // retrieved directly we need to fire the callback\n              setTimeout(_callback);\n            } else {\n              handle = ++xhrId;\n\n              if (xhrOnUnloadAbort) {\n                // Create the active xhrs callbacks list if needed\n                // and attach the unload handler\n                if (!xhrCallbacks) {\n                  xhrCallbacks = {};\n                  jQuery(window).unload(xhrOnUnloadAbort);\n                } // Add to list of active xhrs callbacks\n\n\n                xhrCallbacks[handle] = _callback;\n              }\n\n              xhr.onreadystatechange = _callback;\n            }\n          },\n          abort: function abort() {\n            if (_callback) {\n              _callback(undefined, true);\n            }\n          }\n        };\n      }\n    });\n  }\n\n  var fxNow,\n      timerId,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rfxnum = new RegExp(\"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\"),\n      rrun = /queueHooks$/,\n      animationPrefilters = [defaultPrefilter],\n      tweeners = {\n    \"*\": [function (prop, value) {\n      var end,\n          unit,\n          tween = this.createTween(prop, value),\n          parts = rfxnum.exec(value),\n          target = tween.cur(),\n          start = +target || 0,\n          scale = 1,\n          maxIterations = 20;\n\n      if (parts) {\n        end = +parts[2];\n        unit = parts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"); // We need to compute starting value\n\n        if (unit !== \"px\" && start) {\n          // Iteratively approximate from a nonzero starting point\n          // Prefer the current property, because this process will be trivial if it uses the same units\n          // Fallback to end or a simple constant\n          start = jQuery.css(tween.elem, prop, true) || end || 1;\n\n          do {\n            // If previous iteration zeroed out, double until we get *something*\n            // Use a string for doubling factor so we don't accidentally see scale as unchanged below\n            scale = scale || \".5\"; // Adjust and apply\n\n            start = start / scale;\n            jQuery.style(tween.elem, prop, start + unit); // Update scale, tolerating zero or NaN from tween.cur()\n            // And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n          } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);\n        }\n\n        tween.unit = unit;\n        tween.start = start; // If a +=/-= token was provided, we're doing a relative animation\n\n        tween.end = parts[1] ? start + (parts[1] + 1) * end : end;\n      }\n\n      return tween;\n    }]\n  }; // Animations created synchronously will run synchronously\n\n  function createFxNow() {\n    setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = jQuery.now();\n  }\n\n  function createTweens(animation, props) {\n    jQuery.each(props, function (prop, value) {\n      var collection = (tweeners[prop] || []).concat(tweeners[\"*\"]),\n          index = 0,\n          length = collection.length;\n\n      for (; index < length; index++) {\n        if (collection[index].call(animation, prop, value)) {\n          // we're done with this property\n          return;\n        }\n      }\n    });\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = animationPrefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]);\n\n      if (percent < 1 && length) {\n        return remaining;\n      } else {\n        deferred.resolveWith(elem, [animation]);\n        return false;\n      }\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {}\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // if we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // resolve when we played the last frame\n        // otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = animationPrefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    createTweens(animation, props);\n\n    if (jQuery.isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    }\n\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    })); // attach callbacks from options\n\n    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n  }\n\n  function propFilter(props, specialEasing) {\n    var value, name, index, easing, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = jQuery.camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (jQuery.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // not quite $.extend, this wont overwrite keys already present.\n        // also - reusing 'index' from above because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweener: function tweener(props, callback) {\n      if (jQuery.isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.split(\" \");\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        tweeners[prop] = tweeners[prop] || [];\n        tweeners[prop].unshift(callback);\n      }\n    },\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        animationPrefilters.unshift(callback);\n      } else {\n        animationPrefilters.push(callback);\n      }\n    }\n  });\n\n  function defaultPrefilter(elem, props, opts) {\n    /*jshint validthis:true */\n    var prop,\n        index,\n        length,\n        value,\n        dataShow,\n        toggle,\n        tween,\n        hooks,\n        oldfire,\n        anim = this,\n        style = elem.style,\n        orig = {},\n        handled = [],\n        hidden = elem.nodeType && isHidden(elem); // handle queue: false promises\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // doing this makes sure that the complete handler will be called\n        // before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // height/width overflow pass\n\n\n    if (elem.nodeType === 1 && (\"height\" in props || \"width\" in props)) {\n      // Make sure that nothing sneaks out\n      // Record all 3 overflow attributes because IE does not\n      // change the overflow attribute when overflowX and\n      // overflowY are set to the same value\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Set display property to inline-block for height/width\n      // animations on inline elements that are having width/height animated\n\n      if (jQuery.css(elem, \"display\") === \"inline\" && jQuery.css(elem, \"float\") === \"none\") {\n        // inline-level elements accept inline-block;\n        // block-level elements need to be inline with layout\n        if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === \"inline\") {\n          style.display = \"inline-block\";\n        } else {\n          style.zoom = 1;\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n\n      if (!jQuery.support.shrinkWrapBlocks) {\n        anim.always(function () {\n          style.overflow = opts.overflow[0];\n          style.overflowX = opts.overflow[1];\n          style.overflowY = opts.overflow[2];\n        });\n      }\n    } // show/hide pass\n\n\n    for (index in props) {\n      value = props[index];\n\n      if (rfxtypes.exec(value)) {\n        delete props[index];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          continue;\n        }\n\n        handled.push(index);\n      }\n    }\n\n    length = handled.length;\n\n    if (length) {\n      dataShow = jQuery._data(elem, \"fxshow\") || jQuery._data(elem, \"fxshow\", {});\n\n      if (\"hidden\" in dataShow) {\n        hidden = dataShow.hidden;\n      } // store state if its toggle - enables .stop().toggle() to \"reverse\"\n\n\n      if (toggle) {\n        dataShow.hidden = !hidden;\n      }\n\n      if (hidden) {\n        jQuery(elem).show();\n      } else {\n        anim.done(function () {\n          jQuery(elem).hide();\n        });\n      }\n\n      anim.done(function () {\n        var prop;\n\n        jQuery._removeData(elem, \"fxshow\");\n\n        for (prop in orig) {\n          jQuery.style(elem, prop, orig[prop]);\n        }\n      });\n\n      for (index = 0; index < length; index++) {\n        prop = handled[index];\n        tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);\n        orig[prop] = dataShow[prop] || jQuery.style(elem, prop);\n\n        if (!(prop in dataShow)) {\n          dataShow[prop] = tween.start;\n\n          if (hidden) {\n            tween.end = tween.start;\n            tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n          }\n        }\n      }\n    }\n  }\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || \"swing\";\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result;\n\n        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {\n          return tween.elem[tween.prop];\n        } // passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails\n        // so, simple values such as \"10px\" are parsed to Float.\n        // complex values such as \"rotate(1rad)\" are returned as is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // use step hook for back compat - use cssHook if its there - use .style if its\n        // available and use plain properties where available\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Remove in 2.0 - this supports IE8's panic based approach\n  // to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  });\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // show any hidden elements after setting opacity to 0\n      return this.filter(isHidden).css(\"opacity\", 0).show() // animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall);\n\n        doAnimation.finish = function () {\n          anim.stop(true);\n        }; // Empty animations, or finishing resolves immediately\n\n\n        if (empty || jQuery._data(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue && type !== false) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = jQuery._data(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // start the next in the queue if the last step wasn't forced\n        // timers currently will call their complete callbacks, which will dequeue\n        // but only if they were gotoEnd\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = jQuery._data(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // enable finishing flag on private data\n\n\n        data.finish = true; // empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.cur && hooks.cur.finish) {\n          hooks.cur.finish.call(this);\n        } // look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  }); // Generate parameters to create a standard animation\n\n  function genFx(type, includeWidth) {\n    var which,\n        attrs = {\n      height: type\n    },\n        i = 0; // if we include width, step value is 1 to do all cssExpand values,\n    // if we don't include width, step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  } // Generate shortcuts for custom animations\n\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n    };\n    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default; // normalize opt.queue - true/undefined/null -> \"fx\"\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (jQuery.isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    }\n  };\n  jQuery.timers = [];\n  jQuery.fx = Tween.prototype.init;\n\n  jQuery.fx.tick = function () {\n    var timer,\n        timers = jQuery.timers,\n        i = 0;\n    fxNow = jQuery.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Checks the timer has not already been removed\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    if (timer() && jQuery.timers.push(timer)) {\n      jQuery.fx.start();\n    }\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (!timerId) {\n      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);\n    }\n  };\n\n  jQuery.fx.stop = function () {\n    clearInterval(timerId);\n    timerId = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Back Compat <1.8 extension point\n\n  jQuery.fx.step = {};\n\n  if (jQuery.expr && jQuery.expr.filters) {\n    jQuery.expr.filters.animated = function (elem) {\n      return jQuery.grep(jQuery.timers, function (fn) {\n        return elem === fn.elem;\n      }).length;\n    };\n  }\n\n  jQuery.fn.offset = function (options) {\n    if (arguments.length) {\n      return options === undefined ? this : this.each(function (i) {\n        jQuery.offset.setOffset(this, options, i);\n      });\n    }\n\n    var docElem,\n        win,\n        box = {\n      top: 0,\n      left: 0\n    },\n        elem = this[0],\n        doc = elem && elem.ownerDocument;\n\n    if (!doc) {\n      return;\n    }\n\n    docElem = doc.documentElement; // Make sure it's not a disconnected DOM node\n\n    if (!jQuery.contains(docElem, elem)) {\n      return box;\n    } // If we don't have gBCR, just use 0,0 rather than error\n    // BlackBerry 5, iOS 3 (original iPhone)\n\n\n    if (_typeof(elem.getBoundingClientRect) !== core_strundefined) {\n      box = elem.getBoundingClientRect();\n    }\n\n    win = getWindow(doc);\n    return {\n      top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n      left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n    };\n  };\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var position = jQuery.css(elem, \"position\"); // set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      var curElem = jQuery(elem),\n          curOffset = curElem.offset(),\n          curCSSTop = jQuery.css(elem, \"top\"),\n          curCSSLeft = jQuery.css(elem, \"left\"),\n          calculatePosition = (position === \"absolute\" || position === \"fixed\") && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n          props = {},\n          curPosition = {},\n          curTop,\n          curLeft; // need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (jQuery.isFunction(options)) {\n        options = options.call(elem, i, curOffset);\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          parentOffset = {\n        top: 0,\n        left: 0\n      },\n          elem = this[0]; // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // we assume that getBoundingClientRect is available when computed position is fixed\n        offset = elem.getBoundingClientRect();\n      } else {\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(); // Get correct offsets\n\n        offset = this.offset();\n\n        if (!jQuery.nodeName(offsetParent[0], \"html\")) {\n          parentOffset = offsetParent.offset();\n        } // Add offsetParent borders\n\n\n        parentOffset.top += jQuery.css(offsetParent[0], \"borderTopWidth\", true);\n        parentOffset.left += jQuery.css(offsetParent[0], \"borderLeftWidth\", true);\n      } // Subtract parent offsets and element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent || document.documentElement;\n\n        while (offsetParent && !jQuery.nodeName(offsetParent, \"html\") && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || document.documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = /Y/.test(prop);\n\n    jQuery.fn[method] = function (val) {\n      return jQuery.access(this, function (elem, method, val) {\n        var win = getWindow(elem);\n\n        if (val === undefined) {\n          return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length, null);\n    };\n  });\n\n  function getWindow(elem) {\n    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;\n  } // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return jQuery.access(this, function (elem, type, value) {\n          var doc;\n\n          if (jQuery.isWindow(elem)) {\n            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n            // isn't a whole lot we can do. See pull request at this URL for discussion:\n            // https://github.com/jquery/jquery/pull/764\n            return elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n            // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable, null);\n      };\n    });\n  }); // Limit scope pollution from any deprecated API\n  // (function() {\n  // })();\n  // Expose jQuery to the global object\n\n  window.jQuery = window.$ = jQuery; // Expose jQuery as an AMD module, but only for AMD loaders that\n  // understand the issues with loading multiple versions of jQuery\n  // in a page that all might call define(). The loader will indicate\n  // they have special allowances for multiple jQuery versions by\n  // specifying define.amd.jQuery = true. Register as a named module,\n  // since jQuery can be concatenated with other files that may use define,\n  // but not use a proper concatenation script that understands anonymous\n  // AMD modules. A named AMD is safest and most robust way to register.\n  // Lowercase jquery is used because AMD module names are derived from\n  // file names, and jQuery is normally delivered in a lowercase file name.\n  // Do this after creating the global so that if an AMD module wants to call\n  // noConflict to hide this version of jQuery, it will work.\n\n  if ( true && __webpack_require__.amdO.jQuery) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n})(window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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N0I3QyxDQUFQO01BOEJILENBbENEO0lBbUNILENBckNEO0VBc0NILENBdkNELEVBaHpTMkIsQ0F3MVMzQjtFQUNBO0VBRUE7RUFDQTs7RUFDQTNMLE1BQU0sQ0FBQ1EsTUFBUCxHQUFnQlIsTUFBTSxDQUFDVSxDQUFQLEdBQVdGLE1BQTNCLENBNzFTMkIsQ0ErMVMzQjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VBQ0EsSUFBSyxTQUE4Q29vQyx3QkFBQSxDQUFXcG9DLE1BQTlELEVBQXVFO0lBQ25Fb29DLGlDQUFrQixFQUFaLG1DQUFnQixZQUFZO01BQUUsT0FBT3BvQyxNQUFQO0lBQWdCLENBQTlDO0FBQUEsa0dBQU47RUFDSDtBQUVBLENBLzJTTCxFQSsyU1FSLE1BLzJTUiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9qcXVlcnkuanM/OWZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuOS4xXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMDUsIDIwMTIgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxMy0yLTRcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuICAgIC8vIENhbid0IGRvIHRoaXMgYmVjYXVzZSBzZXZlcmFsIGFwcHMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2VcbiAgICAvLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbiAgICAvLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbiAgICAvL1widXNlIHN0cmljdFwiO1xuICAgIHZhclxuICAgICAgICAvLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbiAgICAgICAgcmVhZHlMaXN0LFxuICAgIFxuICAgICAgICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbiAgICAgICAgcm9vdGpRdWVyeSxcbiAgICBcbiAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAvLyBGb3IgYHR5cGVvZiBub2RlLm1ldGhvZGAgaW5zdGVhZCBvZiBgbm9kZS5tZXRob2QgIT09IHVuZGVmaW5lZGBcbiAgICAgICAgY29yZV9zdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkLFxuICAgIFxuICAgICAgICAvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXG4gICAgICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICBcbiAgICAgICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgIF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuICAgIFxuICAgICAgICAvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgICAgICBfJCA9IHdpbmRvdy4kLFxuICAgIFxuICAgICAgICAvLyBbW0NsYXNzXV0gLT4gdHlwZSBwYWlyc1xuICAgICAgICBjbGFzczJ0eXBlID0ge30sXG4gICAgXG4gICAgICAgIC8vIExpc3Qgb2YgZGVsZXRlZCBkYXRhIGNhY2hlIGlkcywgc28gd2UgY2FuIHJldXNlIHRoZW1cbiAgICAgICAgY29yZV9kZWxldGVkSWRzID0gW10sXG4gICAgXG4gICAgICAgIGNvcmVfdmVyc2lvbiA9IFwiMS45LjFcIixcbiAgICBcbiAgICAgICAgLy8gU2F2ZSBhIHJlZmVyZW5jZSB0byBzb21lIGNvcmUgbWV0aG9kc1xuICAgICAgICBjb3JlX2NvbmNhdCA9IGNvcmVfZGVsZXRlZElkcy5jb25jYXQsXG4gICAgICAgIGNvcmVfcHVzaCA9IGNvcmVfZGVsZXRlZElkcy5wdXNoLFxuICAgICAgICBjb3JlX3NsaWNlID0gY29yZV9kZWxldGVkSWRzLnNsaWNlLFxuICAgICAgICBjb3JlX2luZGV4T2YgPSBjb3JlX2RlbGV0ZWRJZHMuaW5kZXhPZixcbiAgICAgICAgY29yZV90b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmcsXG4gICAgICAgIGNvcmVfaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgY29yZV90cmltID0gY29yZV92ZXJzaW9uLnRyaW0sXG4gICAgXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG4gICAgICAgIGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcbiAgICAgICAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3RqUXVlcnkgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLy8gVXNlZCBmb3IgbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgICBjb3JlX3BudW0gPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2UsXG4gICAgXG4gICAgICAgIC8vIFVzZWQgZm9yIHNwbGl0dGluZyBvbiB3aGl0ZXNwYWNlXG4gICAgICAgIGNvcmVfcm5vdHdoaXRlID0gL1xcUysvZyxcbiAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQIChoZXJlJ3MgbG9va2luZyBhdCB5b3UsIFNhZmFyaSA1LjAgYW5kIElFKVxuICAgICAgICBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcbiAgICBcbiAgICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcbiAgICAgICAgLy8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuICAgICAgICAvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcbiAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86KDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG4gICAgXG4gICAgICAgIC8vIE1hdGNoIGEgc3RhbmRhbG9uZSB0YWdcbiAgICAgICAgcnNpbmdsZVRhZyA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxcbiAgICBcbiAgICAgICAgLy8gSlNPTiBSZWdFeHBcbiAgICAgICAgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLyxcbiAgICAgICAgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLFxuICAgICAgICBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVtcXGRhLWZBLUZdezR9KS9nLFxuICAgICAgICBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcclxcbl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/KD86XFxkK1xcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS9nLFxuICAgIFxuICAgICAgICAvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbiAgICAgICAgcm1zUHJlZml4ID0gL14tbXMtLyxcbiAgICAgICAgcmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcbiAgICBcbiAgICAgICAgLy8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuICAgICAgICBmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlclxuICAgICAgICBjb21wbGV0ZWQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgXG4gICAgICAgICAgICAvLyByZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgaXMgZ29vZCBlbm91Z2ggZm9yIHVzIHRvIGNhbGwgdGhlIGRvbSByZWFkeSBpbiBvbGRJRVxuICAgICAgICAgICAgaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyIHx8IGV2ZW50LnR5cGUgPT09IFwibG9hZFwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcbiAgICAgICAgICAgICAgICBkZXRhY2goKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2xlYW4tdXAgbWV0aG9kIGZvciBkb20gcmVhZHkgZXZlbnRzXG4gICAgICAgIGRldGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG4gICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBjb21wbGV0ZWQgKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGV0YWNoRXZlbnQoIFwib25sb2FkXCIsIGNvbXBsZXRlZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgIGpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcbiAgICAgICAganF1ZXJ5OiBjb3JlX3ZlcnNpb24sXG4gICAgXG4gICAgICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeSApIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCwgZWxlbTtcbiAgICBcbiAgICAgICAgICAgIC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuICAgICAgICAgICAgaWYgKCAhc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gXCI8XCIgJiYgc2VsZWN0b3IuY2hhckF0KCBzZWxlY3Rvci5sZW5ndGggLSAxICkgPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcbiAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuICAgICAgICAgICAgICAgIGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbMV0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWzFdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJCgjaWQpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWzJdICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUgYW5kIE9wZXJhIHJldHVybiBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5pZCAhPT0gbWF0Y2hbMl0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb290alF1ZXJ5LmZpbmQoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgaW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcbiAgICAgICAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gSEFORExFOiAkKERPTUVsZW1lbnQpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgIFxuICAgICAgICAgICAgLy8gSEFORExFOiAkKGZ1bmN0aW9uKVxuICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICggc2VsZWN0b3Iuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG4gICAgICAgIHNlbGVjdG9yOiBcIlwiLFxuICAgIFxuICAgICAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgIFxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxuICAgICAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29yZV9zbGljZS5jYWxsKCB0aGlzICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcbiAgICAgICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiggbnVtICkge1xuICAgICAgICAgICAgcmV0dXJuIG51bSA9PSBudWxsID9cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYSAnY2xlYW4nIGFycmF5XG4gICAgICAgICAgICAgICAgdGhpcy50b0FycmF5KCkgOlxuICAgIFxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBqdXN0IHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAoIG51bSA8IDAgPyB0aGlzWyB0aGlzLmxlbmd0aCArIG51bSBdIDogdGhpc1sgbnVtIF0gKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuICAgICAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcbiAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgXG4gICAgICAgICAgICAvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuICAgICAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuICAgIFxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcbiAgICAgICAgICAgIHJldC5wcmV2T2JqZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIFxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG4gICAgICAgIC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG4gICAgICAgIC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5LilcbiAgICAgICAgZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrLCBhcmdzICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICByZWFkeTogZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgalF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHNsaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggY29yZV9zbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoIDAgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSggLTEgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZXE6IGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzW2pdIF0gOiBbXSApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICAgIC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuICAgICAgICBwdXNoOiBjb3JlX3B1c2gsXG4gICAgICAgIHNvcnQ6IFtdLnNvcnQsXG4gICAgICAgIHNwbGljZTogW10uc3BsaWNlXG4gICAgfTtcbiAgICBcbiAgICAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG4gICAgalF1ZXJ5LmZuLmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuICAgIFxuICAgIGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzcmMsIGNvcHlJc0FycmF5LCBjb3B5LCBuYW1lLCBvcHRpb25zLCBjbG9uZSxcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZXAgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAgZGVlcCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICAgICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIGkgPSAyO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKCBsZW5ndGggPT09IGkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgLS1pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIFxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBub0NvbmZsaWN0OiBmdW5jdGlvbiggZGVlcCApIHtcbiAgICAgICAgICAgIGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuJCA9IF8kO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgIFxuICAgICAgICAvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG4gICAgICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG4gICAgICAgIHJlYWR5V2FpdDogMSxcbiAgICBcbiAgICAgICAgLy8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG4gICAgICAgIGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG4gICAgICAgICAgICBpZiAoIGhvbGQgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5V2FpdCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHkoIHRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLy8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuICAgICAgICByZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG4gICAgXG4gICAgICAgICAgICAvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG4gICAgICAgICAgICBpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG4gICAgICAgICAgICBpZiAoICFkb2N1bWVudC5ib2R5ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgICAgICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuICAgIFxuICAgICAgICAgICAgLy8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuICAgICAgICAgICAgaWYgKCBqUXVlcnkuZm4udHJpZ2dlciApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlcihcInJlYWR5XCIpLm9mZihcInJlYWR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLlxuICAgICAgICAvLyBTaW5jZSB2ZXJzaW9uIDEuMywgRE9NIG1ldGhvZHMgYW5kIGZ1bmN0aW9ucyBsaWtlIGFsZXJ0XG4gICAgICAgIC8vIGFyZW4ndCBzdXBwb3J0ZWQuIFRoZXkgcmV0dXJuIGZhbHNlIG9uIElFICgjMjk2OCkuXG4gICAgICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgaXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgcmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChvYmopICkgJiYgaXNGaW5pdGUoIG9iaiApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICB0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgaWYgKCBvYmogPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKCBvYmogKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG4gICAgICAgICAgICAgICAgY2xhc3MydHlwZVsgY29yZV90b1N0cmluZy5jYWxsKG9iaikgXSB8fCBcIm9iamVjdFwiIDpcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb2JqO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBhbiBPYmplY3QuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAoICFvYmogfHwgalF1ZXJ5LnR5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3RcbiAgICAgICAgICAgICAgICBpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAhY29yZV9oYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvcmVfaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgLy8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG4gICAgICAgICAgICAvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cbiAgICBcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKCBrZXkgaW4gb2JqICkge31cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBjb3JlX2hhc093bi5jYWxsKCBvYmosIGtleSApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuICAgICAgICAvLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4gICAgICAgIC8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbiAgICAgICAgcGFyc2VIVE1MOiBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG4gICAgICAgICAgICBpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICAgICAga2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuICAgIFxuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuICAgICAgICAgICAgICAgIHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG4gICAgXG4gICAgICAgICAgICAvLyBTaW5nbGUgdGFnXG4gICAgICAgICAgICBpZiAoIHBhcnNlZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsxXSApIF07XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBwYXJzZWQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcbiAgICAgICAgICAgIGlmICggc2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBwYXJzZUpTT046IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gICAgICAgICAgICBpZiAoIHdpbmRvdy5KU09OICYmIHdpbmRvdy5KU09OLnBhcnNlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuSlNPTi5wYXJzZSggZGF0YSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCBkYXRhID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQgKElFIGNhbid0IGhhbmRsZSBpdClcbiAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5LnRyaW0oIGRhdGEgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5jb21pbmcgZGF0YSBpcyBhY3R1YWwgSlNPTlxuICAgICAgICAgICAgICAgICAgICAvLyBMb2dpYyBib3Jyb3dlZCBmcm9tIGh0dHA6Ly9qc29uLm9yZy9qc29uMi5qc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJ2YWxpZGNoYXJzLnRlc3QoIGRhdGEucmVwbGFjZSggcnZhbGlkZXNjYXBlLCBcIkBcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSggcnZhbGlkdG9rZW5zLCBcIl1cIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSggcnZhbGlkYnJhY2VzLCBcIlwiKSkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBuZXcgRnVuY3Rpb24oIFwicmV0dXJuIFwiICsgZGF0YSApICkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIEpTT046IFwiICsgZGF0YSApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG4gICAgICAgIHBhcnNlWE1MOiBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgIHZhciB4bWwsIHRtcDtcbiAgICAgICAgICAgIGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICggd2luZG93LkRPTVBhcnNlciApIHsgLy8gU3RhbmRhcmRcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgICAgICB4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhICwgXCJ0ZXh0L3htbFwiICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSUVcbiAgICAgICAgICAgICAgICAgICAgeG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTERPTVwiICk7XG4gICAgICAgICAgICAgICAgICAgIHhtbC5hc3luYyA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgICAgICAgICAgeG1sLmxvYWRYTUwoIGRhdGEgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKCBlICkge1xuICAgICAgICAgICAgICAgIHhtbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHhtbDtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgbm9vcDogZnVuY3Rpb24oKSB7fSxcbiAgICBcbiAgICAgICAgLy8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcbiAgICAgICAgLy8gV29ya2Fyb3VuZHMgYmFzZWQgb24gZmluZGluZ3MgYnkgSmltIERyaXNjb2xsXG4gICAgICAgIC8vIGh0dHA6Ly93ZWJsb2dzLmphdmEubmV0L2Jsb2cvZHJpc2NvbGwvYXJjaGl2ZS8yMDA5LzA5LzA4L2V2YWwtamF2YXNjcmlwdC1nbG9iYWwtY29udGV4dFxuICAgICAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgIGlmICggZGF0YSAmJiBqUXVlcnkudHJpbSggZGF0YSApICkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBleGVjU2NyaXB0IG9uIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGFuIGFub255bW91cyBmdW5jdGlvbiBzbyB0aGF0IGNvbnRleHQgaXMgd2luZG93XG4gICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4galF1ZXJ5IGluIEZpcmVmb3hcbiAgICAgICAgICAgICAgICAoIHdpbmRvdy5leGVjU2NyaXB0IHx8IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dbIFwiZXZhbFwiIF0uY2FsbCggd2luZG93LCBkYXRhICk7XG4gICAgICAgICAgICAgICAgfSApKCBkYXRhICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbiAgICAgICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuICAgICAgICBjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgbm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgICAgZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIGFyZ3MgKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gaXNBcnJheWxpa2UoIG9iaiApO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBhcmdzICkge1xuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIFVzZSBuYXRpdmUgU3RyaW5nLnRyaW0gZnVuY3Rpb24gd2hlcmV2ZXIgcG9zc2libGVcbiAgICAgICAgdHJpbTogY29yZV90cmltICYmICFjb3JlX3RyaW0uY2FsbChcIlxcdUZFRkZcXHhBMFwiKSA/XG4gICAgICAgICAgICBmdW5jdGlvbiggdGV4dCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfdHJpbS5jYWxsKCB0ZXh0ICk7XG4gICAgICAgICAgICB9IDpcbiAgICBcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB1c2Ugb3VyIG93biB0cmltbWluZyBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICBmdW5jdGlvbiggdGV4dCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgICAgICggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcbiAgICBcbiAgICAgICAgICAgIGlmICggYXJyICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBpc0FycmF5bGlrZSggT2JqZWN0KGFycikgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCByZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFsgYXJyIF0gOiBhcnJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3JlX3B1c2guY2FsbCggcmV0LCBhcnIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuICAgICAgICAgICAgdmFyIGxlbjtcbiAgICBcbiAgICAgICAgICAgIGlmICggYXJyICkge1xuICAgICAgICAgICAgICAgIGlmICggY29yZV9pbmRleE9mICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZV9pbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkgPSBpID8gaSA8IDAgPyBNYXRoLm1heCggMCwgbGVuICsgaSApIDogaSA6IDA7XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgYWNjZXNzaW5nIGluIHNwYXJzZSBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpIGluIGFyciAmJiBhcnJbIGkgXSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHNlY29uZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICBcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGwgPT09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICAgICAgZm9yICggOyBqIDwgbDsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlICggc2Vjb25kW2pdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgZmlyc3QubGVuZ3RoID0gaTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZ3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ICkge1xuICAgICAgICAgICAgdmFyIHJldFZhbCxcbiAgICAgICAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBpbnYgPSAhIWludjtcbiAgICBcbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcbiAgICAgICAgICAgIC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG4gICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICByZXRWYWwgPSAhIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG4gICAgICAgICAgICAgICAgaWYgKCBpbnYgIT09IHJldFZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIGVsZW1zWyBpIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgICAgbWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGlzQXJyYXkgPSBpc0FycmF5bGlrZSggZWxlbXMgKSxcbiAgICAgICAgICAgICAgICByZXQgPSBbXTtcbiAgICBcbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpclxuICAgICAgICAgICAgaWYgKCBpc0FycmF5ICkge1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0WyByZXQubGVuZ3RoIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gZWxlbXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbIHJldC5sZW5ndGggXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVfY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuICAgICAgICBndWlkOiAxLFxuICAgIFxuICAgICAgICAvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbiAgICAgICAgLy8gYXJndW1lbnRzLlxuICAgICAgICBwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgdmFyIGFyZ3MsIHByb3h5LCB0bXA7XG4gICAgXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHRtcCA9IGZuWyBjb250ZXh0IF07XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGZuO1xuICAgICAgICAgICAgICAgIGZuID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcbiAgICAgICAgICAgIC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICBpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gU2ltdWxhdGVkIGJpbmRcbiAgICAgICAgICAgIGFyZ3MgPSBjb3JlX3NsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuICAgICAgICAgICAgcHJveHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIGNvcmVfc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuICAgICAgICAvLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbiAgICAgICAgYWNjZXNzOiBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGJ1bGsgPSBrZXkgPT0gbnVsbDtcbiAgICBcbiAgICAgICAgICAgIC8vIFNldHMgbWFueSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgICAgIGNoYWluYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yICggaSBpbiBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gU2V0cyBvbmUgdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBidWxrICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByYXcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gbnVsbDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVsayA9IGZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBmbiApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiggZWxlbXNbaV0sIGtleSwgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gY2hhaW5hYmxlID9cbiAgICAgICAgICAgICAgICBlbGVtcyA6XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gR2V0c1xuICAgICAgICAgICAgICAgIGJ1bGsgP1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtcyApIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBub3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICggbmV3IERhdGUoKSApLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgaWYgKCAhcmVhZHlMaXN0ICkge1xuICAgIFxuICAgICAgICAgICAgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG4gICAgXG4gICAgICAgICAgICAvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgICAgICAgICAgIC8vIHdlIG9uY2UgdHJpZWQgdG8gdXNlIHJlYWR5U3RhdGUgXCJpbnRlcmFjdGl2ZVwiIGhlcmUsIGJ1dCBpdCBjYXVzZWQgaXNzdWVzIGxpa2UgdGhlIG9uZVxuICAgICAgICAgICAgLy8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuICAgICAgICAgICAgaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG4gICAgXG4gICAgICAgICAgICAvLyBTdGFuZGFyZHMtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydCBET01Db250ZW50TG9hZGVkXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG4gICAgXG4gICAgICAgICAgICAvLyBJZiBJRSBldmVudCBtb2RlbCBpcyB1c2VkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCwgbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGNvbXBsZXRlZCApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCBcIm9ubG9hZFwiLCBjb21wbGV0ZWQgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBJZiBJRSBhbmQgbm90IGEgZnJhbWVcbiAgICAgICAgICAgICAgICAvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHdpbmRvdy5mcmFtZUVsZW1lbnQgPT0gbnVsbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgIFxuICAgICAgICAgICAgICAgIGlmICggdG9wICYmIHRvcC5kb1Njcm9sbCApIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIGRvU2Nyb2xsQ2hlY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkuaXNSZWFkeSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCggZG9TY3JvbGxDaGVjaywgNTAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV0YWNoIGFsbCBkb20gcmVhZHkgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWNoKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbiAgICBqUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgICAgY2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgXG4gICAgZnVuY3Rpb24gaXNBcnJheWxpa2UoIG9iaiApIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuICAgIFxuICAgICAgICBpZiAoIGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCBvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCB0eXBlICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICggbGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICB0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqICk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFsbCBqUXVlcnkgb2JqZWN0cyBzaG91bGQgcG9pbnQgYmFjayB0byB0aGVzZVxuICAgIHJvb3RqUXVlcnkgPSBqUXVlcnkoZG9jdW1lbnQpO1xuICAgIC8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbiAgICB2YXIgb3B0aW9uc0NhY2hlID0ge307XG4gICAgXG4gICAgLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG4gICAgZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdID0ge307XG4gICAgICAgIGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcbiAgICAgICAgICAgIG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIFxuICAgIC8qXG4gICAgICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICAgICAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAgICAgKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBQb3NzaWJsZSBvcHRpb25zOlxuICAgICAqXG4gICAgICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICAgICAqXG4gICAgICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gICAgICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICAgICAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICAgICAqXG4gICAgICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAgICAgKlxuICAgICAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICAgICAqXG4gICAgICovXG4gICAgalF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgIFxuICAgICAgICAvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG4gICAgICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcbiAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOlxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcbiAgICBcbiAgICAgICAgdmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcbiAgICAgICAgICAgIGZpcmluZyxcbiAgICAgICAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcbiAgICAgICAgICAgIG1lbW9yeSxcbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICAgICAgICBmaXJlZCxcbiAgICAgICAgICAgIC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLFxuICAgICAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcbiAgICAgICAgICAgIGZpcmluZ0luZGV4LFxuICAgICAgICAgICAgLy8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXG4gICAgICAgICAgICBmaXJpbmdTdGFydCxcbiAgICAgICAgICAgIC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG4gICAgICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgICAgICAvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG4gICAgICAgICAgICBzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICAgICAgICAgIG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XG4gICAgICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcbiAgICAgICAgICAgICAgICBmaXJpbmdTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggZGF0YVsgMCBdLCBkYXRhWyAxIF0gKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YWNrLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCBzdGFjay5zaGlmdCgpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG4gICAgICAgICAgICBzZWxmID0ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIGFkZCggYXJncyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goIGFyZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKCBhcmcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgZmlyaW5nIGJhdGNoP1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmaXJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCBtZW1vcnkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZmlyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmRleCA8PSBmaXJpbmdMZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG4gICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbiggZm4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbiA/IGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOiAhISggbGlzdCAmJiBsaXN0Lmxlbmd0aCApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG4gICAgICAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBJcyBpdCBkaXNhYmxlZD9cbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhbGlzdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgICAgICBsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1lbW9yeSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gSXMgaXQgbG9ja2VkP1xuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RhY2s7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0ICYmICggIWZpcmVkIHx8IHN0YWNrICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpcmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuICAgICAgICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZmlyZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICBcbiAgICAgICAgRGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuICAgICAgICAgICAgdmFyIHR1cGxlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIiBdLFxuICAgICAgICAgICAgICAgICAgICBbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVqZWN0ZWRcIiBdLFxuICAgICAgICAgICAgICAgICAgICBbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSBdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSB0dXBsZVsgMCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsxXSBdKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLnByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEZWZlclsgYWN0aW9uICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IHt9O1xuICAgIFxuICAgICAgICAgICAgLy8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgcHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuICAgIFxuICAgICAgICAgICAgLy8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG4gICAgICAgICAgICAgICAgcHJvbWlzZVsgdHVwbGVbMV0gXSA9IGxpc3QuYWRkO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICggc3RhdGVTdHJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0cmluZztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuICAgICAgICAgICAgICAgICAgICB9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVswXSBdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcbiAgICAgICAgICAgIHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcbiAgICAgICAgICAgIGlmICggZnVuYyApIHtcbiAgICAgICAgICAgICAgICBmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gQWxsIGRvbmUhXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIERlZmVycmVkIGhlbHBlclxuICAgICAgICB3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzID0gY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcbiAgICBcbiAgICAgICAgICAgICAgICAvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8ICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcbiAgICBcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG4gICAgXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvcmVfc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgIHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG4gICAgXG4gICAgICAgICAgICAvLyBhZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuICAgICAgICAgICAgICAgIHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLXJlbWFpbmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcbiAgICAgICAgICAgIGlmICggIXJlbWFpbmluZyApIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgalF1ZXJ5LnN1cHBvcnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgICAgIHZhciBzdXBwb3J0LCBhbGwsIGEsXG4gICAgICAgICAgICBpbnB1dCwgc2VsZWN0LCBmcmFnbWVudCxcbiAgICAgICAgICAgIG9wdCwgZXZlbnROYW1lLCBpc1N1cHBvcnRlZCwgaSxcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgXG4gICAgICAgIC8vIFNldHVwXG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIsIFwidFwiICk7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuICAgIFxuICAgICAgICAvLyBTdXBwb3J0IHRlc3RzIHdvbid0IHJ1biBpbiBzb21lIGxpbWl0ZWQgb3Igbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzXG4gICAgICAgIGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XG4gICAgICAgIGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWyAwIF07XG4gICAgICAgIGlmICggIWFsbCB8fCAhYSB8fCAhYWxsLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBGaXJzdCBiYXRjaCBvZiB0ZXN0c1xuICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikgKTtcbiAgICAgICAgaW5wdXQgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVsgMCBdO1xuICAgIFxuICAgICAgICBhLnN0eWxlLmNzc1RleHQgPSBcInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCI7XG4gICAgICAgIHN1cHBvcnQgPSB7XG4gICAgICAgICAgICAvLyBUZXN0IHNldEF0dHJpYnV0ZSBvbiBjYW1lbENhc2UgY2xhc3MuIElmIGl0IHdvcmtzLCB3ZSBuZWVkIGF0dHJGaXhlcyB3aGVuIGRvaW5nIGdldC9zZXRBdHRyaWJ1dGUgKGllNi83KVxuICAgICAgICAgICAgZ2V0U2V0QXR0cmlidXRlOiBkaXYuY2xhc3NOYW1lICE9PSBcInRcIixcbiAgICBcbiAgICAgICAgICAgIC8vIElFIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiAuaW5uZXJIVE1MIGlzIHVzZWRcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlOiBkaXYuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMyxcbiAgICBcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRib2R5IGVsZW1lbnRzIGFyZW4ndCBhdXRvbWF0aWNhbGx5IGluc2VydGVkXG4gICAgICAgICAgICAvLyBJRSB3aWxsIGluc2VydCB0aGVtIGludG8gZW1wdHkgdGFibGVzXG4gICAgICAgICAgICB0Ym9keTogIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCxcbiAgICBcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuICAgICAgICAgICAgLy8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuICAgICAgICAgICAgaHRtbFNlcmlhbGl6ZTogISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLmxlbmd0aCxcbiAgICBcbiAgICAgICAgICAgIC8vIEdldCB0aGUgc3R5bGUgaW5mb3JtYXRpb24gZnJvbSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vIChJRSB1c2VzIC5jc3NUZXh0IGluc3RlYWQpXG4gICAgICAgICAgICBzdHlsZTogL3RvcC8udGVzdCggYS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSApLFxuICAgIFxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgVVJMcyBhcmVuJ3QgbWFuaXB1bGF0ZWRcbiAgICAgICAgICAgIC8vIChJRSBub3JtYWxpemVzIGl0IGJ5IGRlZmF1bHQpXG4gICAgICAgICAgICBocmVmTm9ybWFsaXplZDogYS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIi9hXCIsXG4gICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBlbGVtZW50IG9wYWNpdHkgZXhpc3RzXG4gICAgICAgICAgICAvLyAoSUUgdXNlcyBmaWx0ZXIgaW5zdGVhZClcbiAgICAgICAgICAgIC8vIFVzZSBhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgV2ViS2l0IGlzc3VlLiBTZWUgIzUxNDVcbiAgICAgICAgICAgIG9wYWNpdHk6IC9eMC41Ly50ZXN0KCBhLnN0eWxlLm9wYWNpdHkgKSxcbiAgICBcbiAgICAgICAgICAgIC8vIFZlcmlmeSBzdHlsZSBmbG9hdCBleGlzdGVuY2VcbiAgICAgICAgICAgIC8vIChJRSB1c2VzIHN0eWxlRmxvYXQgaW5zdGVhZCBvZiBjc3NGbG9hdClcbiAgICAgICAgICAgIGNzc0Zsb2F0OiAhIWEuc3R5bGUuY3NzRmxvYXQsXG4gICAgXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVmYXVsdCBjaGVja2JveC9yYWRpbyB2YWx1ZSAoXCJcIiBvbiBXZWJLaXQ7IFwib25cIiBlbHNld2hlcmUpXG4gICAgICAgICAgICBjaGVja09uOiAhIWlucHV0LnZhbHVlLFxuICAgIFxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYSBzZWxlY3RlZC1ieS1kZWZhdWx0IG9wdGlvbiBoYXMgYSB3b3JraW5nIHNlbGVjdGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gKFdlYktpdCBkZWZhdWx0cyB0byBmYWxzZSBpbnN0ZWFkIG9mIHRydWUsIElFIHRvbywgaWYgaXQncyBpbiBhbiBvcHRncm91cClcbiAgICAgICAgICAgIG9wdFNlbGVjdGVkOiBvcHQuc2VsZWN0ZWQsXG4gICAgXG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZW5jdHlwZSBzdXBwb3J0IG9uIGEgZm9ybSAoIzY3NDMpXG4gICAgICAgICAgICBlbmN0eXBlOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLmVuY3R5cGUsXG4gICAgXG4gICAgICAgICAgICAvLyBNYWtlcyBzdXJlIGNsb25pbmcgYW4gaHRtbDUgZWxlbWVudCBkb2VzIG5vdCBjYXVzZSBwcm9ibGVtc1xuICAgICAgICAgICAgLy8gV2hlcmUgb3V0ZXJIVE1MIGlzIHVuZGVmaW5lZCwgdGhpcyBzdGlsbCB3b3Jrc1xuICAgICAgICAgICAgaHRtbDVDbG9uZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm5hdlwiKS5jbG9uZU5vZGUoIHRydWUgKS5vdXRlckhUTUwgIT09IFwiPDpuYXY+PC86bmF2PlwiLFxuICAgIFxuICAgICAgICAgICAgLy8galF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgREVQUkVDQVRFRCBpbiAxLjggc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydCBRdWlya3MgTW9kZVxuICAgICAgICAgICAgYm94TW9kZWw6IGRvY3VtZW50LmNvbXBhdE1vZGUgPT09IFwiQ1NTMUNvbXBhdFwiLFxuICAgIFxuICAgICAgICAgICAgLy8gV2lsbCBiZSBkZWZpbmVkIGxhdGVyXG4gICAgICAgICAgICBkZWxldGVFeHBhbmRvOiB0cnVlLFxuICAgICAgICAgICAgbm9DbG9uZUV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgaW5saW5lQmxvY2tOZWVkc0xheW91dDogZmFsc2UsXG4gICAgICAgICAgICBzaHJpbmtXcmFwQmxvY2tzOiBmYWxzZSxcbiAgICAgICAgICAgIHJlbGlhYmxlTWFyZ2luUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICBib3hTaXppbmdSZWxpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb246IGZhbHNlXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjaGVja2VkIHN0YXR1cyBpcyBwcm9wZXJseSBjbG9uZWRcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSBpbnB1dC5jbG9uZU5vZGUoIHRydWUgKS5jaGVja2VkO1xuICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgb3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmVuJ3QgbWFya2VkIGFzIGRpc2FibGVkXG4gICAgICAgIC8vIChXZWJLaXQgbWFya3MgdGhlbSBhcyBkaXNhYmxlZClcbiAgICAgICAgc2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgc3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG4gICAgXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlbGV0ZSBkaXYudGVzdDtcbiAgICAgICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgICAgIHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiB0cnVzdCBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcbiAgICAgICAgc3VwcG9ydC5pbnB1dCA9IGlucHV0LmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG4gICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGFuIGlucHV0IG1haW50YWlucyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuICAgICAgICBpbnB1dC52YWx1ZSA9IFwidFwiO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcbiAgICAgICAgc3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuICAgIFxuICAgICAgICAvLyAjMTEyMTcgLSBXZWJLaXQgbG9zZXMgY2hlY2sgd2hlbiB0aGUgbmFtZSBpcyBhZnRlciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGVcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJ0XCIgKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcbiAgICBcbiAgICAgICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBhIGRpc2Nvbm5lY3RlZCBjaGVja2JveCB3aWxsIHJldGFpbiBpdHMgY2hlY2tlZFxuICAgICAgICAvLyB2YWx1ZSBvZiB0cnVlIGFmdGVyIGFwcGVuZGVkIHRvIHRoZSBET00gKElFNi83KVxuICAgICAgICBzdXBwb3J0LmFwcGVuZENoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuICAgIFxuICAgICAgICAvLyBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcbiAgICAgICAgc3VwcG9ydC5jaGVja0Nsb25lID0gZnJhZ21lbnQuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG4gICAgXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgLy8gT3BlcmEgZG9lcyBub3QgY2xvbmUgZXZlbnRzIChhbmQgdHlwZW9mIGRpdi5hdHRhY2hFdmVudCA9PT0gdW5kZWZpbmVkKS5cbiAgICAgICAgLy8gSUU5LTEwIGNsb25lcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50LCBidXQgdGhleSBkb24ndCB0cmlnZ2VyIHdpdGggLmNsaWNrKClcbiAgICAgICAgaWYgKCBkaXYuYXR0YWNoRXZlbnQgKSB7XG4gICAgICAgICAgICBkaXYuYXR0YWNoRXZlbnQoIFwib25jbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0Lm5vQ2xvbmVFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xpY2soKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBTdXBwb3J0OiBJRTw5IChsYWNrIHN1Ym1pdC9jaGFuZ2UgYnViYmxlKSwgRmlyZWZveCAxNysgKGxhY2sgZm9jdXNpbiBldmVudClcbiAgICAgICAgLy8gQmV3YXJlIG9mIENTUCByZXN0cmljdGlvbnMgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NlY3VyaXR5L0NTUCksIHRlc3QvY3NwLnBocFxuICAgICAgICBmb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCBjaGFuZ2U6IHRydWUsIGZvY3VzaW46IHRydWUgfSkge1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSggZXZlbnROYW1lID0gXCJvblwiICsgaSwgXCJ0XCIgKTtcbiAgICBcbiAgICAgICAgICAgIHN1cHBvcnRbIGkgKyBcIkJ1YmJsZXNcIiBdID0gZXZlbnROYW1lIGluIHdpbmRvdyB8fCBkaXYuYXR0cmlidXRlc1sgZXZlbnROYW1lIF0uZXhwYW5kbyA9PT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuICAgICAgICBkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuICAgICAgICBzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuICAgIFxuICAgICAgICAvLyBSdW4gdGVzdHMgdGhhdCBuZWVkIGEgYm9keSBhdCBkb2MgcmVhZHlcbiAgICAgICAgalF1ZXJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciwgbWFyZ2luRGl2LCB0ZHMsXG4gICAgICAgICAgICAgICAgZGl2UmVzZXQgPSBcInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtcIixcbiAgICAgICAgICAgICAgICBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuICAgIFxuICAgICAgICAgICAgaWYgKCAhYm9keSApIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZm9yIGZyYW1lc2V0IGRvY3MgdGhhdCBkb24ndCBoYXZlIGEgYm9keVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0Oi05OTk5cHg7bWFyZ2luLXRvcDoxcHhcIjtcbiAgICBcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB0aGV5IGFyZSBzZXRcbiAgICAgICAgICAgIC8vIHRvIGRpc3BsYXk6bm9uZSBhbmQgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHZpc2libGUgdGFibGUgY2VsbHMgaW4gYVxuICAgICAgICAgICAgLy8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmluZyBpZiBhbiBlbGVtZW50IGhhcyBiZWVuIGhpZGRlbiBkaXJlY3RseSB1c2luZ1xuICAgICAgICAgICAgLy8gZGlzcGxheTpub25lIChpdCBpcyBzdGlsbCBzYWZlIHRvIHVzZSBvZmZzZXRzIGlmIGEgcGFyZW50IGVsZW1lbnQgaXNcbiAgICAgICAgICAgIC8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjx0YWJsZT48dHI+PHRkPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIjtcbiAgICAgICAgICAgIHRkcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRkXCIpO1xuICAgICAgICAgICAgdGRzWyAwIF0uc3R5bGUuY3NzVGV4dCA9IFwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowO2Rpc3BsYXk6bm9uZVwiO1xuICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSAoIHRkc1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMCApO1xuICAgIFxuICAgICAgICAgICAgdGRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICB0ZHNbIDEgXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGVtcHR5IHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0XG4gICAgICAgICAgICBzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyA9IGlzU3VwcG9ydGVkICYmICggdGRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwICk7XG4gICAgXG4gICAgICAgICAgICAvLyBDaGVjayBib3gtc2l6aW5nIGFuZCBtYXJnaW4gYmVoYXZpb3JcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjFweDtib3JkZXI6MXB4O2Rpc3BsYXk6YmxvY2s7d2lkdGg6NHB4O21hcmdpbi10b3A6MSU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjElO1wiO1xuICAgICAgICAgICAgc3VwcG9ydC5ib3hTaXppbmcgPSAoIGRpdi5vZmZzZXRXaWR0aCA9PT0gNCApO1xuICAgICAgICAgICAgc3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCA9ICggYm9keS5vZmZzZXRUb3AgIT09IDEgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFVzZSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSBiZWNhdXNlIGpzZG9tIG9uIG5vZGUuanMgd2lsbCBicmVhayB3aXRob3V0IGl0LlxuICAgICAgICAgICAgaWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0LnBpeGVsUG9zaXRpb24gPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7fSApLnRvcCAhPT0gXCIxJVwiO1xuICAgICAgICAgICAgICAgIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUgPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7IHdpZHRoOiBcIjRweFwiIH0gKS53aWR0aCA9PT0gXCI0cHhcIjtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG4gICAgICAgICAgICAgICAgLy8gRmFpbHMgaW4gV2ViS2l0IGJlZm9yZSBGZWIgMjAxMSBuaWdodGxpZXNcbiAgICAgICAgICAgICAgICAvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcbiAgICAgICAgICAgICAgICBtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcbiAgICAgICAgICAgICAgICBtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2UmVzZXQ7XG4gICAgICAgICAgICAgICAgbWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcbiAgICBcbiAgICAgICAgICAgICAgICBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQgPVxuICAgICAgICAgICAgICAgICAgICAhcGFyc2VGbG9hdCggKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2LCBudWxsICkgfHwge30gKS5tYXJnaW5SaWdodCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IGNvcmVfc3RydW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyB3aGVuIHNldHRpbmcgdGhlaXIgZGlzcGxheSB0byAnaW5saW5lJyBhbmQgZ2l2aW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBsYXlvdXRcbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IGRpdlJlc2V0ICsgXCJ3aWR0aDoxcHg7cGFkZGluZzoxcHg7ZGlzcGxheTppbmxpbmU7em9vbToxXCI7XG4gICAgICAgICAgICAgICAgc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gKCBkaXYub2Zmc2V0V2lkdGggPT09IDMgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTZcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50cyB3aXRoIGxheW91dCBzaHJpbmstd3JhcCB0aGVpciBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxkaXY+PC9kaXY+XCI7XG4gICAgICAgICAgICAgICAgZGl2LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjVweFwiO1xuICAgICAgICAgICAgICAgIHN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcyA9ICggZGl2Lm9mZnNldFdpZHRoICE9PSAzICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBzdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgSUUgNiBmcm9tIGFmZmVjdGluZyBsYXlvdXQgZm9yIHBvc2l0aW9uZWQgZWxlbWVudHMgIzExMDQ4XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgSUUgZnJvbSBzaHJpbmtpbmcgdGhlIGJvZHkgaW4gSUUgNyBtb2RlICMxMjg2OVxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuc3R5bGUuem9vbSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG4gICAgXG4gICAgICAgICAgICAvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFXG4gICAgICAgICAgICBjb250YWluZXIgPSBkaXYgPSB0ZHMgPSBtYXJnaW5EaXYgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLy8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRVxuICAgICAgICBhbGwgPSBzZWxlY3QgPSBmcmFnbWVudCA9IG9wdCA9IGEgPSBpbnB1dCA9IG51bGw7XG4gICAgXG4gICAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgIH0pKCk7XG4gICAgXG4gICAgdmFyIHJicmFjZSA9IC8oPzpcXHtbXFxzXFxTXSpcXH18XFxbW1xcc1xcU10qXFxdKSQvLFxuICAgICAgICBybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcbiAgICBcbiAgICBmdW5jdGlvbiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEsIHB2dCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApe1xuICAgICAgICBpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHZhciB0aGlzQ2FjaGUsIHJldCxcbiAgICAgICAgICAgIGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG4gICAgICAgICAgICBnZXRCeU5hbWUgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIixcbiAgICBcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gaGFuZGxlIERPTSBub2RlcyBhbmQgSlMgb2JqZWN0cyBkaWZmZXJlbnRseSBiZWNhdXNlIElFNi03XG4gICAgICAgICAgICAvLyBjYW4ndCBHQyBvYmplY3QgcmVmZXJlbmNlcyBwcm9wZXJseSBhY3Jvc3MgdGhlIERPTS1KUyBib3VuZGFyeVxuICAgICAgICAgICAgaXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcbiAgICBcbiAgICAgICAgICAgIC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzXG4gICAgICAgICAgICAvLyBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgb2JqZWN0IHNvIEdDIGNhbiBvY2N1ciBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICBjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG4gICAgXG4gICAgICAgICAgICAvLyBPbmx5IGRlZmluaW5nIGFuIElEIGZvciBKUyBvYmplY3RzIGlmIGl0cyBjYWNoZSBhbHJlYWR5IGV4aXN0cyBhbGxvd3NcbiAgICAgICAgICAgIC8vIHRoZSBjb2RlIHRvIHNob3J0Y3V0IG9uIHRoZSBzYW1lIHBhdGggYXMgYSBET00gbm9kZSB3aXRoIG5vIGNhY2hlXG4gICAgICAgICAgICBpZCA9IGlzTm9kZSA/IGVsZW1bIGludGVybmFsS2V5IF0gOiBlbGVtWyBpbnRlcm5hbEtleSBdICYmIGludGVybmFsS2V5O1xuICAgIFxuICAgICAgICAvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxuICAgICAgICAvLyBvYmplY3QgdGhhdCBoYXMgbm8gZGF0YSBhdCBhbGxcbiAgICAgICAgaWYgKCAoIWlkIHx8ICFjYWNoZVtpZF0gfHwgKCFwdnQgJiYgIWNhY2hlW2lkXS5kYXRhKSkgJiYgZ2V0QnlOYW1lICYmIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoICFpZCApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgYSBuZXcgdW5pcXVlIElEIGZvciBlYWNoIGVsZW1lbnQgc2luY2UgdGhlaXIgZGF0YVxuICAgICAgICAgICAgLy8gZW5kcyB1cCBpbiB0aGUgZ2xvYmFsIGNhY2hlXG4gICAgICAgICAgICBpZiAoIGlzTm9kZSApIHtcbiAgICAgICAgICAgICAgICBlbGVtWyBpbnRlcm5hbEtleSBdID0gaWQgPSBjb3JlX2RlbGV0ZWRJZHMucG9wKCkgfHwgalF1ZXJ5Lmd1aWQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWQgPSBpbnRlcm5hbEtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoICFjYWNoZVsgaWQgXSApIHtcbiAgICAgICAgICAgIGNhY2hlWyBpZCBdID0ge307XG4gICAgXG4gICAgICAgICAgICAvLyBBdm9pZHMgZXhwb3NpbmcgalF1ZXJ5IG1ldGFkYXRhIG9uIHBsYWluIEpTIG9iamVjdHMgd2hlbiB0aGUgb2JqZWN0XG4gICAgICAgICAgICAvLyBpcyBzZXJpYWxpemVkIHVzaW5nIEpTT04uc3RyaW5naWZ5XG4gICAgICAgICAgICBpZiAoICFpc05vZGUgKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbIGlkIF0udG9KU09OID0galF1ZXJ5Lm5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQW4gb2JqZWN0IGNhbiBiZSBwYXNzZWQgdG8galF1ZXJ5LmRhdGEgaW5zdGVhZCBvZiBhIGtleS92YWx1ZSBwYWlyOyB0aGlzIGdldHNcbiAgICAgICAgLy8gc2hhbGxvdyBjb3BpZWQgb3ZlciBvbnRvIHRoZSBleGlzdGluZyBjYWNoZVxuICAgICAgICBpZiAoIHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICBpZiAoIHB2dCApIHtcbiAgICAgICAgICAgICAgICBjYWNoZVsgaWQgXSA9IGpRdWVyeS5leHRlbmQoIGNhY2hlWyBpZCBdLCBuYW1lICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhY2hlWyBpZCBdLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXS5kYXRhLCBuYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgdGhpc0NhY2hlID0gY2FjaGVbIGlkIF07XG4gICAgXG4gICAgICAgIC8vIGpRdWVyeSBkYXRhKCkgaXMgc3RvcmVkIGluIGEgc2VwYXJhdGUgb2JqZWN0IGluc2lkZSB0aGUgb2JqZWN0J3MgaW50ZXJuYWwgZGF0YVxuICAgICAgICAvLyBjYWNoZSBpbiBvcmRlciB0byBhdm9pZCBrZXkgY29sbGlzaW9ucyBiZXR3ZWVuIGludGVybmFsIGRhdGEgYW5kIHVzZXItZGVmaW5lZFxuICAgICAgICAvLyBkYXRhLlxuICAgICAgICBpZiAoICFwdnQgKSB7XG4gICAgICAgICAgICBpZiAoICF0aGlzQ2FjaGUuZGF0YSApIHtcbiAgICAgICAgICAgICAgICB0aGlzQ2FjaGUuZGF0YSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdGhpc0NhY2hlID0gdGhpc0NhY2hlLmRhdGE7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB0aGlzQ2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSBdID0gZGF0YTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBDaGVjayBmb3IgYm90aCBjb252ZXJ0ZWQtdG8tY2FtZWwgYW5kIG5vbi1jb252ZXJ0ZWQgZGF0YSBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICAvLyBJZiBhIGRhdGEgcHJvcGVydHkgd2FzIHNwZWNpZmllZFxuICAgICAgICBpZiAoIGdldEJ5TmFtZSApIHtcbiAgICBcbiAgICAgICAgICAgIC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcbiAgICAgICAgICAgIHJldCA9IHRoaXNDYWNoZVsgbmFtZSBdO1xuICAgIFxuICAgICAgICAgICAgLy8gVGVzdCBmb3IgbnVsbHx1bmRlZmluZWQgcHJvcGVydHkgZGF0YVxuICAgICAgICAgICAgaWYgKCByZXQgPT0gbnVsbCApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCB0aGUgY2FtZWxDYXNlZCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzQ2FjaGU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCBwdnQgKSB7XG4gICAgICAgIGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgdmFyIGksIGwsIHRoaXNDYWNoZSxcbiAgICAgICAgICAgIGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG4gICAgXG4gICAgICAgICAgICAvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcbiAgICAgICAgICAgIGlkID0gaXNOb2RlID8gZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXSA6IGpRdWVyeS5leHBhbmRvO1xuICAgIFxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IG5vIGNhY2hlIGVudHJ5IGZvciB0aGlzIG9iamVjdCwgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gcHVycG9zZSBpbiBjb250aW51aW5nXG4gICAgICAgIGlmICggIWNhY2hlWyBpZCBdICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmICggbmFtZSApIHtcbiAgICBcbiAgICAgICAgICAgIHRoaXNDYWNoZSA9IHB2dCA/IGNhY2hlWyBpZCBdIDogY2FjaGVbIGlkIF0uZGF0YTtcbiAgICBcbiAgICAgICAgICAgIGlmICggdGhpc0NhY2hlICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBuYW1lcyBmb3IgZGF0YSBrZXlzXG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBbIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBjYW1lbCBjYXNlZCB2ZXJzaW9uIGJ5IHNwYWNlcyB1bmxlc3MgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5jb25jYXQoIGpRdWVyeS5tYXAoIG5hbWUsIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpc0NhY2hlWyBuYW1lW2ldIF07XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgbGVmdCBpbiB0aGUgY2FjaGUsIHdlIHdhbnQgdG8gY29udGludWVcbiAgICAgICAgICAgICAgICAvLyBhbmQgbGV0IHRoZSBjYWNoZSBvYmplY3QgaXRzZWxmIGdldCBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICBpZiAoICEoIHB2dCA/IGlzRW1wdHlEYXRhT2JqZWN0IDogalF1ZXJ5LmlzRW1wdHlPYmplY3QgKSggdGhpc0NhY2hlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICAgIGlmICggIXB2dCApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsgaWQgXS5kYXRhO1xuICAgIFxuICAgICAgICAgICAgLy8gRG9uJ3QgZGVzdHJveSB0aGUgcGFyZW50IGNhY2hlIHVubGVzcyB0aGUgaW50ZXJuYWwgZGF0YSBvYmplY3RcbiAgICAgICAgICAgIC8vIGhhZCBiZWVuIHRoZSBvbmx5IHRoaW5nIGxlZnQgaW4gaXRcbiAgICAgICAgICAgIGlmICggIWlzRW1wdHlEYXRhT2JqZWN0KCBjYWNoZVsgaWQgXSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBEZXN0cm95IHRoZSBjYWNoZVxuICAgICAgICBpZiAoIGlzTm9kZSApIHtcbiAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIFsgZWxlbSBdLCB0cnVlICk7XG4gICAgXG4gICAgICAgIC8vIFVzZSBkZWxldGUgd2hlbiBzdXBwb3J0ZWQgZm9yIGV4cGFuZG9zIG9yIGBjYWNoZWAgaXMgbm90IGEgd2luZG93IHBlciBpc1dpbmRvdyAoIzEwMDgwKVxuICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuc3VwcG9ydC5kZWxldGVFeHBhbmRvIHx8IGNhY2hlICE9IGNhY2hlLndpbmRvdyApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsgaWQgXTtcbiAgICBcbiAgICAgICAgLy8gV2hlbiBhbGwgZWxzZSBmYWlscywgbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVbIGlkIF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBjYWNoZToge30sXG4gICAgXG4gICAgICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuICAgICAgICAvLyBOb24tZGlnaXRzIHJlbW92ZWQgdG8gbWF0Y2ggcmlubGluZWpRdWVyeVxuICAgICAgICBleHBhbmRvOiBcImpRdWVyeVwiICsgKCBjb3JlX3ZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG4gICAgXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZWxlbWVudHMgdGhyb3cgdW5jYXRjaGFibGUgZXhjZXB0aW9ucyBpZiB5b3VcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBhZGQgZXhwYW5kbyBwcm9wZXJ0aWVzIHRvIHRoZW0uXG4gICAgICAgIG5vRGF0YToge1xuICAgICAgICAgICAgXCJlbWJlZFwiOiB0cnVlLFxuICAgICAgICAgICAgLy8gQmFuIGFsbCBvYmplY3RzIGV4Y2VwdCBmb3IgRmxhc2ggKHdoaWNoIGhhbmRsZSBleHBhbmRvcylcbiAgICAgICAgICAgIFwib2JqZWN0XCI6IFwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCIsXG4gICAgICAgICAgICBcImFwcGxldFwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0ubm9kZVR5cGUgPyBqUXVlcnkuY2FjaGVbIGVsZW1balF1ZXJ5LmV4cGFuZG9dIF0gOiBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xuICAgICAgICAgICAgcmV0dXJuICEhZWxlbSAmJiAhaXNFbXB0eURhdGFPYmplY3QoIGVsZW0gKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsUmVtb3ZlRGF0YSggZWxlbSwgbmFtZSApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICAgIF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEsIHRydWUgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgX3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsUmVtb3ZlRGF0YSggZWxlbSwgbmFtZSwgdHJ1ZSApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBBIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBET00gbm9kZSBjYW4gaGFuZGxlIHRoZSBkYXRhIGV4cGFuZG9cbiAgICAgICAgYWNjZXB0RGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAvLyBEbyBub3Qgc2V0IGRhdGEgb24gbm9uLWVsZW1lbnQgYmVjYXVzZSBpdCB3aWxsIG5vdCBiZSBjbGVhcmVkICgjODMzNSkuXG4gICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgJiYgZWxlbS5ub2RlVHlwZSAhPT0gMSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHZhciBub0RhdGEgPSBlbGVtLm5vZGVOYW1lICYmIGpRdWVyeS5ub0RhdGFbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuICAgIFxuICAgICAgICAgICAgLy8gbm9kZXMgYWNjZXB0IGRhdGEgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQ7IHJlamVjdGlvbiBjYW4gYmUgY29uZGl0aW9uYWxcbiAgICAgICAgICAgIHJldHVybiAhbm9EYXRhIHx8IG5vRGF0YSAhPT0gdHJ1ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIikgPT09IG5vRGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBhdHRycywgbmFtZSxcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1swXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICBcbiAgICAgICAgICAgIC8vIEdldHMgYWxsIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5LmRhdGEoIGVsZW0gKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBlbGVtLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSg1KSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9kYXRhKCBlbGVtLCBcInBhcnNlZEF0dHJzXCIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEoIHRoaXMsIGtleSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmZXRjaCBhbnkgaW50ZXJuYWxseSBzdG9yZWQgZGF0YSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA/IGRhdGFBdHRyKCBlbGVtLCBrZXksIGpRdWVyeS5kYXRhKCBlbGVtLCBrZXkgKSApIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSggdGhpcywga2V5LCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKCB0aGlzLCBrZXkgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcbiAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuICAgICAgICAvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICBcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuICAgIFxuICAgICAgICAgICAgZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG4gICAgXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICArZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG4gICAgICAgICAgICAgICAgICAgICAgICByYnJhY2UudGVzdCggZGF0YSApID8galF1ZXJ5LnBhcnNlSlNPTiggZGF0YSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7fVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKCBlbGVtLCBrZXksIGRhdGEgKTtcbiAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgXG4gICAgLy8gY2hlY2tzIGEgY2FjaGUgb2JqZWN0IGZvciBlbXB0aW5lc3NcbiAgICBmdW5jdGlvbiBpc0VtcHR5RGF0YU9iamVjdCggb2JqICkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZm9yICggbmFtZSBpbiBvYmogKSB7XG4gICAgXG4gICAgICAgICAgICAvLyBpZiB0aGUgcHVibGljIGRhdGEgb2JqZWN0IGlzIGVtcHR5LCB0aGUgcHJpdmF0ZSBpcyBzdGlsbCBlbXB0eVxuICAgICAgICAgICAgaWYgKCBuYW1lID09PSBcImRhdGFcIiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb2JqW25hbWVdICkgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIG5hbWUgIT09IFwidG9KU09OXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG4gICAgICAgICAgICAgICAgcXVldWUgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheShkYXRhKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKCBkYXRhICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlIHx8IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcbiAgICBcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuICAgICAgICAgICAgICAgIHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKSxcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuICAgICAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuICAgICAgICAgICAgaWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0TGVuZ3RoLS07XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBob29rcy5jdXIgPSBmbjtcbiAgICAgICAgICAgIGlmICggZm4gKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcbiAgICAgICAgICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIG5vdCBpbnRlbmRlZCBmb3IgcHVibGljIGNvbnN1bXB0aW9uIC0gZ2VuZXJhdGVzIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybnMgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXkgKSB8fCBqUXVlcnkuX2RhdGEoIGVsZW0sIGtleSwge1xuICAgICAgICAgICAgICAgIGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIHR5cGUgKyBcInF1ZXVlXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCBrZXkgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIHNldHRlciA9IDI7XG4gICAgXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImZ4XCI7XG4gICAgICAgICAgICAgICAgc2V0dGVyLS07XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuICAgICAgICAvLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG4gICAgICAgIGRlbGF5OiBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcbiAgICAgICAgICAgIHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuICAgICAgICAgICAgICAgIGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuICAgICAgICAvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcbiAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcbiAgICAgICAgICAgIHZhciB0bXAsXG4gICAgICAgICAgICAgICAgY291bnQgPSAxLFxuICAgICAgICAgICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggISggLS1jb3VudCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcbiAgICBcbiAgICAgICAgICAgIHdoaWxlKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgdG1wID0galF1ZXJ5Ll9kYXRhKCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxuICAgICAgICByY2xhc3MgPSAvW1xcdFxcclxcbl0vZyxcbiAgICAgICAgcnJldHVybiA9IC9cXHIvZyxcbiAgICAgICAgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pLFxuICAgICAgICByY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pLFxuICAgICAgICByYm9vbGVhbiA9IC9eKD86Y2hlY2tlZHxzZWxlY3RlZHxhdXRvZm9jdXN8YXV0b3BsYXl8YXN5bmN8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWQpJC9pLFxuICAgICAgICBydXNlRGVmYXVsdCA9IC9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksXG4gICAgICAgIGdldFNldEF0dHJpYnV0ZSA9IGpRdWVyeS5zdXBwb3J0LmdldFNldEF0dHJpYnV0ZSxcbiAgICAgICAgZ2V0U2V0SW5wdXQgPSBqUXVlcnkuc3VwcG9ydC5pbnB1dDtcbiAgICBcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkvY2F0Y2ggaGFuZGxlcyBjYXNlcyB3aGVyZSBJRSBiYWxrcyAoc3VjaCBhcyByZW1vdmluZyBhIHByb3BlcnR5IG9uIHdpbmRvdylcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWyBuYW1lIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzWyBuYW1lIF07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCggZSApIHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWU7XG4gICAgXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIHByb2NlZWQgKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIGNvcmVfcm5vdHdoaXRlICkgfHwgW107XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyICs9IGNsYXp6ICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHByb2NlZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZTtcbiAgICBcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggcHJvY2VlZCApIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIGNvcmVfcm5vdHdoaXRlICkgfHwgW107XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID49IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSB2YWx1ZSA/IGpRdWVyeS50cmltKCBjdXIgKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpc0Jvb2wgPSB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIGNvcmVfcm5vdHdoaXRlICkgfHwgW107XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBpc0Jvb2wgPyBzdGF0ZSA6ICFzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZbIHN0YXRlID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiIF0oIGNsYXNzTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09PSBjb3JlX3N0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHRoaXNbaV0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPj0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICB2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciByZXQsIGhvb2tzLCBpc0Z1bmN0aW9uLFxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdO1xuICAgIFxuICAgICAgICAgICAgaWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGVsZW0udmFsdWU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgc2VsZi52YWwoKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcbiAgICAgICAgICAgICAgICBpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIHZhbEhvb2tzOiB7XG4gICAgICAgICAgICBvcHRpb246IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzLnZhbHVlIGlzIHVuZGVmaW5lZCBpbiBCbGFja2JlcnJ5IDQuNyBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlcyAudmFsdWUuIFNlZSAjNjkzMlxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZWxlbS5hdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXZhbCB8fCB2YWwuc3BlY2lmaWVkID8gZWxlbS52YWx1ZSA6IGVsZW0udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4IDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUgPyBpbmRleCA6IDA7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zWyBpIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbGRJRSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggalF1ZXJ5LnN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09PSBudWxsICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KGVsZW0pLmZpbmQoXCJvcHRpb25cIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KHRoaXMpLnZhbCgpLCB2YWx1ZXMgKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhdmFsdWVzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICBhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgaG9va3MsIG5vdHhtbCwgcmV0LFxuICAgICAgICAgICAgICAgIG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcbiAgICBcbiAgICAgICAgICAgIC8vIGRvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgICAgIGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBjb3JlX3N0cnVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG4gICAgXG4gICAgICAgICAgICAvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG4gICAgICAgICAgICAvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoIG5vdHhtbCApIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8ICggcmJvb2xlYW4udGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG4gICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggaG9va3MgJiYgbm90eG1sICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBob29rcyAmJiBub3R4bWwgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIEluIElFOSssIEZsYXNoIG9iamVjdHMgZG9uJ3QgaGF2ZSAuZ2V0QXR0cmlidXRlICgjMTI5NDUpXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5K1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBjb3JlX3N0cnVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICAgICAgcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSwgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgYXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIGNvcmVfcm5vdHdoaXRlICk7XG4gICAgXG4gICAgICAgICAgICBpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgIHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50ICgjMTA4NzApXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmJvb2xlYW4udGVzdCggbmFtZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbyBjbGVhciBkZWZhdWx0Q2hlY2tlZC9kZWZhdWx0U2VsZWN0ZWQgKGlmIGFwcHJvcHJpYXRlKSBmb3IgSUU8OFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZ2V0U2V0QXR0cmlidXRlICYmIHJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBqUXVlcnkuY2FtZWxDYXNlKCBcImRlZmF1bHQtXCIgKyBuYW1lICkgXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgIzk2OTkgZm9yIGV4cGxhbmF0aW9uIG9mIHRoaXMgYXBwcm9hY2ggKHNldHRpbmcgZmlyc3QsIHRoZW4gcmVtb3ZhbClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdHRyKCBlbGVtLCBuYW1lLCBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGdldFNldEF0dHJpYnV0ZSA/IG5hbWUgOiBwcm9wTmFtZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgYXR0ckhvb2tzOiB7XG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJpbnB1dFwiKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIHR5cGUgb24gYSByYWRpbyBidXR0b24gYWZ0ZXIgdGhlIHZhbHVlIHJlc2V0cyB0aGUgdmFsdWUgaW4gSUU2LTlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHZhbHVlIHRvIGRlZmF1bHQgaW4gY2FzZSB0eXBlIGlzIHNldCBhZnRlciB2YWx1ZSBkdXJpbmcgY3JlYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcHJvcEZpeDoge1xuICAgICAgICAgICAgdGFiaW5kZXg6IFwidGFiSW5kZXhcIixcbiAgICAgICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIixcbiAgICAgICAgICAgIG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcbiAgICAgICAgICAgIGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXG4gICAgICAgICAgICBjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICAgICAgcm93c3BhbjogXCJyb3dTcGFuXCIsXG4gICAgICAgICAgICBjb2xzcGFuOiBcImNvbFNwYW5cIixcbiAgICAgICAgICAgIHVzZW1hcDogXCJ1c2VNYXBcIixcbiAgICAgICAgICAgIGZyYW1lYm9yZGVyOiBcImZyYW1lQm9yZGVyXCIsXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCJcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIHJldCwgaG9va3MsIG5vdHhtbCxcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG4gICAgXG4gICAgICAgICAgICAvLyBkb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG4gICAgICAgICAgICBpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcbiAgICBcbiAgICAgICAgICAgIGlmICggbm90eG1sICkge1xuICAgICAgICAgICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcbiAgICAgICAgICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbVsgbmFtZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcHJvcEhvb2tzOiB7XG4gICAgICAgICAgICB0YWJJbmRleDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJ0YWJpbmRleFwiKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5vZGUgJiYgYXR0cmlidXRlTm9kZS5zcGVjaWZpZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoIGF0dHJpYnV0ZU5vZGUudmFsdWUsIDEwICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSG9vayBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgYm9vbEhvb2sgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAvLyBVc2UgLnByb3AgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgYXR0cmlidXRlIGlzIHVuZGVyc3Rvb2QgYXMgYm9vbGVhblxuICAgICAgICAgICAgICAgIHByb3AgPSBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSApLFxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGl0IGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgYXR0ciA9IHR5cGVvZiBwcm9wID09PSBcImJvb2xlYW5cIiAmJiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApLFxuICAgICAgICAgICAgICAgIGRldGFpbCA9IHR5cGVvZiBwcm9wID09PSBcImJvb2xlYW5cIiA/XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyICE9IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2xkSUUgZmFicmljYXRlcyBhbiBlbXB0eSBzdHJpbmcgZm9yIG1pc3NpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY29uZmxhdGVzIGNoZWNrZWQvc2VsZWN0ZWQgaW50byBhdHRyb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEhYXR0ciA6XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGZldGNoIGFuIGF0dHJpYnV0ZSBub2RlIGZvciBwcm9wZXJ0aWVzIG5vdCByZWNvZ25pemVkIGFzIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsICYmIGRldGFpbC52YWx1ZSAhPT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcbiAgICAgICAgICAgIGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggZ2V0U2V0SW5wdXQgJiYgZ2V0U2V0QXR0cmlidXRlIHx8ICFydXNlRGVmYXVsdC50ZXN0KCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgLy8gSUU8OCBuZWVkcyB0aGUgKnByb3BlcnR5KiBuYW1lXG4gICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoICFnZXRTZXRBdHRyaWJ1dGUgJiYgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lLCBuYW1lICk7XG4gICAgXG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdENoZWNrZWQgYW5kIGRlZmF1bHRTZWxlY3RlZCBmb3Igb2xkSUVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPSBlbGVtWyBuYW1lIF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIGZpeCBvbGRJRSB2YWx1ZSBhdHRyb3BlcnR5XG4gICAgaWYgKCAhZ2V0U2V0SW5wdXQgfHwgIWdldFNldEF0dHJpYnV0ZSApIHtcbiAgICAgICAgalF1ZXJ5LmF0dHJIb29rcy52YWx1ZSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApID9cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZSB2YWx1ZSAqcHJvcGVydHkqIGJ5IHVzaW5nIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICBlbGVtLmRlZmF1bHRWYWx1ZSA6XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldCAmJiByZXQuc3BlY2lmaWVkID8gcmV0LnZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9lcyBub3QgcmV0dXJuIHNvIHRoYXQgc2V0QXR0cmlidXRlIGlzIGFsc28gdXNlZFxuICAgICAgICAgICAgICAgICAgICBlbGVtLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBub2RlSG9vayBpZiBkZWZpbmVkICgjMTk1NCk7IG90aGVyd2lzZSBzZXRBdHRyaWJ1dGUgaXMgZmluZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUhvb2sgJiYgbm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gSUU2LzcgZG8gbm90IHN1cHBvcnQgZ2V0dGluZy9zZXR0aW5nIHNvbWUgYXR0cmlidXRlcyB3aXRoIGdldC9zZXRBdHRyaWJ1dGVcbiAgICBpZiAoICFnZXRTZXRBdHRyaWJ1dGUgKSB7XG4gICAgXG4gICAgICAgIC8vIFVzZSB0aGlzIGZvciBhbnkgYXR0cmlidXRlIGluIElFNi83XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgYWxtb3N0IGV2ZXJ5IElFNi83IGlzc3VlXG4gICAgICAgIG5vZGVIb29rID0galF1ZXJ5LnZhbEhvb2tzLmJ1dHRvbiA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQgJiYgKCBuYW1lID09PSBcImlkXCIgfHwgbmFtZSA9PT0gXCJuYW1lXCIgfHwgbmFtZSA9PT0gXCJjb29yZHNcIiA/IHJldC52YWx1ZSAhPT0gXCJcIiA6IHJldC5zcGVjaWZpZWQgKSA/XG4gICAgICAgICAgICAgICAgICAgIHJldC52YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGV4aXN0aW5nIG9yIGNyZWF0ZSBhIG5ldyBhdHRyaWJ1dGUgbm9kZVxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcbiAgICAgICAgICAgICAgICBpZiAoICFyZXQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXQgPSBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKCBuYW1lICkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldC52YWx1ZSA9IHZhbHVlICs9IFwiXCI7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgYXNzb2NpYXRpb24gd2l0aCBjbG9uZWQgZWxlbWVudHMgYnkgYWxzbyB1c2luZyBzZXRBdHRyaWJ1dGUgKCM5NjQ2KVxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcInZhbHVlXCIgfHwgdmFsdWUgPT09IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgP1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gU2V0IGNvbnRlbnRlZGl0YWJsZSB0byBmYWxzZSBvbiByZW1vdmFscygjMTA0MjkpXG4gICAgICAgIC8vIFNldHRpbmcgdG8gZW1wdHkgc3RyaW5nIHRocm93cyBhbiBlcnJvciBhcyBhbiBpbnZhbGlkIHZhbHVlXG4gICAgICAgIGpRdWVyeS5hdHRySG9va3MuY29udGVudGVkaXRhYmxlID0ge1xuICAgICAgICAgICAgZ2V0OiBub2RlSG9vay5nZXQsXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcbiAgICAgICAgICAgICAgICBub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlID09PSBcIlwiID8gZmFsc2UgOiB2YWx1ZSwgbmFtZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyBTZXQgd2lkdGggYW5kIGhlaWdodCB0byBhdXRvIGluc3RlYWQgb2YgMCBvbiBlbXB0eSBzdHJpbmcoIEJ1ZyAjODE1MCApXG4gICAgICAgIC8vIFRoaXMgaXMgZm9yIHJlbW92YWxzXG4gICAgICAgIGpRdWVyeS5lYWNoKFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgICAgICAgICAgalF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgXCJhdXRvXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy8gU29tZSBhdHRyaWJ1dGVzIHJlcXVpcmUgYSBzcGVjaWFsIGNhbGwgb24gSUVcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgKSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKFsgXCJocmVmXCIsIFwic3JjXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICAgICAgICAgIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgMiApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvLyBocmVmL3NyYyBwcm9wZXJ0eSBzaG91bGQgZ2V0IHRoZSBmdWxsIG5vcm1hbGl6ZWQgVVJMICgjMTAyOTkvIzEyOTE1KVxuICAgICAgICBqUXVlcnkuZWFjaChbIFwiaHJlZlwiLCBcInNyY1wiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgICAgICAgICAgalF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdID0ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgNCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5zdHlsZSApIHtcbiAgICAgICAgalF1ZXJ5LmF0dHJIb29rcy5zdHlsZSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpbiB0aGUgY2FzZSBvZiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBJRSB1cHBlcmNhc2VzIGNzcyBwcm9wZXJ0eSBuYW1lcywgYnV0IGlmIHdlIHdlcmUgdG8gLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAvLyAuY3NzVGV4dCwgdGhhdCB3b3VsZCBkZXN0cm95IGNhc2Ugc2Vuc3RpdGl2aXR5IGluIFVSTCdzLCBsaWtlIGluIFwiYmFja2dyb3VuZFwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc3R5bGUuY3NzVGV4dCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbS5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgKyBcIlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFNhZmFyaSBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhbiBvcHRpb25cbiAgICAvLyBBY2Nlc3NpbmcgdGhlIHBhcmVudCdzIHNlbGVjdGVkSW5kZXggcHJvcGVydHkgZml4ZXMgaXRcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcbiAgICAgICAgalF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIHBhcmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnNlbGVjdGVkSW5kZXg7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGl0IGFsc28gd29ya3Mgd2l0aCBvcHRncm91cHMsIHNlZSAjNTcwMVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElFNi83IGNhbGwgZW5jdHlwZSBlbmNvZGluZ1xuICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmVuY3R5cGUgKSB7XG4gICAgICAgIGpRdWVyeS5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCI7XG4gICAgfVxuICAgIFxuICAgIC8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hlY2tPbiApIHtcbiAgICAgICAgalF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBpbiBXZWJraXQgXCJcIiBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIHZhbHVlIGlzbid0IHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0sIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHJmb3JtRWxlbXMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2ksXG4gICAgICAgIHJrZXlFdmVudCA9IC9ea2V5LyxcbiAgICAgICAgcm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sXG4gICAgICAgIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuICAgICAgICBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KSQvO1xuICAgIFxuICAgIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAgICAgKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICAgICAqL1xuICAgIGpRdWVyeS5ldmVudCA9IHtcbiAgICBcbiAgICAgICAgZ2xvYmFsOiB7fSxcbiAgICBcbiAgICAgICAgYWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIHRtcCwgZXZlbnRzLCB0LCBoYW5kbGVPYmpJbixcbiAgICAgICAgICAgICAgICBzcGVjaWFsLCBldmVudEhhbmRsZSwgaGFuZGxlT2JqLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGpRdWVyeS5fZGF0YSggZWxlbSApO1xuICAgIFxuICAgICAgICAgICAgLy8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcbiAgICAgICAgICAgIGlmICggIWVsZW1EYXRhICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgICAgICAgICAgaWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcbiAgICAgICAgICAgIGlmICggIWhhbmRsZXIuZ3VpZCApIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAgICAgaWYgKCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoICEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpICkge1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IGNvcmVfc3RydW5kZWZpbmVkICYmICghZSB8fCBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZXZlbnRIYW5kbGUuZWxlbSwgYXJndW1lbnRzICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gQWRkIGVsZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlIGZuIHRvIHByZXZlbnQgYSBtZW1vcnkgbGVhayB3aXRoIElFIG5vbi1uYXRpdmUgZXZlbnRzXG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGUuZWxlbSA9IGVsZW07XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG4gICAgICAgICAgICAvLyBqUXVlcnkoLi4uKS5iaW5kKFwibW91c2VvdmVyIG1vdXNlb3V0XCIsIGZuKTtcbiAgICAgICAgICAgIHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIGNvcmVfcm5vdHdoaXRlICkgfHwgW1wiXCJdO1xuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggdC0tICkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG4gICAgICAgICAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuICAgICAgICAgICAgICAgIHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlT2JqSW4gKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgIGlmICggIShoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lci9hdHRhY2hFdmVudCBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpbmQgdGhlIGdsb2JhbCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZWxlbS5hdHRhY2hFdmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBldmVudEhhbmRsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbC5hZGQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBOdWxsaWZ5IGVsZW0gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcbiAgICAgICAgICAgIGVsZW0gPSBudWxsO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcbiAgICAgICAgICAgIHZhciBqLCBoYW5kbGVPYmosIHRtcCxcbiAgICAgICAgICAgICAgICBvcmlnQ291bnQsIHQsIGV2ZW50cyxcbiAgICAgICAgICAgICAgICBzcGVjaWFsLCBoYW5kbGVycywgdHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG4gICAgXG4gICAgICAgICAgICBpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuICAgICAgICAgICAgdHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggY29yZV9ybm90d2hpdGUgKSB8fCBbXCJcIl07XG4gICAgICAgICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCB0LS0gKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKCAhdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiBldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG4gICAgICAgICAgICAgICAgdHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG4gICAgICAgICAgICAgICAgdG1wID0gdG1wWzJdICYmIG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgb3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG4gICAgICAgICAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgaWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZURhdGEgYWxzbyBjaGVja3MgZm9yIGVtcHRpbmVzcyBhbmQgY2xlYXJzIHRoZSBleHBhbmRvIGlmIGVtcHR5XG4gICAgICAgICAgICAgICAgLy8gc28gdXNlIGl0IGluc3RlYWQgb2YgZGVsZXRlXG4gICAgICAgICAgICAgICAgalF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCBcImV2ZW50c1wiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSwgb250eXBlLCBjdXIsXG4gICAgICAgICAgICAgICAgYnViYmxlVHlwZSwgc3BlY2lhbCwgdG1wLCBpLFxuICAgICAgICAgICAgICAgIGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBjb3JlX2hhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gY29yZV9oYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcbiAgICBcbiAgICAgICAgICAgIGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuICAgIFxuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuICAgICAgICAgICAgaWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICggdHlwZS5pbmRleE9mKFwiLlwiKSA+PSAwICkge1xuICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgdHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLnNvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG4gICAgXG4gICAgICAgICAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuICAgICAgICAgICAgICAgIGV2ZW50IDpcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcbiAgICBcbiAgICAgICAgICAgIGV2ZW50LmlzVHJpZ2dlciA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcbiAgICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICggIWV2ZW50LnRhcmdldCApIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBlbGVtO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuICAgICAgICAgICAgZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgWyBldmVudCBdIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcbiAgICBcbiAgICAgICAgICAgIC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcbiAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG4gICAgICAgICAgICAvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuICAgICAgICAgICAgaWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICBidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IGN1cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG4gICAgICAgICAgICAgICAgaWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoIChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGkgPiAxID9cbiAgICAgICAgICAgICAgICAgICAgYnViYmxlVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgaGFuZGxlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9ICggalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiaGFuZGxlXCIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gTmF0aXZlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcbiAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgJiYgaGFuZGxlLmFwcGx5ICYmIGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgIFxuICAgICAgICAgICAgLy8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuICAgICAgICAgICAgaWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBlbGVtLm93bmVyRG9jdW1lbnQsIGRhdGEgKSA9PT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICEodHlwZSA9PT0gXCJjbGlja1wiICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJhXCIgKSkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCB1c2UgYW4gLmlzRnVuY3Rpb24oKSBjaGVjayBoZXJlIGJlY2F1c2UgSUU2LzcgZmFpbHMgdGhhdCB0ZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG4gICAgICAgICAgICAgICAgICAgIGlmICggb250eXBlICYmIGVsZW1bIHR5cGUgXSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBlbGVtWyBvbnR5cGUgXTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG9udHlwZSBdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgdHlwZSBdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTw5IGRpZXMgb24gZm9jdXMvYmx1ciB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYsIzEyNTE4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcmVwcm9kdWNpYmxlIG9uIHdpblhQIElFOCBuYXRpdmUsIG5vdCBJRTkgaW4gSUU4IG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRtcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBvbnR5cGUgXSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgXG4gICAgICAgICAgICAvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcbiAgICAgICAgICAgIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcbiAgICBcbiAgICAgICAgICAgIHZhciBpLCByZXQsIGhhbmRsZU9iaiwgbWF0Y2hlZCwgaixcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcbiAgICAgICAgICAgICAgICBhcmdzID0gY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9ICggalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuICAgIFxuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBldmVudDtcbiAgICAgICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcbiAgICBcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcbiAgICAgICAgICAgIGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIERldGVybWluZSBoYW5kbGVyc1xuICAgICAgICAgICAgaGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuICAgIFxuICAgICAgICAgICAgLy8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG4gICAgXG4gICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0pICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIDIpIGhhdmUgbmFtZXNwYWNlKHMpIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuICAgICAgICAgICAgICAgICAgICBpZiAoICFldmVudC5uYW1lc3BhY2VfcmUgfHwgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9ICggKGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSkuaGFuZGxlIHx8IGhhbmRsZU9iai5oYW5kbGVyIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcbiAgICAgICAgICAgIGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuICAgICAgICAgICAgdmFyIHNlbCwgaGFuZGxlT2JqLCBtYXRjaGVzLCBpLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuICAgICAgICAgICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDtcbiAgICBcbiAgICAgICAgICAgIC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcbiAgICAgICAgICAgIC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG4gICAgICAgICAgICAvLyBBdm9pZCBub24tbGVmdC1jbGljayBidWJibGluZyBpbiBGaXJlZm94ICgjMzg2MSlcbiAgICAgICAgICAgIGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiYgKCFldmVudC5idXR0b24gfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGN1ciAhPSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmIChjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+PSAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG4gICAgICAgICAgICBpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyUXVldWU7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgaWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHZhciBpLCBwcm9wLCBjb3B5LFxuICAgICAgICAgICAgICAgIHR5cGUgPSBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQgPSBldmVudCxcbiAgICAgICAgICAgICAgICBmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuICAgIFxuICAgICAgICAgICAgaWYgKCAhZml4SG9vayApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cbiAgICAgICAgICAgICAgICAgICAgcm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcbiAgICAgICAgICAgICAgICAgICAgcmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG4gICAgXG4gICAgICAgICAgICBldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcbiAgICBcbiAgICAgICAgICAgIGkgPSBjb3B5Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb3B5WyBpIF07XG4gICAgICAgICAgICAgICAgZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAgIC8vIEZpeCB0YXJnZXQgcHJvcGVydHkgKCMxOTI1KVxuICAgICAgICAgICAgaWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSAyMyssIFNhZmFyaT9cbiAgICAgICAgICAgIC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG4gICAgICAgICAgICBpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAgIC8vIEZvciBtb3VzZS9rZXkgZXZlbnRzLCBtZXRhS2V5PT1mYWxzZSBpZiBpdCdzIHVuZGVmaW5lZCAoIzMzNjgsICMxMTMyOClcbiAgICAgICAgICAgIGV2ZW50Lm1ldGFLZXkgPSAhIWV2ZW50Lm1ldGFLZXk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuICAgICAgICBwcm9wczogXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksXG4gICAgXG4gICAgICAgIGZpeEhvb2tzOiB7fSxcbiAgICBcbiAgICAgICAga2V5SG9va3M6IHtcbiAgICAgICAgICAgIHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgbW91c2VIb29rczoge1xuICAgICAgICAgICAgcHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuICAgICAgICAgICAgICAgIHZhciBib2R5LCBldmVudERvYywgZG9jLFxuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSBvcmlnaW5hbC5idXR0b24sXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbGVtZW50ID0gb3JpZ2luYWwuZnJvbUVsZW1lbnQ7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGV2ZW50RG9jLmJvZHk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArICggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICsgKCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgcmVsYXRlZFRhcmdldCwgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBmcm9tRWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBvcmlnaW5hbC50b0VsZW1lbnQgOiBmcm9tRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG4gICAgICAgICAgICAgICAgaWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICBzcGVjaWFsOiB7XG4gICAgICAgICAgICBsb2FkOiB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuICAgICAgICAgICAgICAgIG5vQnViYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgJiYgdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICAgIC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgdGhpcy5mb2N1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBlcnJvciBvbiBmb2N1cyB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYsICMxMjUxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IC50cmlnZ2VyKCkgcnVuIHRoZSBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmx1cjoge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgdGhpcy5ibHVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgYmVmb3JldW5sb2FkOiB7XG4gICAgICAgICAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gd2hlbiByZXR1cm5WYWx1ZSBlcXVhbHMgdG8gdW5kZWZpbmVkIEZpcmVmb3ggd2lsbCBzdGlsbCBzaG93IGFsZXJ0XG4gICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICBzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XG4gICAgICAgICAgICAvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG4gICAgICAgICAgICAvLyBGYWtlIG9yaWdpbmFsRXZlbnQgdG8gYXZvaWQgZG9ub3IncyBzdG9wUHJvcGFnYXRpb24sIGJ1dCBpZiB0aGVcbiAgICAgICAgICAgIC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxuICAgICAgICAgICAgdmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQoKSxcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2ltdWxhdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIGJ1YmJsZSApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGpRdWVyeS5yZW1vdmVFdmVudCA9IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgP1xuICAgICAgICBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuICAgICAgICAgICAgaWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIm9uXCIgKyB0eXBlO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBlbGVtLmRldGFjaEV2ZW50ICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vICM4NTQ1LCAjNzA1NCwgcHJldmVudGluZyBtZW1vcnkgbGVha3MgZm9yIGN1c3RvbSBldmVudHMgaW4gSUU2LThcbiAgICAgICAgICAgICAgICAvLyBkZXRhY2hFdmVudCBuZWVkZWQgcHJvcGVydHkgb24gZWxlbWVudCwgYnkgbmFtZSBvZiB0aGF0IGV2ZW50LCB0byBwcm9wZXJseSBleHBvc2UgaXQgdG8gR0NcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtWyBuYW1lIF0gPT09IGNvcmVfc3RydW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtWyBuYW1lIF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCBuYW1lLCBoYW5kbGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBcbiAgICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcbiAgICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gRXZlbnQgb2JqZWN0XG4gICAgICAgIGlmICggc3JjICYmIHNyYy50eXBlICkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG4gICAgXG4gICAgICAgICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHwgc3JjLnJldHVyblZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgIHNyYy5nZXRQcmV2ZW50RGVmYXVsdCAmJiBzcmMuZ2V0UHJldmVudERlZmF1bHQoKSApID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuICAgIFxuICAgICAgICAvLyBFdmVudCB0eXBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcbiAgICAgICAgaWYgKCBwcm9wcyApIHtcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG4gICAgXG4gICAgICAgIC8vIE1hcmsgaXQgYXMgZml4ZWRcbiAgICAgICAgdGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG4gICAgfTtcbiAgICBcbiAgICAvLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgICBqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgXG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG4gICAgICAgICAgICBpZiAoICFlICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIElmIHByZXZlbnREZWZhdWx0IGV4aXN0cywgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgICAgICAgICAgaWYgKCBlLnByZXZlbnREZWZhdWx0ICkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2V0IHRoZSByZXR1cm5WYWx1ZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgXG4gICAgICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgICAgICAgIGlmICggIWUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cywgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgICAgICAgICAgaWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUVcbiAgICAgICAgICAgIC8vIFNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICAgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG4gICAgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogZml4LFxuICAgICAgICAgICAgYmluZFR5cGU6IGZpeCxcbiAgICBcbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciByZXQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICAgIC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG4gICAgICAgICAgICAgICAgaWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIC8vIElFIHN1Ym1pdCBkZWxlZ2F0aW9uXG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuc3VibWl0QnViYmxlcyApIHtcbiAgICBcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWwuc3VibWl0ID0ge1xuICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gTGF6eS1hZGQgYSBzdWJtaXQgaGFuZGxlciB3aGVuIGEgZGVzY2VuZGFudCBmb3JtIG1heSBwb3RlbnRpYWxseSBiZSBzdWJtaXR0ZWRcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSBuYW1lIGNoZWNrIGF2b2lkcyBhIFZNTC1yZWxhdGVkIGNyYXNoIGluIElFICgjOTgwNylcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0gPSBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApID8gZWxlbS5mb3JtIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGZvcm0gJiYgIWpRdWVyeS5fZGF0YSggZm9ybSwgXCJzdWJtaXRCdWJibGVzXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGZvcm0sIFwic3VibWl0Ll9zdWJtaXRcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9zdWJtaXRfYnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9kYXRhKCBmb3JtLCBcInN1Ym1pdEJ1YmJsZXNcIiwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHVuZGVmaW5lZCBzaW5jZSB3ZSBkb24ndCBuZWVkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZm9ybSB3YXMgc3VibWl0dGVkIGJ5IHRoZSB1c2VyLCBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSB0cmVlXG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC5fc3VibWl0X2J1YmJsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50Ll9zdWJtaXRfYnViYmxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcInN1Ym1pdFwiLCB0aGlzLnBhcmVudE5vZGUsIGV2ZW50LCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGRlbGVnYXRlZCBoYW5kbGVyczsgY2xlYW5EYXRhIGV2ZW50dWFsbHkgcmVhcHMgc3VibWl0IGhhbmRsZXJzIGF0dGFjaGVkIGFib3ZlXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgXCIuX3N1Ym1pdFwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIElFIGNoYW5nZSBkZWxlZ2F0aW9uIGFuZCBjaGVja2JveC9yYWRpbyBmaXhcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5jaGFuZ2VCdWJibGVzICkge1xuICAgIFxuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UgPSB7XG4gICAgXG4gICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCByZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgZG9lc24ndCBmaXJlIGNoYW5nZSBvbiBhIGNoZWNrL3JhZGlvIHVudGlsIGJsdXI7IHRyaWdnZXIgaXQgb24gY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgYSBwcm9wZXJ0eWNoYW5nZS4gRWF0IHRoZSBibHVyLWNoYW5nZSBpbiBzcGVjaWFsLmNoYW5nZS5oYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc3RpbGwgZmlyZXMgb25jaGFuZ2UgYSBzZWNvbmQgdGltZSBmb3IgY2hlY2svcmFkaW8gYWZ0ZXIgYmx1ci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LnByb3BlcnR5TmFtZSA9PT0gXCJjaGVja2VkXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2p1c3RfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5fanVzdF9jaGFuZ2VkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2p1c3RfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0cmlnZ2VyZWQsIHNpbXVsYXRlZCBjaGFuZ2UgZXZlbnRzICgjMTE1MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcImNoYW5nZVwiLCB0aGlzLCBldmVudCwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEZWxlZ2F0ZWQgZXZlbnQ7IGxhenktYWRkIGEgY2hhbmdlIGhhbmRsZXIgb24gZGVzY2VuZGFudCBpbnB1dHNcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZS50YXJnZXQ7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmZvcm1FbGVtcy50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgIWpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VCdWJibGVzXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGVsZW0sIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1NpbXVsYXRlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMucGFyZW50Tm9kZSwgZXZlbnQsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VCdWJibGVzXCIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZXZlbnQudGFyZ2V0O1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgbmF0aXZlIGNoYW5nZSBldmVudHMgZnJvbSBjaGVja2JveC9yYWRpbywgd2UgYWxyZWFkeSB0cmlnZ2VyZWQgdGhlbSBhYm92ZVxuICAgICAgICAgICAgICAgIGlmICggdGhpcyAhPT0gZWxlbSB8fCBldmVudC5pc1NpbXVsYXRlZCB8fCBldmVudC5pc1RyaWdnZXIgfHwgKGVsZW0udHlwZSAhPT0gXCJyYWRpb1wiICYmIGVsZW0udHlwZSAhPT0gXCJjaGVja2JveFwiKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9jaGFuZ2VcIiApO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiAhcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBcImJ1YmJsaW5nXCIgZm9jdXMgYW5kIGJsdXIgZXZlbnRzXG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcbiAgICBcbiAgICAgICAgICAgIC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcbiAgICAgICAgICAgIHZhciBhdHRhY2hlcyA9IDAsXG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGF0dGFjaGVzKysgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAtLWF0dGFjaGVzID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIFxuICAgICAgICBvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSwgb3JpZ0ZuO1xuICAgIFxuICAgICAgICAgICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiB0eXBlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbiggdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZm4gKVxuICAgICAgICAgICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICggdHlwZXMsIGRhdGEsIGZuIClcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggZm4gPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAhZm4gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIG9uZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBvcmlnRm4gPSBmbjtcbiAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuICAgICAgICAgICAgICAgIGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuICAgICAgICB9LFxuICAgICAgICBvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU9iaiwgdHlwZTtcbiAgICAgICAgICAgIGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuICAgICAgICAgICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgIC8vICggdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuICAgICAgICAgICAgLy8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXTtcbiAgICAgICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qIVxuICAgICAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lXG4gICAgICogQ29weXJpZ2h0IDIwMTIgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgICAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcbiAgICBcbiAgICB2YXIgaSxcbiAgICAgICAgY2FjaGVkcnVucyxcbiAgICAgICAgRXhwcixcbiAgICAgICAgZ2V0VGV4dCxcbiAgICAgICAgaXNYTUwsXG4gICAgICAgIGNvbXBpbGUsXG4gICAgICAgIGhhc0R1cGxpY2F0ZSxcbiAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCxcbiAgICBcbiAgICAgICAgLy8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuICAgICAgICBzZXREb2N1bWVudCxcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIGRvY0VsZW0sXG4gICAgICAgIGRvY3VtZW50SXNYTUwsXG4gICAgICAgIHJidWdneVFTQSxcbiAgICAgICAgcmJ1Z2d5TWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgY29udGFpbnMsXG4gICAgICAgIHNvcnRPcmRlcixcbiAgICBcbiAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuICAgICAgICBleHBhbmRvID0gXCJzaXp6bGVcIiArIC0obmV3IERhdGUoKSksXG4gICAgICAgIHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgc3VwcG9ydCA9IHt9LFxuICAgICAgICBkaXJydW5zID0gMCxcbiAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgXG4gICAgICAgIC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcbiAgICAgICAgc3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZCxcbiAgICAgICAgTUFYX05FR0FUSVZFID0gMSA8PCAzMSxcbiAgICBcbiAgICAgICAgLy8gQXJyYXkgbWV0aG9kc1xuICAgICAgICBhcnIgPSBbXSxcbiAgICAgICAgcG9wID0gYXJyLnBvcCxcbiAgICAgICAgcHVzaCA9IGFyci5wdXNoLFxuICAgICAgICBzbGljZSA9IGFyci5zbGljZSxcbiAgICAgICAgLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGlmIHdlIGNhbid0IHVzZSBhIG5hdGl2ZSBvbmVcbiAgICAgICAgaW5kZXhPZiA9IGFyci5pbmRleE9mIHx8IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzW2ldID09PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG4gICAgXG4gICAgXG4gICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICBcbiAgICAgICAgLy8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG4gICAgICAgIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4LyNjaGFyYWN0ZXJzXG4gICAgICAgIGNoYXJhY3RlckVuY29kaW5nID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcbiAgICBcbiAgICAgICAgLy8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICAgICAgLy8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG4gICAgICAgIGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXG4gICAgXG4gICAgICAgIC8vIEFjY2VwdGFibGUgb3BlcmF0b3JzIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuICAgICAgICBvcGVyYXRvcnMgPSBcIihbKl4kfCF+XT89KVwiLFxuICAgICAgICBhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgIFwiKig/OlwiICsgb3BlcmF0b3JzICsgd2hpdGVzcGFjZSArIFwiKig/OihbJ1xcXCJdKSgoPzpcXFxcXFxcXC58W15cXFxcXFxcXF0pKj8pXFxcXDN8KFwiICsgaWRlbnRpZmllciArIFwiKXwpfClcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuICAgIFxuICAgICAgICAvLyBQcmVmZXIgYXJndW1lbnRzIHF1b3RlZCxcbiAgICAgICAgLy8gICB0aGVuIG5vdCBjb250YWluaW5nIHBzZXVkb3MvYnJhY2tldHMsXG4gICAgICAgIC8vICAgdGhlbiBhdHRyaWJ1dGUgc2VsZWN0b3JzL25vbi1wYXJlbnRoZXRpY2FsIGV4cHJlc3Npb25zLFxuICAgICAgICAvLyAgIHRoZW4gYW55dGhpbmcgZWxzZVxuICAgICAgICAvLyBUaGVzZSBwcmVmZXJlbmNlcyBhcmUgaGVyZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnNcbiAgICAgICAgLy8gICBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBQU0VVRE8gcHJlRmlsdGVyXG4gICAgICAgIHBzZXVkb3MgPSBcIjooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlxcXFwoKChbJ1xcXCJdKSgoPzpcXFxcXFxcXC58W15cXFxcXFxcXF0pKj8pXFxcXDN8KCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcy5yZXBsYWNlKCAzLCA4ICkgKyBcIikqKXwuKilcXFxcKXwpXCIsXG4gICAgXG4gICAgICAgIC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcbiAgICAgICAgcnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuICAgIFxuICAgICAgICByY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcbiAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFtcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGY+K35dKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG4gICAgICAgIHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG4gICAgICAgIHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcbiAgICBcbiAgICAgICAgbWF0Y2hFeHByID0ge1xuICAgICAgICAgICAgXCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuICAgICAgICAgICAgXCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcbiAgICAgICAgICAgIFwiTkFNRVwiOiBuZXcgUmVnRXhwKCBcIl5cXFxcW25hbWU9WydcXFwiXT8oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVsnXFxcIl0/XFxcXF1cIiApLFxuICAgICAgICAgICAgXCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidypcIiApICsgXCIpXCIgKSxcbiAgICAgICAgICAgIFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcbiAgICAgICAgICAgIFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuICAgICAgICAgICAgXCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuICAgICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG4gICAgICAgICAgICBcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICByc2libGluZyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKlsrfl0vLFxuICAgIFxuICAgICAgICBybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgY29kZS8sXG4gICAgXG4gICAgICAgIC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuICAgICAgICBycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG4gICAgXG4gICAgICAgIHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuICAgICAgICByaGVhZGVyID0gL15oXFxkJC9pLFxuICAgIFxuICAgICAgICByZXNjYXBlID0gLyd8XFxcXC9nLFxuICAgICAgICByYXR0cmlidXRlUXVvdGVzID0gL1xcPVtcXHgyMFxcdFxcclxcblxcZl0qKFteJ1wiXFxdXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXF0vZyxcbiAgICBcbiAgICAgICAgLy8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuICAgICAgICBydW5lc2NhcGUgPSAvXFxcXChbXFxkYS1mQS1GXXsxLDZ9W1xceDIwXFx0XFxyXFxuXFxmXT98LikvZyxcbiAgICAgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQgKSB7XG4gICAgICAgICAgICB2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuICAgICAgICAgICAgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAgICAgICAgIHJldHVybiBoaWdoICE9PSBoaWdoID9cbiAgICAgICAgICAgICAgICBlc2NhcGVkIDpcbiAgICAgICAgICAgICAgICAvLyBCTVAgY29kZXBvaW50XG4gICAgICAgICAgICAgICAgaGlnaCA8IDAgP1xuICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG4gICAgICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuICAgICAgICB9O1xuICAgIFxuICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gc2xpY2UgaWYgd2UgY2FuJ3QgdXNlIGEgbmF0aXZlIG9uZVxuICAgIHRyeSB7XG4gICAgICAgIHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcywgMCApWzBdLm5vZGVUeXBlO1xuICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICBzbGljZSA9IGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IHRoaXNbaSsrXSkgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogRm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHRlc3QgZm9yIG5hdGl2ZSBzdXBwb3J0XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUoIGZuICkge1xuICAgICAgICByZXR1cm4gcm5hdGl2ZS50ZXN0KCBmbiArIFwiXCIgKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9uKHN0cmluZywgT2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICAgICAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICAgICAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gICAgICAgIHZhciBjYWNoZSxcbiAgICAgICAgICAgIGtleXMgPSBbXTtcbiAgICBcbiAgICAgICAgcmV0dXJuIChjYWNoZSA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcbiAgICAgICAgICAgIGlmICgga2V5cy5wdXNoKCBrZXkgKz0gXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY2FjaGVbIGtleSBdID0gdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG4gICAgICAgIGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oIGRpdiApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuICAgICAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuICAgICAgICB2YXIgbWF0Y2gsIGVsZW0sIG0sIG5vZGVUeXBlLFxuICAgICAgICAgICAgLy8gUVNBIHZhcnNcbiAgICAgICAgICAgIGksIGdyb3Vwcywgb2xkLCBuaWQsIG5ld0NvbnRleHQsIG5ld1NlbGVjdG9yO1xuICAgIFxuICAgICAgICBpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgc2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gICAgXG4gICAgICAgIGlmICggIXNlbGVjdG9yIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmICggKG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZSkgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCAhZG9jdW1lbnRJc1hNTCAmJiAhc2VlZCApIHtcbiAgICBcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgaWYgKCAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcbiAgICAgICAgICAgICAgICBpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLmlkID09PSBtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgbm90IGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJiBlbGVtLmlkID09PSBtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU3BlZWQtdXA6IFNpenpsZShcIlRBR1wiKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLCBzbGljZS5jYWxsKGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICksIDApICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIuQ0xBU1NcIilcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEJ5Q2xhc3NOYW1lICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2xpY2UuY2FsbChjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSwgMCkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gUVNBIHBhdGhcbiAgICAgICAgICAgIGlmICggc3VwcG9ydC5xc2EgJiYgIXJidWdneVFTQS50ZXN0KHNlbGVjdG9yKSApIHtcbiAgICAgICAgICAgICAgICBvbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5pZCA9IGV4cGFuZG87XG4gICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBub2RlVHlwZSA9PT0gOSAmJiBzZWxlY3RvcjtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXNcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG4gICAgICAgICAgICAgICAgLy8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKCBub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pZCA9IG9sZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuaWQgPSBcIltpZD0nXCIgKyBuaWQgKyBcIiddIFwiO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpID0gZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHNbaV0gPSBuaWQgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiBjb250ZXh0LnBhcmVudE5vZGUgfHwgY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGlmICggbmV3U2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLCBzbGljZS5jYWxsKCBuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICksIDAgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gocXNhRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW9sZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEFsbCBvdGhlcnNcbiAgICAgICAgcmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIERldGVjdCB4bWxcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICAgICAqL1xuICAgIGlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgLy8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG4gICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICovXG4gICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcbiAgICAgICAgdmFyIGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcbiAgICBcbiAgICAgICAgLy8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxuICAgICAgICBpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIFNldCBvdXIgZG9jdW1lbnRcbiAgICAgICAgZG9jdW1lbnQgPSBkb2M7XG4gICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIFxuICAgICAgICAvLyBTdXBwb3J0IHRlc3RzXG4gICAgICAgIGRvY3VtZW50SXNYTUwgPSBpc1hNTCggZG9jICk7XG4gICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcbiAgICAgICAgc3VwcG9ydC50YWdOYW1lTm9Db21tZW50cyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuICAgICAgICAgICAgcmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHJldHJpZXZlZCBieSBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8c2VsZWN0Pjwvc2VsZWN0PlwiO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZGl2Lmxhc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKTtcbiAgICAgICAgICAgIC8vIElFOCByZXR1cm5zIGEgc3RyaW5nIGZvciBzb21lIGF0dHJpYnV0ZXMgZXZlbiB3aGVuIG5vdCBwcmVzZW50XG4gICAgICAgICAgICByZXR1cm4gdHlwZSAhPT0gXCJib29sZWFuXCIgJiYgdHlwZSAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgY2FuIGJlIHRydXN0ZWRcbiAgICAgICAgc3VwcG9ydC5nZXRCeUNsYXNzTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgLy8gT3BlcmEgY2FuJ3QgZmluZCBhIHNlY29uZCBjbGFzc25hbWUgKGluIDkuNilcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2hpZGRlbiBlJz48L2Rpdj48ZGl2IGNsYXNzPSdoaWRkZW4nPjwvZGl2PlwiO1xuICAgICAgICAgICAgaWYgKCAhZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgfHwgIWRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gU2FmYXJpIDMuMiBjYWNoZXMgY2xhc3MgYXR0cmlidXRlcyBhbmQgZG9lc24ndCBjYXRjaCBjaGFuZ2VzXG4gICAgICAgICAgICBkaXYubGFzdENoaWxkLmNsYXNzTmFtZSA9IFwiZVwiO1xuICAgICAgICAgICAgcmV0dXJuIGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggPT09IDI7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcbiAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeU5hbWUgcHJpdmlsZWdlcyBmb3JtIGNvbnRyb2xzIG9yIHJldHVybnMgZWxlbWVudHMgYnkgSURcbiAgICAgICAgc3VwcG9ydC5nZXRCeU5hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgIC8vIEluamVjdCBjb250ZW50XG4gICAgICAgICAgICBkaXYuaWQgPSBleHBhbmRvICsgMDtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxhIG5hbWU9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+PGRpdiBuYW1lPSdcIiArIGV4cGFuZG8gKyBcIic+PC9kaXY+XCI7XG4gICAgICAgICAgICBkb2NFbGVtLmluc2VydEJlZm9yZSggZGl2LCBkb2NFbGVtLmZpcnN0Q2hpbGQgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFRlc3RcbiAgICAgICAgICAgIHZhciBwYXNzID0gZG9jLmdldEVsZW1lbnRzQnlOYW1lICYmXG4gICAgICAgICAgICAgICAgLy8gYnVnZ3kgYnJvd3NlcnMgd2lsbCByZXR1cm4gZmV3ZXIgdGhhbiB0aGUgY29ycmVjdCAyXG4gICAgICAgICAgICAgICAgZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoID09PSAyICtcbiAgICAgICAgICAgICAgICAvLyBidWdneSBicm93c2VycyB3aWxsIHJldHVybiBtb3JlIHRoYW4gdGhlIGNvcnJlY3QgMFxuICAgICAgICAgICAgICAgIGRvYy5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyArIDAgKS5sZW5ndGg7XG4gICAgICAgICAgICBzdXBwb3J0LmdldElkTm90TmFtZSA9ICFkb2MuZ2V0RWxlbWVudEJ5SWQoIGV4cGFuZG8gKTtcbiAgICBcbiAgICAgICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgICAgIGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGRpdiApO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHBhc3M7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvLyBJRTYvNyByZXR1cm4gbW9kaWZpZWQgYXR0cmlidXRlc1xuICAgICAgICBFeHByLmF0dHJIYW5kbGUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcbiAgICAgICAgICAgIHJldHVybiBkaXYuZmlyc3RDaGlsZCAmJiB0eXBlb2YgZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIjtcbiAgICAgICAgfSkgP1xuICAgICAgICAgICAge30gOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaHJlZlwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImhyZWZcIiwgMiApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIElEIGZpbmQgYW5kIGZpbHRlclxuICAgICAgICBpZiAoIHN1cHBvcnQuZ2V0SWROb3ROYW1lICkge1xuICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gc3RydW5kZWZpbmVkICYmICFkb2N1bWVudElzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gW21dIDogW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gc3RydW5kZWZpbmVkICYmICFkb2N1bWVudElzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG0uaWQgPT09IGlkIHx8IHR5cGVvZiBtLmdldEF0dHJpYnV0ZU5vZGUgIT09IHN0cnVuZGVmaW5lZCAmJiBtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKS52YWx1ZSA9PT0gaWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gc3RydW5kZWZpbmVkICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gVGFnXG4gICAgICAgIEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQudGFnTmFtZU5vQ29tbWVudHMgP1xuICAgICAgICAgICAgZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBzdHJ1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDpcbiAgICAgICAgICAgIGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyBOYW1lXG4gICAgICAgIEV4cHIuZmluZFtcIk5BTUVcIl0gPSBzdXBwb3J0LmdldEJ5TmFtZSAmJiBmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSAhPT0gc3RydW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBuYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIENsYXNzXG4gICAgICAgIEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgIWRvY3VtZW50SXNYTUwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcbiAgICBcbiAgICAgICAgLy8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcbiAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuICAgIFxuICAgICAgICAvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKSxcbiAgICAgICAgLy8gbm8gbmVlZCB0byBhbHNvIGFkZCB0byBidWdneU1hdGNoZXMgc2luY2UgbWF0Y2hlcyBjaGVja3MgYnVnZ3lRU0FcbiAgICAgICAgLy8gQSBzdXBwb3J0IHRlc3Qgd291bGQgcmVxdWlyZSB0b28gbXVjaCBjb2RlICh3b3VsZCBpbmNsdWRlIGRvY3VtZW50IHJlYWR5KVxuICAgICAgICByYnVnZ3lRU0EgPSBbIFwiOmZvY3VzXCIgXTtcbiAgICBcbiAgICAgICAgaWYgKCAoc3VwcG9ydC5xc2EgPSBpc05hdGl2ZShkb2MucXVlcnlTZWxlY3RvckFsbCkpICkge1xuICAgICAgICAgICAgLy8gQnVpbGQgUVNBIHJlZ2V4XG4gICAgICAgICAgICAvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG4gICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPHNlbGVjdD48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIElFOCAtIFNvbWUgYm9vbGVhbiBhdHRyaWJ1dGVzIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICBpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OmNoZWNrZWR8ZGlzYWJsZWR8aXNtYXB8bXVsdGlwbGV8cmVhZG9ubHl8c2VsZWN0ZWR8dmFsdWUpXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG4gICAgICAgICAgICAgICAgaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMC0xMi9JRTggLSBePSAkPSAqPSBhbmQgZW1wdHkgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBzZWxlY3QgYW55dGhpbmdcbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpPScnLz5cIjtcbiAgICAgICAgICAgICAgICBpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW2lePScnXVwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OlxcXCJcXFwifCcnKVwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG4gICAgICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcbiAgICAgICAgICAgICAgICBpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuICAgICAgICAgICAgICAgIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IGlzTmF0aXZlKCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICBkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgIGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG4gICAgXG4gICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmJ1Z2d5UVNBID0gbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG4gICAgICAgIHJidWdneU1hdGNoZXMgPSBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG4gICAgXG4gICAgICAgIC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuICAgICAgICAvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG4gICAgICAgIC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG4gICAgICAgIGNvbnRhaW5zID0gaXNOYXRpdmUoZG9jRWxlbS5jb250YWlucykgfHwgZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcbiAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMoIGJ1cCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBiID09PSBhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcbiAgICAgICAgc29ydE9yZGVyID0gZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmU7XG4gICAgXG4gICAgICAgICAgICBpZiAoIGEgPT09IGIgKSB7XG4gICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICggKGNvbXBhcmUgPSBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApKSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXBhcmUgJiAxIHx8IGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGRvYyB8fCBjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBiID09PSBkb2MgfHwgY29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gLTEgOiAxO1xuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICB2YXIgY3VyLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGF1cCA9IGEucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBidXAgPSBiLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgYXAgPSBbIGEgXSxcbiAgICAgICAgICAgICAgICBicCA9IFsgYiBdO1xuICAgIFxuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuICAgICAgICAgICAgaWYgKCBhID09PSBiICkge1xuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgXG4gICAgICAgICAgICAvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgfSBlbHNlIGlmICggIWF1cCB8fCAhYnVwICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBkb2MgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgIGIgPT09IGRvYyA/IDEgOlxuICAgICAgICAgICAgICAgICAgICBhdXAgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgIGJ1cCA/IDEgOlxuICAgICAgICAgICAgICAgICAgICAwO1xuICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG4gICAgICAgICAgICBjdXIgPSBhO1xuICAgICAgICAgICAgd2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuICAgICAgICAgICAgICAgIGFwLnVuc2hpZnQoIGN1ciApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gYjtcbiAgICAgICAgICAgIHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICAgICAgICBicC51bnNoaWZ0KCBjdXIgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG4gICAgICAgICAgICB3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gaSA/XG4gICAgICAgICAgICAgICAgLy8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgc2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG4gICAgICAgICAgICAgICAgYXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcbiAgICAgICAgICAgICAgICBicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG4gICAgICAgICAgICAgICAgMDtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gQWx3YXlzIGFzc3VtZSB0aGUgcHJlc2VuY2Ugb2YgZHVwbGljYXRlcyBpZiBzb3J0IGRvZXNuJ3RcbiAgICAgICAgLy8gcGFzcyB0aGVtIHRvIG91ciBjb21wYXJpc29uIGZ1bmN0aW9uIChhcyBpbiBHb29nbGUgQ2hyb21lKS5cbiAgICAgICAgaGFzRHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgIFswLCAwXS5zb3J0KCBzb3J0T3JkZXIgKTtcbiAgICAgICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gaGFzRHVwbGljYXRlO1xuICAgIFxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfTtcbiAgICBcbiAgICBTaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcbiAgICAgICAgcmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbiAgICB9O1xuICAgIFxuICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcbiAgICAgICAgICAgIHNldERvY3VtZW50KCBlbGVtICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG4gICAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcbiAgICBcbiAgICAgICAgLy8gcmJ1Z2d5UVNBIGFsd2F5cyBjb250YWlucyA6Zm9jdXMsIHNvIG5vIG5lZWQgZm9yIGFuIGV4aXN0ZW5jZSBjaGVja1xuICAgICAgICBpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmICFkb2N1bWVudElzWE1MICYmICghcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KGV4cHIpKSAmJiAhcmJ1Z2d5UVNBLnRlc3QoZXhwcikgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyYWdtZW50IGluIElFIDlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbZWxlbV0gKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgXG4gICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG4gICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG4gICAgICAgICAgICBzZXREb2N1bWVudCggY29udGV4dCApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xuICAgIH07XG4gICAgXG4gICAgU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICBcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcbiAgICAgICAgICAgIHNldERvY3VtZW50KCBlbGVtICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCAhZG9jdW1lbnRJc1hNTCApIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAodmFsID0gRXhwci5hdHRySGFuZGxlWyBuYW1lIF0pICkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCggZWxlbSApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggZG9jdW1lbnRJc1hNTCB8fCBzdXBwb3J0LmF0dHJpYnV0ZXMgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgKSAmJiBlbGVtWyBuYW1lIF0gPT09IHRydWUgP1xuICAgICAgICAgICAgbmFtZSA6XG4gICAgICAgICAgICB2YWwgJiYgdmFsLnNwZWNpZmllZCA/IHZhbC52YWx1ZSA6IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAgICBTaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcbiAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgaiA9IDA7XG4gICAgXG4gICAgICAgIC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcbiAgICAgICAgaGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcbiAgICAgICAgcmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcbiAgICBcbiAgICAgICAgaWYgKCBoYXNEdXBsaWNhdGUgKSB7XG4gICAgICAgICAgICBmb3IgKCA7IChlbGVtID0gcmVzdWx0c1tpXSk7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgLSAxIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG4gICAgICAgIHZhciBjdXIgPSBiICYmIGEsXG4gICAgICAgICAgICBkaWZmID0gY3VyICYmICggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLSAoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuICAgIFxuICAgICAgICAvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcbiAgICAgICAgaWYgKCBkaWZmICkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcbiAgICAgICAgaWYgKCBjdXIgKSB7XG4gICAgICAgICAgICB3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuICAgICAgICAgICAgICAgIGlmICggY3VyID09PSBiICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBhID8gMSA6IC0xO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAgICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcbiAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG4gICAgICAgICAgICBhcmd1bWVudCA9ICthcmd1bWVudDtcbiAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGosXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICAgICAqL1xuICAgIGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgIHJldCA9IFwiXCIsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcbiAgICBcbiAgICAgICAgaWYgKCAhbm9kZVR5cGUgKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuICAgICAgICAgICAgZm9yICggOyAobm9kZSA9IGVsZW1baV0pOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChzZWUgIzExMTUzKVxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgZm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcbiAgICBcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIFxuICAgIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuICAgIFxuICAgICAgICAvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgY2FjaGVMZW5ndGg6IDUwLFxuICAgIFxuICAgICAgICBjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcbiAgICBcbiAgICAgICAgbWF0Y2g6IG1hdGNoRXhwcixcbiAgICBcbiAgICAgICAgZmluZDoge30sXG4gICAgXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICBcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgXCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuICAgICAgICAgICAgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcHJlRmlsdGVyOiB7XG4gICAgICAgICAgICBcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuICAgICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuICAgICAgICAgICAgICAgIG1hdGNoWzNdID0gKCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cbiAgICAgICAgICAgICAgICAgICAgMSB0eXBlIChvbmx5fG50aHwuLi4pXG4gICAgICAgICAgICAgICAgICAgIDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgMyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcbiAgICAgICAgICAgICAgICAgICAgNCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG4gICAgICAgICAgICAgICAgICAgIDUgc2lnbiBvZiB4bi1jb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgNiB4IG9mIHhuLWNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICA3IHNpZ24gb2YgeS1jb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgOCB5IG9mIHktY29tcG9uZW50XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaFszXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuICAgICAgICAgICAgICAgICAgICBtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG4gICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhjZXNzLFxuICAgICAgICAgICAgICAgICAgICB1bnF1b3RlZCA9ICFtYXRjaFs1XSAmJiBtYXRjaFsyXTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbNF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdID0gbWF0Y2hbNF07XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcbiAgICAgICAgICAgICAgICAgICAgKGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICAgICAgKGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGZpbHRlcjoge1xuICAgIFxuICAgICAgICAgICAgXCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lICkge1xuICAgICAgICAgICAgICAgIGlmICggbm9kZU5hbWUgPT09IFwiKlwiICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IG5vZGVOYW1lLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoIGVsZW0uY2xhc3NOYW1lIHx8ICh0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IHN0cnVuZGVmaW5lZCAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSB8fCBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzdWx0ID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoICFvcGVyYXRvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdCArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgXCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuICAgICAgICAgICAgICAgIHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgb2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgZGlmZiwgbm9kZUluZGV4LCBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNpbXBsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBkaXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gY2FjaGVbMV07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geG1sIDpudGgtY2hpbGQoLi4uKSBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJiArK2RpZmYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdXNlQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgLT0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcbiAgICAgICAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAgICAgLy8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8ganVzdCBhcyBTaXp6bGUgZG9lc1xuICAgICAgICAgICAgICAgIGlmICggZm5bIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCBhcmd1bWVudCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcbiAgICAgICAgICAgICAgICBpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaW5kZXhPZi5jYWxsKCBzZWVkLCBtYXRjaGVkW2ldICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHBzZXVkb3M6IHtcbiAgICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuICAgICAgICAgICAgXCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuICAgICAgICAgICAgICAgICAgICBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gc2VlZC5sZW5ndGg7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgXG4gICAgICAgICAgICBcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICBcbiAgICAgICAgICAgIFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgXG4gICAgICAgICAgICAvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcbiAgICAgICAgICAgIC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG4gICAgICAgICAgICAvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuICAgICAgICAgICAgLy8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cbiAgICAgICAgICAgIC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICAgICAgLy8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuICAgICAgICAgICAgXCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG4gICAgICAgICAgICAgICAgLy8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmlkZXJcbiAgICAgICAgICAgICAgICBpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG4gICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNYTUwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmxhbmcpICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgIFxuICAgICAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICAgICAgXCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgXCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgXCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICAgIFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cbiAgICAgICAgICAgICAgICAvLyA6ZW1wdHkgaXMgb25seSBhZmZlY3RlZCBieSBlbGVtZW50IG5vZGVzIGFuZCBjb250ZW50IG5vZGVzKGluY2x1ZGluZyB0ZXh0KDMpLCBjZGF0YSg0KSksXG4gICAgICAgICAgICAgICAgLy8gICBub3QgY29tbWVudCwgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnMsIG9yIG90aGVyc1xuICAgICAgICAgICAgICAgIC8vIFRoYW5rcyB0byBEaWVnbyBQZXJpbmkgZm9yIHRoZSBub2RlTmFtZSBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIC8vICAgR3JlYXRlciB0aGFuIFwiQFwiIG1lYW5zIGFscGhhIGNoYXJhY3RlcnMgKHNwZWNpZmljYWxseSBub3Qgc3RhcnRpbmcgd2l0aCBcIiNcIiBvciBcIj9cIilcbiAgICAgICAgICAgICAgICBmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVOYW1lID4gXCJAXCIgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXG4gICAgICAgICAgICBcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgXCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgICAgICAgLy8gSUU2IGFuZCA3IHdpbGwgbWFwIGVsZW0udHlwZSB0byAndGV4dCcgZm9yIG5ldyBIVE1MNSB0eXBlcyAoc2VhcmNoLCBldGMpXG4gICAgICAgICAgICAgICAgLy8gdXNlIGdldEF0dHJpYnV0ZSBpbnN0ZWFkIHRvIHRlc3QgdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0udHlwZSApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cbiAgICAgICAgICAgIFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyAwIF07XG4gICAgICAgICAgICB9KSxcbiAgICBcbiAgICAgICAgICAgIFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBsZW5ndGggLSAxIF07XG4gICAgICAgICAgICB9KSxcbiAgICBcbiAgICAgICAgICAgIFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcbiAgICAgICAgICAgIH0pLFxuICAgIFxuICAgICAgICAgICAgXCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgIH0pLFxuICAgIFxuICAgICAgICAgICAgXCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICAgICAgfSksXG4gICAgXG4gICAgICAgICAgICBcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgZm9yICggOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICB9KSxcbiAgICBcbiAgICAgICAgICAgIFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuICAgIGZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuICAgICAgICBFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG4gICAgfVxuICAgIGZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG4gICAgICAgIEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHRva2VuaXplKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuICAgICAgICB2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcbiAgICAgICAgICAgIHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG4gICAgICAgICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG4gICAgXG4gICAgICAgIGlmICggY2FjaGVkICkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBzb0ZhciA9IHNlbGVjdG9yO1xuICAgICAgICBncm91cHMgPSBbXTtcbiAgICAgICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuICAgIFxuICAgICAgICB3aGlsZSAoIHNvRmFyICkge1xuICAgIFxuICAgICAgICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuICAgICAgICAgICAgaWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCB0b2tlbnMgPSBbXSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgLy8gQ29tYmluYXRvcnNcbiAgICAgICAgICAgIGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEZpbHRlcnNcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCAhbWF0Y2hlZCApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3NcbiAgICAgICAgLy8gaWYgd2UncmUganVzdCBwYXJzaW5nXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuICAgICAgICByZXR1cm4gcGFyc2VPbmx5ID9cbiAgICAgICAgICAgIHNvRmFyLmxlbmd0aCA6XG4gICAgICAgICAgICBzb0ZhciA/XG4gICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdG9rZW5zXG4gICAgICAgICAgICAgICAgdG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuICAgICAgICB2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG4gICAgICAgICAgICBjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuICAgICAgICAgICAgZG9uZU5hbWUgPSBkb25lKys7XG4gICAgXG4gICAgICAgIHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cbiAgICAgICAgICAgIC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOlxuICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhLCBjYWNoZSwgb3V0ZXJDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgZGlya2V5ID0gZGlycnVucyArIFwiIFwiICsgZG9uZU5hbWU7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcbiAgICAgICAgICAgICAgICBpZiAoIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoY2FjaGUgPSBvdXRlckNhY2hlWyBkaXIgXSkgJiYgY2FjaGVbMF0gPT09IGRpcmtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZGF0YSA9IGNhY2hlWzFdKSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBjYWNoZWRydW5zICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IG91dGVyQ2FjaGVbIGRpciBdID0gWyBkaXJrZXkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVbMV0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB8fCBjYWNoZWRydW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhY2hlWzFdID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgbWF0Y2hlcnNbMF07XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgbmV3VW5tYXRjaGVkID0gW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG4gICAgICAgICAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcbiAgICBcbiAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcbiAgICAgICAgICAgICAgICBpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXBwZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBuZXdVbm1hdGNoZWQ7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcbiAgICAgICAgaWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG4gICAgICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgIHZhciB0ZW1wLCBpLCBlbGVtLFxuICAgICAgICAgICAgICAgIHByZU1hcCA9IFtdLFxuICAgICAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcbiAgICAgICAgICAgICAgICBwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuICAgIFxuICAgICAgICAgICAgICAgIC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuICAgICAgICAgICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuICAgICAgICAgICAgICAgICAgICBjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG4gICAgICAgICAgICAgICAgICAgIGVsZW1zLFxuICAgIFxuICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBbXSA6XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgOlxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVySW47XG4gICAgXG4gICAgICAgICAgICAvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuICAgICAgICAgICAgaWYgKCBtYXRjaGVyICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBBcHBseSBwb3N0RmlsdGVyXG4gICAgICAgICAgICBpZiAoIHBvc3RGaWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG4gICAgICAgICAgICAgICAgcG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cbiAgICAgICAgICAgICAgICBpID0gdGVtcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcbiAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YuY2FsbCggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbmRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG4gICAgICAgIHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG4gICAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcbiAgICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG4gICAgICAgICAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG4gICAgXG4gICAgICAgICAgICAvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuICAgICAgICAgICAgbWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcbiAgICAgICAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcbiAgICAgICAgICAgIG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG4gICAgICAgICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG4gICAgICAgICAgICBtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcbiAgICAgICAgICAgICAgICAgICAgKGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuICAgICAgICAgICAgfSBdO1xuICAgIFxuICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG4gICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuICAgICAgICAgICAgICAgICAgICBqID0gKytpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGogPCBsZW47IGorKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0TWF0Y2hlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDEgJiYgdG9TZWxlY3RvciggdG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApICkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG4gICAgICAgIC8vIEEgY291bnRlciB0byBzcGVjaWZ5IHdoaWNoIGVsZW1lbnQgaXMgY3VycmVudGx5IGJlaW5nIG1hdGNoZWRcbiAgICAgICAgdmFyIG1hdGNoZXJDYWNoZWRSdW5zID0gMCxcbiAgICAgICAgICAgIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgc3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgZXhwYW5kQ29udGV4dCApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSwgaiwgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICBpID0gXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG4gICAgICAgICAgICAgICAgICAgIG91dGVybW9zdCA9IGV4cGFuZENvbnRleHQgIT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3IgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIGV4cGFuZENvbnRleHQgJiYgY29udGV4dC5wYXJlbnROb2RlIHx8IGNvbnRleHQgKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcbiAgICAgICAgICAgICAgICAgICAgZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBvdXRlcm1vc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRydW5zID0gbWF0Y2hlckNhY2hlZFJ1bnM7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG4gICAgICAgICAgICAgICAgLy8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXCIwMFwiIGJlbG93XG4gICAgICAgICAgICAgICAgZm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZHJ1bnMgPSArK21hdGNoZXJDYWNoZWRSdW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBieVNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCArPSBpO1xuICAgICAgICAgICAgICAgIGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICkge1xuICAgICAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB1bm1hdGNoZWQ7XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXR1cm4gYnlTZXQgP1xuICAgICAgICAgICAgbWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG4gICAgICAgICAgICBzdXBlck1hdGNoZXI7XG4gICAgfVxuICAgIFxuICAgIGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgZ3JvdXAgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgICAgY2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuICAgIFxuICAgICAgICBpZiAoICFjYWNoZWQgKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICggIWdyb3VwICkge1xuICAgICAgICAgICAgICAgIGdyb3VwID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gZ3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIGdyb3VwW2ldICk7XG4gICAgICAgICAgICAgICAgaWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuICAgICAgICAgICAgY2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHNlbGVjdCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG4gICAgICAgIHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuICAgICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcbiAgICBcbiAgICAgICAgaWYgKCAhc2VlZCApIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwXG4gICAgICAgICAgICBpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgICAgICAgIHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmICFkb2N1bWVudElzWE1MICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICBpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChzZWVkID0gZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiBjb250ZXh0LnBhcmVudE5vZGUgfHwgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgKSkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIHNsaWNlLmNhbGwoIHNlZWQsIDAgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvblxuICAgICAgICAvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG4gICAgICAgIGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApKFxuICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBkb2N1bWVudElzWE1MLFxuICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgIHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIFxuICAgIC8vIERlcHJlY2F0ZWRcbiAgICBFeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcbiAgICBcbiAgICAvLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbiAgICBmdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbiAgICBFeHByLmZpbHRlcnMgPSBzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIucHNldWRvcztcbiAgICBFeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuICAgIHNldERvY3VtZW50KCk7XG4gICAgXG4gICAgLy8gT3ZlcnJpZGUgc2l6emxlIGF0dHJpYnV0ZSByZXRyaWV2YWxcbiAgICBTaXp6bGUuYXR0ciA9IGpRdWVyeS5hdHRyO1xuICAgIGpRdWVyeS5maW5kID0gU2l6emxlO1xuICAgIGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbiAgICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xuICAgIGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbiAgICBqUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xuICAgIGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbiAgICBqUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG4gICAgXG4gICAgXG4gICAgfSkoIHdpbmRvdyApO1xuICAgIHZhciBydW50aWwgPSAvVW50aWwkLyxcbiAgICAgICAgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG4gICAgICAgIGlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvLFxuICAgICAgICBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LFxuICAgICAgICAvLyBtZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuICAgICAgICBndWFyYW50ZWVkVW5pcXVlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRydWUsXG4gICAgICAgICAgICBjb250ZW50czogdHJ1ZSxcbiAgICAgICAgICAgIG5leHQ6IHRydWUsXG4gICAgICAgICAgICBwcmV2OiB0cnVlXG4gICAgICAgIH07XG4gICAgXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHZhciBpLCByZXQsIHNlbGYsXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKCBzZWxlY3RvciwgdGhpc1sgaSBdLCByZXQgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuICAgICAgICAgICAgcmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuICAgICAgICAgICAgcmV0LnNlbGVjdG9yID0gKCB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiIDogXCJcIiApICsgc2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0YXJnZXRzLmxlbmd0aDtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgbm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciwgZmFsc2UpICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IsIHRydWUpICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gISFzZWxlY3RvciAmJiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG4gICAgICAgICAgICAgICAgICAgIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbGVjdG9yLCB0aGlzLmNvbnRleHQgKS5pbmRleCggdGhpc1swXSApID49IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKS5sZW5ndGggPiAwIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIoIHNlbGVjdG9yICkubGVuZ3RoID4gMCApO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgdmFyIGN1cixcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXG4gICAgICAgICAgICAgICAgcG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuICAgICAgICAgICAgICAgICAgICAwO1xuICAgIFxuICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGN1ciA9IHRoaXNbaV07XG4gICAgXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBjdXIgJiYgY3VyLm93bmVyRG9jdW1lbnQgJiYgY3VyICE9PSBjb250ZXh0ICYmIGN1ci5ub2RlVHlwZSAhPT0gMTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcG9zID8gcG9zLmluZGV4KGN1cikgPiAtMSA6IGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxuICAgICAgICAvLyB0aGUgbWF0Y2hlZCBzZXQgb2YgZWxlbWVudHNcbiAgICAgICAgaW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIFxuICAgICAgICAgICAgLy8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcbiAgICAgICAgICAgIGlmICggIWVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBpbmRleCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmluQXJyYXkoIHRoaXNbMF0sIGpRdWVyeSggZWxlbSApICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuaW5BcnJheShcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcbiAgICAgICAgICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtLCB0aGlzICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgdmFyIHNldCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yICYmIHNlbGVjdG9yLm5vZGVUeXBlID8gWyBzZWxlY3RvciBdIDogc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICBhbGwgPSBqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIHNldCApO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkudW5pcXVlKGFsbCkgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgYWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cbiAgICAgICAgICAgICAgICB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG4gICAgXG4gICAgZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGN1ciA9IGN1clsgZGlyIF07XG4gICAgICAgIH0gd2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSAxICk7XG4gICAgXG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIFxuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgP1xuICAgICAgICAgICAgICAgIGVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcbiAgICBcbiAgICAgICAgICAgIGlmICggIXJ1bnRpbC50ZXN0KCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bnRpbDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCByZXQgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldCA9IHRoaXMubGVuZ3RoID4gMSAmJiAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQ7XG4gICAgXG4gICAgICAgICAgICBpZiAoIHRoaXMubGVuZ3RoID4gMSAmJiBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuICAgICAgICAgICAgICAgIHJldCA9IHJldC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuICAgICAgICAgICAgaWYgKCBub3QgKSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihlbGVtc1swXSwgZXhwcikgPyBbIGVsZW1zWzBdIF0gOiBbXSA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlcyhleHByLCBlbGVtcyk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGRpcjogZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICAgIGN1ciA9IGVsZW1bIGRpciBdO1xuICAgIFxuICAgICAgICAgICAgd2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSA5ICYmICh1bnRpbCA9PT0gdW5kZWZpbmVkIHx8IGN1ci5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5KCBjdXIgKS5pcyggdW50aWwgKSkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjdXIubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ciA9IGN1cltkaXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuICAgICAgICAgICAgdmFyIHIgPSBbXTtcbiAgICBcbiAgICAgICAgICAgIGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaCggbiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbiAgICBmdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIGtlZXAgKSB7XG4gICAgXG4gICAgICAgIC8vIENhbid0IHBhc3MgbnVsbCBvciB1bmRlZmluZWQgdG8gaW5kZXhPZiBpbiBGaXJlZm94IDRcbiAgICAgICAgLy8gU2V0IHRvIDAgdG8gc2tpcCBzdHJpbmcgY2hlY2tcbiAgICAgICAgcXVhbGlmaWVyID0gcXVhbGlmaWVyIHx8IDA7XG4gICAgXG4gICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0VmFsID0gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRWYWwgPT09IGtlZXA7XG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgfSBlbHNlIGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSA9PT0ga2VlcDtcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBpZiAoIGlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZmlsdGVyZWQsICFrZWVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBmaWx0ZXJlZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gKCBqUXVlcnkuaW5BcnJheSggZWxlbSwgcXVhbGlmaWVyICkgPj0gMCApID09PSBrZWVwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApIHtcbiAgICAgICAgdmFyIGxpc3QgPSBub2RlTmFtZXMuc3BsaXQoIFwifFwiICksXG4gICAgICAgICAgICBzYWZlRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBcbiAgICAgICAgaWYgKCBzYWZlRnJhZy5jcmVhdGVFbGVtZW50ICkge1xuICAgICAgICAgICAgd2hpbGUgKCBsaXN0Lmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBzYWZlRnJhZy5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBsaXN0LnBvcCgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FmZUZyYWc7XG4gICAgfVxuICAgIFxuICAgIHZhciBub2RlTmFtZXMgPSBcImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8XCIgK1xuICAgICAgICAgICAgXCJoZWFkZXJ8aGdyb3VwfG1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwcm9ncmVzc3xzZWN0aW9ufHN1bW1hcnl8dGltZXx2aWRlb1wiLFxuICAgICAgICByaW5saW5lalF1ZXJ5ID0gLyBqUXVlcnlcXGQrPVwiKD86bnVsbHxcXGQrKVwiL2csXG4gICAgICAgIHJub3NoaW1jYWNoZSA9IG5ldyBSZWdFeHAoXCI8KD86XCIgKyBub2RlTmFtZXMgKyBcIilbXFxcXHMvPl1cIiwgXCJpXCIpLFxuICAgICAgICBybGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvLFxuICAgICAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksXG4gICAgICAgIHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuICAgICAgICBydGJvZHkgPSAvPHRib2R5L2ksXG4gICAgICAgIHJodG1sID0gLzx8JiM/XFx3KzsvLFxuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxuICAgICAgICBtYW5pcHVsYXRpb25fcmNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSxcbiAgICAgICAgLy8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG4gICAgICAgIHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcbiAgICAgICAgcnNjcmlwdFR5cGUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuICAgICAgICByc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuICAgICAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG4gICAgXG4gICAgICAgIC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG4gICAgICAgIHdyYXBNYXAgPSB7XG4gICAgICAgICAgICBvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcbiAgICAgICAgICAgIGxlZ2VuZDogWyAxLCBcIjxmaWVsZHNldD5cIiwgXCI8L2ZpZWxkc2V0PlwiIF0sXG4gICAgICAgICAgICBhcmVhOiBbIDEsIFwiPG1hcD5cIiwgXCI8L21hcD5cIiBdLFxuICAgICAgICAgICAgcGFyYW06IFsgMSwgXCI8b2JqZWN0PlwiLCBcIjwvb2JqZWN0PlwiIF0sXG4gICAgICAgICAgICB0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG4gICAgICAgICAgICB0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG4gICAgICAgICAgICBjb2w6IFsgMiwgXCI8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuICAgICAgICAgICAgdGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuICAgIFxuICAgICAgICAgICAgLy8gSUU2LTggY2FuJ3Qgc2VyaWFsaXplIGxpbmssIHNjcmlwdCwgc3R5bGUsIG9yIGFueSBodG1sNSAoTm9TY29wZSkgdGFncyxcbiAgICAgICAgICAgIC8vIHVubGVzcyB3cmFwcGVkIGluIGEgZGl2IHdpdGggbm9uLWJyZWFraW5nIGNoYXJhY3RlcnMgaW4gZnJvbnQgb2YgaXQuXG4gICAgICAgICAgICBfZGVmYXVsdDogalF1ZXJ5LnN1cHBvcnQuaHRtbFNlcmlhbGl6ZSA/IFsgMCwgXCJcIiwgXCJcIiBdIDogWyAxLCBcIlg8ZGl2PlwiLCBcIjwvZGl2PlwiICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNhZmVGcmFnbWVudCA9IGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKSxcbiAgICAgICAgZnJhZ21lbnREaXYgPSBzYWZlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcbiAgICBcbiAgICB3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG4gICAgd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbiAgICB3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcbiAgICBcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgdGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKCAoIHRoaXNbMF0gJiYgdGhpc1swXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkuY3JlYXRlVGV4dE5vZGUoIHZhbHVlICkgKTtcbiAgICAgICAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIHRoaXNbMF0gKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcbiAgICAgICAgICAgICAgICB2YXIgd3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50ICkuZXEoMCkuY2xvbmUodHJ1ZSk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWzBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggZWxlbS5maXJzdENoaWxkICYmIGVsZW0uZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKCB0aGlzICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggY29udGVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG4gICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoIGh0bWwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgd3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIHVud3JhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmVuZCgpO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCB0cnVlLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgdHJ1ZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZhbHNlLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBhZnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLy8ga2VlcERhdGEgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5LS1kbyBub3QgZG9jdW1lbnRcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgXG4gICAgICAgICAgICBmb3IgKCA7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggIXNlbGVjdG9yIHx8IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBbIGVsZW0gXSApLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0gKSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEdsb2JhbEV2YWwoIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICBcbiAgICAgICAgICAgIGZvciAoIDsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVDaGlsZCggZWxlbS5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBzZWxlY3QsIGVuc3VyZSB0aGF0IGl0IGRpc3BsYXlzIGVtcHR5ICgjMTIzMzYpXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5vcHRpb25zICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJzZWxlY3RcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLm9wdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcbiAgICAgICAgICAgIGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG4gICAgICAgICAgICBkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwucmVwbGFjZSggcmlubGluZWpRdWVyeSwgXCJcIiApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIGpRdWVyeS5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCB2YWx1ZSApICApICYmXG4gICAgICAgICAgICAgICAgICAgICggalF1ZXJ5LnN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgfHwgIXJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCB2YWx1ZSApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbXCJcIiwgXCJcIl0gKVsxXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1tpXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSAwO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmMgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBlbGVtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBET00gYmVmb3JlIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBoZWxwIGZpeCByZXBsYWNpbmcgYSBwYXJlbnQgd2l0aCBjaGlsZCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCAhaXNGdW5jICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeSggdmFsdWUgKS5ub3QoIHRoaXMgKS5kZXRhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKCBbIHZhbHVlIF0sIHRydWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSggZWxlbSwgbmV4dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZG9tTWFuaXA6IGZ1bmN0aW9uKCBhcmdzLCB0YWJsZSwgY2FsbGJhY2sgKSB7XG4gICAgXG4gICAgICAgICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgICAgICBhcmdzID0gY29yZV9jb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG4gICAgXG4gICAgICAgICAgICB2YXIgZmlyc3QsIG5vZGUsIGhhc1NjcmlwdHMsXG4gICAgICAgICAgICAgICAgc2NyaXB0cywgZG9jLCBmcmFnbWVudCxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc2V0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpTm9DbG9uZSA9IGwgLSAxLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXSxcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG4gICAgXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcbiAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiB8fCAhKCBsIDw9IDEgfHwgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IGpRdWVyeS5zdXBwb3J0LmNoZWNrQ2xvbmUgfHwgIXJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBzZXQuZXEoIGluZGV4ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgdGFibGUgPyBzZWxmLmh0bWwoKSA6IHVuZGVmaW5lZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tTWFuaXAoIGFyZ3MsIHRhYmxlLCBjYWxsYmFjayApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCBsICkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGZpcnN0ICkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHRhYmxlICYmIGpRdWVyeS5ub2RlTmFtZSggZmlyc3QsIFwidHJcIiApO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGZyYWdtZW50O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSBpTm9DbG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaGFzU2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzW2ldLCBcInRhYmxlXCIgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRPckFwcGVuZCggdGhpc1tpXSwgXCJ0Ym9keVwiICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc1NjcmlwdHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVlbmFibGUgc2NyaXB0c1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWpRdWVyeS5fZGF0YSggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJiBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUuc3JjICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9wZSBhamF4IGlzIGF2YWlsYWJsZS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogbm9kZS5zcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRocm93c1wiOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKCAoIG5vZGUudGV4dCB8fCBub2RlLnRleHRDb250ZW50IHx8IG5vZGUuaW5uZXJIVE1MIHx8IFwiXCIgKS5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCAjMTE4MDk6IEF2b2lkIGxlYWtpbmcgbWVtb3J5XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgZnVuY3Rpb24gZmluZE9yQXBwZW5kKCBlbGVtLCB0YWcgKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKVswXSB8fCBlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCggdGFnICkgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuICAgIGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG4gICAgICAgIHZhciBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwidHlwZVwiKTtcbiAgICAgICAgZWxlbS50eXBlID0gKCBhdHRyICYmIGF0dHIuc3BlY2lmaWVkICkgKyBcIi9cIiArIGVsZW0udHlwZTtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuICAgICAgICBpZiAoIG1hdGNoICkge1xuICAgICAgICAgICAgZWxlbS50eXBlID0gbWF0Y2hbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIFxuICAgIC8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuICAgIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcbiAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgZm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgICBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgalF1ZXJ5Ll9kYXRhKCByZWZFbGVtZW50c1tpXSwgXCJnbG9iYWxFdmFsXCIgKSApO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG4gICAgXG4gICAgICAgIGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5Lmhhc0RhdGEoIHNyYyApICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHZhciB0eXBlLCBpLCBsLFxuICAgICAgICAgICAgb2xkRGF0YSA9IGpRdWVyeS5fZGF0YSggc3JjICksXG4gICAgICAgICAgICBjdXJEYXRhID0galF1ZXJ5Ll9kYXRhKCBkZXN0LCBvbGREYXRhICksXG4gICAgICAgICAgICBldmVudHMgPSBvbGREYXRhLmV2ZW50cztcbiAgICBcbiAgICAgICAgaWYgKCBldmVudHMgKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VyRGF0YS5oYW5kbGU7XG4gICAgICAgICAgICBjdXJEYXRhLmV2ZW50cyA9IHt9O1xuICAgIFxuICAgICAgICAgICAgZm9yICggdHlwZSBpbiBldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gbWFrZSB0aGUgY2xvbmVkIHB1YmxpYyBkYXRhIG9iamVjdCBhIGNvcHkgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgICAgaWYgKCBjdXJEYXRhLmRhdGEgKSB7XG4gICAgICAgICAgICBjdXJEYXRhLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyRGF0YS5kYXRhICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZml4Q2xvbmVOb2RlSXNzdWVzKCBzcmMsIGRlc3QgKSB7XG4gICAgICAgIHZhciBub2RlTmFtZSwgZSwgZGF0YTtcbiAgICBcbiAgICAgICAgLy8gV2UgZG8gbm90IG5lZWQgdG8gZG8gYW55dGhpbmcgZm9yIG5vbi1FbGVtZW50c1xuICAgICAgICBpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgICAgIC8vIElFNi04IGNvcGllcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50IHdoZW4gdXNpbmcgY2xvbmVOb2RlLlxuICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5ub0Nsb25lRXZlbnQgJiYgZGVzdFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QgKTtcbiAgICBcbiAgICAgICAgICAgIGZvciAoIGUgaW4gZGF0YS5ldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KCBkZXN0LCBlLCBkYXRhLmhhbmRsZSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG8gZ2V0cyBjb3BpZWQgdG9vXG4gICAgICAgICAgICBkZXN0LnJlbW92ZUF0dHJpYnV0ZSggalF1ZXJ5LmV4cGFuZG8gKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBJRSBibGFua3MgY29udGVudHMgd2hlbiBjbG9uaW5nIHNjcmlwdHMsIGFuZCB0cmllcyB0byBldmFsdWF0ZSBuZXdseS1zZXQgdGV4dFxuICAgICAgICBpZiAoIG5vZGVOYW1lID09PSBcInNjcmlwdFwiICYmIGRlc3QudGV4dCAhPT0gc3JjLnRleHQgKSB7XG4gICAgICAgICAgICBkaXNhYmxlU2NyaXB0KCBkZXN0ICkudGV4dCA9IHNyYy50ZXh0O1xuICAgICAgICAgICAgcmVzdG9yZVNjcmlwdCggZGVzdCApO1xuICAgIFxuICAgICAgICAvLyBJRTYtMTAgaW1wcm9wZXJseSBjbG9uZXMgY2hpbGRyZW4gb2Ygb2JqZWN0IGVsZW1lbnRzIHVzaW5nIGNsYXNzaWQuXG4gICAgICAgIC8vIElFMTAgdGhyb3dzIE5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yIGlmIHBhcmVudCBpcyBudWxsLCAjMTIxMzIuXG4gICAgICAgIH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgaWYgKCBkZXN0LnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgZGVzdC5vdXRlckhUTUwgPSBzcmMub3V0ZXJIVE1MO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gVGhpcyBwYXRoIGFwcGVhcnMgdW5hdm9pZGFibGUgZm9yIElFOS4gV2hlbiBjbG9uaW5nIGFuIG9iamVjdFxuICAgICAgICAgICAgLy8gZWxlbWVudCBpbiBJRTksIHRoZSBvdXRlckhUTUwgc3RyYXRlZ3kgYWJvdmUgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc3JjIGhhcyBpbm5lckhUTUwgYW5kIHRoZSBkZXN0aW5hdGlvbiBkb2VzIG5vdCxcbiAgICAgICAgICAgIC8vIGNvcHkgdGhlIHNyYy5pbm5lckhUTUwgaW50byB0aGUgZGVzdC5pbm5lckhUTUwuICMxMDMyNFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lICYmICggc3JjLmlubmVySFRNTCAmJiAhalF1ZXJ5LnRyaW0oZGVzdC5pbm5lckhUTUwpICkgKSB7XG4gICAgICAgICAgICAgICAgZGVzdC5pbm5lckhUTUwgPSBzcmMuaW5uZXJIVE1MO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIG1hbmlwdWxhdGlvbl9yY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuICAgICAgICAgICAgLy8gSUU2LTggZmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveFxuICAgICAgICAgICAgLy8gb3IgcmFkaW8gYnV0dG9uLiBXb3JzZSwgSUU2LTcgZmFpbCB0byBnaXZlIHRoZSBjbG9uZWQgZWxlbWVudFxuICAgICAgICAgICAgLy8gYSBjaGVja2VkIGFwcGVhcmFuY2UgaWYgdGhlIGRlZmF1bHRDaGVja2VkIHZhbHVlIGlzbid0IGFsc28gc2V0XG4gICAgXG4gICAgICAgICAgICBkZXN0LmRlZmF1bHRDaGVja2VkID0gZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG4gICAgXG4gICAgICAgICAgICAvLyBJRTYtNyBnZXQgY29uZnVzZWQgYW5kIGVuZCB1cCBzZXR0aW5nIHRoZSB2YWx1ZSBvZiBhIGNsb25lZFxuICAgICAgICAgICAgLy8gY2hlY2tib3gvcmFkaW8gYnV0dG9uIHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIFwib25cIlxuICAgICAgICAgICAgaWYgKCBkZXN0LnZhbHVlICE9PSBzcmMudmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgZGVzdC52YWx1ZSA9IHNyYy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gSUU2LTggZmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWRcbiAgICAgICAgLy8gc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcbiAgICAgICAgfSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgKSB7XG4gICAgICAgICAgICBkZXN0LmRlZmF1bHRTZWxlY3RlZCA9IGRlc3Quc2VsZWN0ZWQgPSBzcmMuZGVmYXVsdFNlbGVjdGVkO1xuICAgIFxuICAgICAgICAvLyBJRTYtOCBmYWlscyB0byBzZXQgdGhlIGRlZmF1bHRWYWx1ZSB0byB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuXG4gICAgICAgIC8vIGNsb25pbmcgb3RoZXIgdHlwZXMgb2YgaW5wdXQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcbiAgICAgICAgICAgIGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuICAgICAgICBwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuICAgICAgICBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG4gICAgICAgIGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG4gICAgICAgIHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxuICAgIH0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB2YXIgZWxlbXMsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXG4gICAgICAgICAgICAgICAgaW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuICAgICAgICAgICAgICAgIGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMTtcbiAgICBcbiAgICAgICAgICAgIGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCBpbnNlcnRbaV0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgY2FuIGFwcGx5IGpRdWVyeSBjb2xsZWN0aW9ucyBhcyBhcnJheXMsIGJ1dCBvbGRJRSBuZWVkcyBhIC5nZXQoKVxuICAgICAgICAgICAgICAgIGNvcmVfcHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBcbiAgICBmdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcbiAgICAgICAgdmFyIGVsZW1zLCBlbGVtLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBmb3VuZCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBjb3JlX3N0cnVuZGVmaW5lZCA/IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBjb3JlX3N0cnVuZGVmaW5lZCA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICBcbiAgICAgICAgaWYgKCAhZm91bmQgKSB7XG4gICAgICAgICAgICBmb3IgKCBmb3VuZCA9IFtdLCBlbGVtcyA9IGNvbnRleHQuY2hpbGROb2RlcyB8fCBjb250ZXh0OyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhdGFnIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgdGFnICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIGZvdW5kLCBnZXRBbGwoIGVsZW0sIHRhZyApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG4gICAgICAgICAgICBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCBmb3VuZCApIDpcbiAgICAgICAgICAgIGZvdW5kO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2VkIGluIGJ1aWxkRnJhZ21lbnQsIGZpeGVzIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wZXJ0eVxuICAgIGZ1bmN0aW9uIGZpeERlZmF1bHRDaGVja2VkKCBlbGVtICkge1xuICAgICAgICBpZiAoIG1hbmlwdWxhdGlvbl9yY2hlY2thYmxlVHlwZS50ZXN0KCBlbGVtLnR5cGUgKSApIHtcbiAgICAgICAgICAgIGVsZW0uZGVmYXVsdENoZWNrZWQgPSBlbGVtLmNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICB2YXIgZGVzdEVsZW1lbnRzLCBub2RlLCBjbG9uZSwgaSwgc3JjRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgaW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcbiAgICBcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LnN1cHBvcnQuaHRtbDVDbG9uZSB8fCBqUXVlcnkuaXNYTUxEb2MoZWxlbSkgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCBcIjxcIiArIGVsZW0ubm9kZU5hbWUgKyBcIj5cIiApICkge1xuICAgICAgICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIElFPD04IGRvZXMgbm90IHByb3Blcmx5IGNsb25lIGRldGFjaGVkLCB1bmtub3duIGVsZW1lbnQgbm9kZXNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnREaXYuaW5uZXJIVE1MID0gZWxlbS5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnREaXYucmVtb3ZlQ2hpbGQoIGNsb25lID0gZnJhZ21lbnREaXYuZmlyc3RDaGlsZCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCAoIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVFdmVudCB8fCAhalF1ZXJ5LnN1cHBvcnQubm9DbG9uZUNoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJiAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gRml4IGFsbCBJRSBjbG9uaW5nIGlzc3Vlc1xuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyAobm9kZSA9IHNyY0VsZW1lbnRzW2ldKSAhPSBudWxsOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBkZXN0aW5hdGlvbiBub2RlIGlzIG5vdCBudWxsOyBGaXhlcyAjOTU4N1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRlc3RFbGVtZW50c1tpXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeENsb25lTm9kZUlzc3Vlcyggbm9kZSwgZGVzdEVsZW1lbnRzW2ldICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG4gICAgICAgICAgICBpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IChub2RlID0gc3JjRWxlbWVudHNbaV0pICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBub2RlLCBkZXN0RWxlbWVudHNbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcbiAgICAgICAgICAgIGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBzcmNFbGVtZW50cyA9IG5vZGUgPSBudWxsO1xuICAgIFxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGJ1aWxkRnJhZ21lbnQ6IGZ1bmN0aW9uKCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uICkge1xuICAgICAgICAgICAgdmFyIGosIGVsZW0sIGNvbnRhaW5zLFxuICAgICAgICAgICAgICAgIHRtcCwgdGFnLCB0Ym9keSwgd3JhcCxcbiAgICAgICAgICAgICAgICBsID0gZWxlbXMubGVuZ3RoLFxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBhIHNhZmUgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICBzYWZlID0gY3JlYXRlU2FmZUZyYWdtZW50KCBjb250ZXh0ICksXG4gICAgXG4gICAgICAgICAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICBcbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbXNbIGkgXTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAgfHwgc2FmZS5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbXCJcIiwgXCJcIl0gKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAuaW5uZXJIVE1MID0gd3JhcFsxXSArIGVsZW0ucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICkgKyB3cmFwWzJdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gd3JhcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggai0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBhZGQgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQgYnkgSUVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggcmxlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMoIGVsZW0gKVswXSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSUUncyBhdXRvaW5zZXJ0ZWQgPHRib2R5PiBmcm9tIHRhYmxlIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQudGJvZHkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIHdhcyBhIDx0YWJsZT4sICptYXkqIGhhdmUgc3B1cmlvdXMgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0YWcgPT09IFwidGFibGVcIiAmJiAhcnRib2R5LnRlc3QoIGVsZW0gKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5maXJzdENoaWxkIDpcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIHdhcyBhIGJhcmUgPHRoZWFkPiBvciA8dGZvb3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBbMV0gPT09IFwiPHRhYmxlPlwiICYmICFydGJvZHkudGVzdCggZWxlbSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBlbGVtICYmIGVsZW0uY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBqLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5Lm5vZGVOYW1lKCAodGJvZHkgPSBlbGVtLmNoaWxkTm9kZXNbal0pLCBcInRib2R5XCIgKSAmJiAhdGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUNoaWxkKCB0Ym9keSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpeCAjMTIzOTIgZm9yIFdlYktpdCBhbmQgSUUgPiA5XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4ICMxMjM5MiBmb3Igb2xkSUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggdG1wLmZpcnN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnJlbW92ZUNoaWxkKCB0bXAuZmlyc3RDaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgZm9yIHByb3BlciBjbGVhbnVwXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBzYWZlLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEZpeCAjMTEzNTY6IENsZWFyIGVsZW1lbnRzIGZyb20gZnJhZ21lbnRcbiAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICAgIHNhZmUucmVtb3ZlQ2hpbGQoIHRtcCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gUmVzZXQgZGVmYXVsdENoZWNrZWQgZm9yIGFueSByYWRpb3MgYW5kIGNoZWNrYm94ZXNcbiAgICAgICAgICAgIC8vIGFib3V0IHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBET00gaW4gSUUgNi83ICgjODA2MClcbiAgICAgICAgICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmFwcGVuZENoZWNrZWQgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmdyZXAoIGdldEFsbCggbm9kZXMsIFwiaW5wdXRcIiApLCBmaXhEZWZhdWx0Q2hlY2tlZCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gbm9kZXNbIGkrKyBdKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgaWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdG8gZnJhZ21lbnRcbiAgICAgICAgICAgICAgICB0bXAgPSBnZXRBbGwoIHNhZmUuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRhaW5zICkge1xuICAgICAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKCB0bXAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuICAgICAgICAgICAgICAgIGlmICggc2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGVsZW0gPSB0bXBbIGorKyBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRzLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHRtcCA9IG51bGw7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gc2FmZTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgY2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMsIC8qIGludGVybmFsICovIGFjY2VwdERhdGEgKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSwgdHlwZSwgaWQsIGRhdGEsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IGpRdWVyeS5jYWNoZSxcbiAgICAgICAgICAgICAgICBkZWxldGVFeHBhbmRvID0galF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyxcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWw7XG4gICAgXG4gICAgICAgICAgICBmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGFjY2VwdERhdGEgfHwgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gaWQgJiYgY2FjaGVbIGlkIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YS5ldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjYWNoZSBvbmx5IGlmIGl0IHdhcyBub3QgYWxyZWFkeSByZW1vdmVkIGJ5IGpRdWVyeS5ldmVudC5yZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FjaGVbIGlkIF0gKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlWyBpZCBdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3IgZG9lcyBpdCBoYXZlIGEgcmVtb3ZlQXR0cmlidXRlIGZ1bmN0aW9uIG9uIERvY3VtZW50IG5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgaGFuZGxlIGFsbCBvZiB0aGVzZSBjYXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGVsZXRlRXhwYW5kbyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1bIGludGVybmFsS2V5IF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGVsZW0ucmVtb3ZlQXR0cmlidXRlICE9PSBjb3JlX3N0cnVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGludGVybmFsS2V5ICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgaW50ZXJuYWxLZXkgXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfZGVsZXRlZElkcy5wdXNoKCBpZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGlmcmFtZSwgZ2V0U3R5bGVzLCBjdXJDU1MsXG4gICAgICAgIHJhbHBoYSA9IC9hbHBoYVxcKFteKV0qXFwpL2ksXG4gICAgICAgIHJvcGFjaXR5ID0gL29wYWNpdHlcXHMqPVxccyooW14pXSopLyxcbiAgICAgICAgcnBvc2l0aW9uID0gL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvLFxuICAgICAgICAvLyBzd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuICAgICAgICAvLyBzZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcbiAgICAgICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuICAgICAgICBybWFyZ2luID0gL15tYXJnaW4vLFxuICAgICAgICBybnVtc3BsaXQgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjb3JlX3BudW0gKyBcIikoLiopJFwiLCBcImlcIiApLFxuICAgICAgICBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjb3JlX3BudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApLFxuICAgICAgICBycmVsTnVtID0gbmV3IFJlZ0V4cCggXCJeKFsrLV0pPShcIiArIGNvcmVfcG51bSArIFwiKVwiLCBcImlcIiApLFxuICAgICAgICBlbGVtZGlzcGxheSA9IHsgQk9EWTogXCJibG9ja1wiIH0sXG4gICAgXG4gICAgICAgIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuICAgICAgICBjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiAwLFxuICAgICAgICAgICAgZm9udFdlaWdodDogNDAwXG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdLFxuICAgICAgICBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdO1xuICAgIFxuICAgIC8vIHJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG5hbWUgKSB7XG4gICAgXG4gICAgICAgIC8vIHNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG4gICAgICAgIGlmICggbmFtZSBpbiBzdHlsZSApIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIGNoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcbiAgICAgICAgdmFyIGNhcE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcbiAgICAgICAgICAgIG9yaWdOYW1lID0gbmFtZSxcbiAgICAgICAgICAgIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG4gICAgXG4gICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgbmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuICAgICAgICAgICAgaWYgKCBuYW1lIGluIHN0eWxlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBvcmlnTmFtZTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaXNIaWRkZW4oIGVsZW0sIGVsICkge1xuICAgICAgICAvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcbiAgICAgICAgZWxlbSA9IGVsIHx8IGVsZW07XG4gICAgICAgIHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuICAgICAgICB2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuICAgICAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgXG4gICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG4gICAgICAgICAgICBpZiAoICFlbGVtLnN0eWxlICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdmFsdWVzWyBpbmRleCBdID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApO1xuICAgICAgICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgIGlmICggc2hvdyApIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG4gICAgICAgICAgICAgICAgLy8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuICAgICAgICAgICAgICAgIGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuICAgICAgICAgICAgICAgIC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG4gICAgICAgICAgICAgICAgLy8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGNzc19kZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3BsYXkgJiYgZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3BcbiAgICAgICAgLy8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuICAgICAgICBmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuICAgICAgICAgICAgaWYgKCAhZWxlbS5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgICBcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgY3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4sIHN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgbWFwID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IG5hbWUubGVuZ3RoO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgICAgIH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgICAgICB9LFxuICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcbiAgICAgICAgICAgIHZhciBib29sID0gdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIjtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBib29sID8gc3RhdGUgOiBpc0hpZGRlbiggdGhpcyApICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcbiAgICAgICAgY3NzSG9va3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBFeGNsdWRlIHRoZSBmb2xsb3dpbmcgY3NzIHByb3BlcnRpZXMgdG8gYWRkIHB4XG4gICAgICAgIGNzc051bWJlcjoge1xuICAgICAgICAgICAgXCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmb250V2VpZ2h0XCI6IHRydWUsXG4gICAgICAgICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcnBoYW5zXCI6IHRydWUsXG4gICAgICAgICAgICBcIndpZG93c1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcbiAgICAgICAgLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuICAgICAgICBjc3NQcm9wczoge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGZsb2F0IGNzcyBwcm9wZXJ0eVxuICAgICAgICAgICAgXCJmbG9hdFwiOiBqUXVlcnkuc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcbiAgICAgICAgICAgIHZhciByZXQsIHR5cGUsIGhvb2tzLFxuICAgICAgICAgICAgICAgIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcbiAgICBcbiAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG9yaWdOYW1lICkgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cbiAgICAgICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHJlbGF0aXZlIG51bWJlciBzdHJpbmdzICgrPSBvciAtPSkgdG8gcmVsYXRpdmUgbnVtYmVycy4gIzczNDVcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZXMgYnVnICM5MjM3XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBOYU4gYW5kIG51bGwgdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09IG51bGwgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgJ3B4JyB0byB0aGUgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFwicHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gRml4ZXMgIzg5MDgsIGl0IGNhbiBiZSBkb25lIG1vcmUgY29ycmVjdGx5IGJ5IHNwZWNpZmluZyBzZXR0ZXJzIGluIGNzc0hvb2tzLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCB3b3VsZCBtZWFuIHRvIGRlZmluZSBlaWdodCAoZm9yIGV2ZXJ5IHByb2JsZW1hdGljIHByb3BlcnR5KSBpZGVudGljYWwgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZihcImJhY2tncm91bmRcIikgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwcGVkIHRvIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBlcnJvcnMgd2hlbiAnaW52YWxpZCcgdmFsdWVzIGFyZSBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlcyBidWcgIzU1MDlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFxuICAgICAgICBjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuICAgICAgICAgICAgdmFyIG51bSwgdmFsLCBob29rcyxcbiAgICAgICAgICAgICAgICBvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBlbGVtLnN0eWxlLCBvcmlnTmFtZSApICk7XG4gICAgXG4gICAgICAgICAgICAvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcbiAgICBcbiAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcbiAgICAgICAgICAgIGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vY29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG4gICAgICAgICAgICBpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcbiAgICAgICAgICAgIGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG4gICAgICAgICAgICAgICAgbnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICAvLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zXG4gICAgICAgIHN3YXA6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcbiAgICAgICAgICAgIHZhciByZXQsIG5hbWUsXG4gICAgICAgICAgICAgICAgb2xkID0ge307XG4gICAgXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICBvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuICAgIFxuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG4gICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gTk9URTogd2UndmUgaW5jbHVkZWQgdGhlIFwid2luZG93XCIgaW4gd2luZG93LmdldENvbXB1dGVkU3R5bGVcbiAgICAvLyBiZWNhdXNlIGpzZG9tIG9uIG5vZGUuanMgd2lsbCBicmVhayB3aXRob3V0IGl0LlxuICAgIGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG4gICAgICAgIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGN1ckNTUyA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBfY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBjb21wdXRlZCA9IF9jb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKSxcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSBpbiBJRTksIHNlZSAjMTI1MzdcbiAgICAgICAgICAgICAgICByZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcbiAgICBcbiAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIDwgMTcgYW5kIFNhZmFyaSA1LjAgdXNlcyBcImNvbXB1dGVkIHZhbHVlXCIgaW5zdGVhZCBvZiBcInVzZWQgdmFsdWVcIiBmb3IgbWFyZ2luLXJpZ2h0XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDUuMS43IChhdCBsZWFzdCkgcmV0dXJucyBwZXJjZW50YWdlIGZvciBhIGxhcmdlciBzZXQgb2YgdmFsdWVzLCBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICkge1xuICAgICAgICBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgY3VyQ1NTID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIF9jb21wdXRlZCApIHtcbiAgICAgICAgICAgIHZhciBsZWZ0LCBycywgcnNMZWZ0LFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gX2NvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApLFxuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkID8gY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gICAgXG4gICAgICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIHJldCB0byBlbXB0eSBzdHJpbmcgaGVyZVxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgZGVmYXVsdCB0byBhdXRvXG4gICAgICAgICAgICBpZiAoIHJldCA9PSBudWxsICYmIHN0eWxlICYmIHN0eWxlWyBuYW1lIF0gKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gc3R5bGVbIG5hbWUgXTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcbiAgICBcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggYSByZWd1bGFyIHBpeGVsIG51bWJlclxuICAgICAgICAgICAgLy8gYnV0IGEgbnVtYmVyIHRoYXQgaGFzIGEgd2VpcmQgZW5kaW5nLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gcGl4ZWxzXG4gICAgICAgICAgICAvLyBidXQgbm90IHBvc2l0aW9uIGNzcyBhdHRyaWJ1dGVzLCBhcyB0aG9zZSBhcmUgcHJvcG9ydGlvbmFsIHRvIHRoZSBwYXJlbnQgZWxlbWVudCBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBhbmQgd2UgY2FuJ3QgbWVhc3VyZSB0aGUgcGFyZW50IGluc3RlYWQgYmVjYXVzZSBpdCBtaWdodCB0cmlnZ2VyIGEgXCJzdGFja2luZyBkb2xsc1wiIHByb2JsZW1cbiAgICAgICAgICAgIGlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmICFycG9zaXRpb24udGVzdCggbmFtZSApICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBsZWZ0ID0gc3R5bGUubGVmdDtcbiAgICAgICAgICAgICAgICBycyA9IGVsZW0ucnVudGltZVN0eWxlO1xuICAgICAgICAgICAgICAgIHJzTGVmdCA9IHJzICYmIHJzLmxlZnQ7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgICAgICAgICAgICAgIGlmICggcnNMZWZ0ICkge1xuICAgICAgICAgICAgICAgICAgICBycy5sZWZ0ID0gZWxlbS5jdXJyZW50U3R5bGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiByZXQ7XG4gICAgICAgICAgICAgICAgcmV0ID0gc3R5bGUucGl4ZWxMZWZ0ICsgXCJweFwiO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICBpZiAoIHJzTGVmdCApIHtcbiAgICAgICAgICAgICAgICAgICAgcnMubGVmdCA9IHJzTGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gXCJhdXRvXCIgOiByZXQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG4gICAgICAgIHJldHVybiBtYXRjaGVzID9cbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG4gICAgICAgICAgICBNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcbiAgICAgICAgICAgIHZhbHVlO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG4gICAgICAgIHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cbiAgICAgICAgICAgIDQgOlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuICAgICAgICAgICAgbmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG4gICAgXG4gICAgICAgICAgICB2YWwgPSAwO1xuICAgIFxuICAgICAgICBmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG4gICAgICAgICAgICAvLyBib3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG4gICAgICAgICAgICBpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuICAgICAgICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICggaXNCb3JkZXJCb3ggKSB7XG4gICAgICAgICAgICAgICAgLy8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG4gICAgICAgICAgICAgICAgaWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcbiAgICAgICAgICAgICAgICBpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgdmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcbiAgICAgICAgICAgICAgICBpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuICAgIFxuICAgICAgICAvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG4gICAgICAgICAgICB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcbiAgICAgICAgICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LnN1cHBvcnQuYm94U2l6aW5nICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG4gICAgXG4gICAgICAgIC8vIHNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuICAgICAgICAvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcbiAgICAgICAgLy8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG4gICAgICAgIGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG4gICAgICAgICAgICBpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cbiAgICAgICAgICAgIGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcbiAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiAoIGpRdWVyeS5zdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG4gICAgXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG4gICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIHVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG4gICAgICAgIHJldHVybiAoIHZhbCArXG4gICAgICAgICAgICBhdWdtZW50V2lkdGhPckhlaWdodChcbiAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuICAgICAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3gsXG4gICAgICAgICAgICAgICAgc3R5bGVzXG4gICAgICAgICAgICApXG4gICAgICAgICkgKyBcInB4XCI7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gICAgZnVuY3Rpb24gY3NzX2RlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcbiAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LFxuICAgICAgICAgICAgZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuICAgIFxuICAgICAgICBpZiAoICFkaXNwbGF5ICkge1xuICAgICAgICAgICAgZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuICAgICAgICAgICAgaWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBpZnJhbWUgPSAoIGlmcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIpXG4gICAgICAgICAgICAgICAgICAgIC5jc3MoIFwiY3NzVGV4dFwiLCBcImRpc3BsYXk6YmxvY2sgIWltcG9ydGFudFwiIClcbiAgICAgICAgICAgICAgICApLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG4gICAgICAgICAgICAgICAgZG9jID0gKCBpZnJhbWVbMF0uY29udGVudFdpbmRvdyB8fCBpZnJhbWVbMF0uY29udGVudERvY3VtZW50ICkuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgZG9jLndyaXRlKFwiPCFkb2N0eXBlIGh0bWw+PGh0bWw+PGJvZHk+XCIpO1xuICAgICAgICAgICAgICAgIGRvYy5jbG9zZSgpO1xuICAgIFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG4gICAgICAgICAgICAgICAgaWZyYW1lLmRldGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG4gICAgICAgICAgICBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIGRpc3BsYXk7XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGxlZCBPTkxZIGZyb20gd2l0aGluIGNzc19kZWZhdWx0RGlzcGxheVxuICAgIGZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHtcbiAgICAgICAgdmFyIGVsZW0gPSBqUXVlcnkoIGRvYy5jcmVhdGVFbGVtZW50KCBuYW1lICkgKS5hcHBlbmRUbyggZG9jLmJvZHkgKSxcbiAgICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtWzBdLCBcImRpc3BsYXlcIiApO1xuICAgICAgICBlbGVtLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gZGlzcGxheTtcbiAgICB9XG4gICAgXG4gICAgalF1ZXJ5LmVhY2goWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG4gICAgICAgIGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyBob3dldmVyLCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0IGZyb20gdGhpc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCAmJiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgZXh0cmEgP1xuICAgICAgICAgICAgICAgICAgICBhdWdtZW50V2lkdGhPckhlaWdodChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3VwcG9ydC5ib3hTaXppbmcgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICApIDogMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQub3BhY2l0eSApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzLm9wYWNpdHkgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9wYWNpdHkudGVzdCggKGNvbXB1dGVkICYmIGVsZW0uY3VycmVudFN0eWxlID8gZWxlbS5jdXJyZW50U3R5bGUuZmlsdGVyIDogZWxlbS5zdHlsZS5maWx0ZXIpIHx8IFwiXCIgKSA/XG4gICAgICAgICAgICAgICAgICAgICggMC4wMSAqIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApICkgKyBcIlwiIDpcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQgPyBcIjFcIiA6IFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZWxlbS5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlID0gZWxlbS5jdXJyZW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBqUXVlcnkuaXNOdW1lcmljKCB2YWx1ZSApID8gXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGN1cnJlbnRTdHlsZSAmJiBjdXJyZW50U3R5bGUuZmlsdGVyIHx8IHN0eWxlLmZpbHRlciB8fCBcIlwiO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGl0IGJ5IHNldHRpbmcgdGhlIHpvb20gbGV2ZWxcbiAgICAgICAgICAgICAgICBzdHlsZS56b29tID0gMTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBpZiBzZXR0aW5nIG9wYWNpdHkgdG8gMSwgYW5kIG5vIG90aGVyIGZpbHRlcnMgZXhpc3QgLSBhdHRlbXB0IHRvIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICM2NjUyXG4gICAgICAgICAgICAgICAgLy8gaWYgdmFsdWUgPT09IFwiXCIsIHRoZW4gcmVtb3ZlIGlubGluZSBvcGFjaXR5ICMxMjY4NVxuICAgICAgICAgICAgICAgIGlmICggKCB2YWx1ZSA+PSAxIHx8IHZhbHVlID09PSBcIlwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS50cmltKCBmaWx0ZXIucmVwbGFjZSggcmFscGhhLCBcIlwiICkgKSA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHN0eWxlLmZpbHRlciB0byBudWxsLCBcIlwiICYgXCIgXCIgc3RpbGwgbGVhdmUgXCJmaWx0ZXI6XCIgaW4gdGhlIGNzc1RleHRcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgXCJmaWx0ZXI6XCIgaXMgcHJlc2VudCBhdCBhbGwsIGNsZWFyVHlwZSBpcyBkaXNhYmxlZCwgd2Ugd2FudCB0byBhdm9pZCB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSBpcyBJRSBPbmx5LCBidXQgc28gYXBwYXJlbnRseSBpcyB0aGlzIGNvZGUgcGF0aC4uLlxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoIFwiZmlsdGVyXCIgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZmlsdGVyIHN0eWxlIGFwcGxpZWQgaW4gYSBjc3MgcnVsZSBvciB1bnNldCBpbmxpbmUgb3BhY2l0eSwgd2UgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gXCJcIiB8fCBjdXJyZW50U3R5bGUgJiYgIWN1cnJlbnRTdHlsZS5maWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBzZXQgbmV3IGZpbHRlciB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzdHlsZS5maWx0ZXIgPSByYWxwaGEudGVzdCggZmlsdGVyICkgP1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIucmVwbGFjZSggcmFscGhhLCBvcGFjaXR5ICkgOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgKyBcIiBcIiArIG9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFRoZXNlIGhvb2tzIGNhbm5vdCBiZSBhZGRlZCB1bnRpbCBET00gcmVhZHkgYmVjYXVzZSB0aGUgc3VwcG9ydCB0ZXN0XG4gICAgLy8gZm9yIGl0IGlzIG5vdCBydW4gdW50aWwgYWZ0ZXIgRE9NIHJlYWR5XG4gICAgalF1ZXJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0ICkge1xuICAgICAgICAgICAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBieSB0ZW1wb3JhcmlseSBzZXR0aW5nIGVsZW1lbnQgZGlzcGxheSB0byBpbmxpbmUtYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbiAgICAgICAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodFxuICAgICAgICAvLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwgd2UganVzdCBjaGVjayBmb3IgaXQgaGVyZVxuICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5waXhlbFBvc2l0aW9uICYmIGpRdWVyeS5mbi5wb3NpdGlvbiApIHtcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIFxuICAgIH0pO1xuICAgIFxuICAgIGlmICggalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycyApIHtcbiAgICAgICAgalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG4gICAgICAgICAgICAvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA8PSAwICYmIGVsZW0ub2Zmc2V0SGVpZ2h0IDw9IDAgfHxcbiAgICAgICAgICAgICAgICAoIWpRdWVyeS5zdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyAmJiAoKGVsZW0uc3R5bGUgJiYgZWxlbS5zdHlsZS5kaXNwbGF5KSB8fCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApKSA9PT0gXCJub25lXCIpO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICBqUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgbWFyZ2luOiBcIlwiLFxuICAgICAgICBwYWRkaW5nOiBcIlwiLFxuICAgICAgICBib3JkZXI6IFwiV2lkdGhcIlxuICAgIH0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcbiAgICAgICAgICAgIGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSB7fSxcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoXCIgXCIpIDogWyB2YWx1ZSBdO1xuICAgIFxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG4gICAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHIyMCA9IC8lMjAvZyxcbiAgICAgICAgcmJyYWNrZXQgPSAvXFxbXFxdJC8sXG4gICAgICAgIHJDUkxGID0gL1xccj9cXG4vZyxcbiAgICAgICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuICAgICAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG4gICAgXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLy8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgLy8gVXNlIC5pcyhcIjpkaXNhYmxlZFwiKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgcnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIHRoaXMuY2hlY2tlZCB8fCAhbWFuaXB1bGF0aW9uX3JjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oIGksIGVsZW0gKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuICAgICAgICAgICAgfSkuZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvL1NlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4gICAgLy9rZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbiAgICBqUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG4gICAgICAgIHZhciBwcmVmaXgsXG4gICAgICAgICAgICBzID0gW10sXG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuICAgICAgICBpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgICAgICBpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG4gICAgICAgICAgICBqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgICAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgICAgICAgZm9yICggcHJlZml4IGluIGEgKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG4gICAgICAgIHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICBcbiAgICAgICAgaWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuICAgICAgICAgICAgICAgIGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICAgICAgICAgICAgYWRkKCBwcmVmaXgsIHYgKTtcbiAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICB9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuICAgICAgICAgICAgZm9yICggbmFtZSBpbiBvYmogKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuICAgICAgICAgICAgYWRkKCBwcmVmaXgsIG9iaiApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG4gICAgICAgIFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuICAgICAgICBcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICBcbiAgICAgICAgLy8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgIHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciggbmFtZSApO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIGpRdWVyeS5mbi5ob3ZlciA9IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcbiAgICB9O1xuICAgIHZhclxuICAgICAgICAvLyBEb2N1bWVudCBsb2NhdGlvblxuICAgICAgICBhamF4TG9jUGFydHMsXG4gICAgICAgIGFqYXhMb2NhdGlvbixcbiAgICAgICAgYWpheF9ub25jZSA9IGpRdWVyeS5ub3coKSxcbiAgICBcbiAgICAgICAgYWpheF9ycXVlcnkgPSAvXFw/LyxcbiAgICAgICAgcmhhc2ggPSAvIy4qJC8sXG4gICAgICAgIHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcbiAgICAgICAgcmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKilcXHI/JC9tZywgLy8gSUUgbGVhdmVzIGFuIFxcciBjaGFyYWN0ZXIgYXQgRU9MXG4gICAgICAgIC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuICAgICAgICBybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuICAgICAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcbiAgICAgICAgcnByb3RvY29sID0gL15cXC9cXC8vLFxuICAgICAgICBydXJsID0gL14oW1xcdy4rLV0rOikoPzpcXC9cXC8oW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXG4gICAgXG4gICAgICAgIC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbiAgICAgICAgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZCxcbiAgICBcbiAgICAgICAgLyogUHJlZmlsdGVyc1xuICAgICAgICAgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuICAgICAgICAgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuICAgICAgICAgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG4gICAgICAgICAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcbiAgICAgICAgICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuICAgICAgICAgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG4gICAgICAgICAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG4gICAgICAgICAqL1xuICAgICAgICBwcmVmaWx0ZXJzID0ge30sXG4gICAgXG4gICAgICAgIC8qIFRyYW5zcG9ydHMgYmluZGluZ3NcbiAgICAgICAgICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuICAgICAgICAgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG4gICAgICAgICAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNwb3J0cyA9IHt9LFxuICAgIFxuICAgICAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cbiAgICAgICAgYWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KFwiKlwiKTtcbiAgICBcbiAgICAvLyAjODEzOCwgSUUgbWF5IHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuICAgIC8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldFxuICAgIHRyeSB7XG4gICAgICAgIGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWY7XG4gICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgLy8gVXNlIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiBhbiBBIGVsZW1lbnRcbiAgICAgICAgLy8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cbiAgICAgICAgYWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcbiAgICAgICAgYWpheExvY2F0aW9uLmhyZWYgPSBcIlwiO1xuICAgICAgICBhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcbiAgICB9XG4gICAgXG4gICAgLy8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG4gICAgYWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuICAgIFxuICAgIC8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbiAgICBmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcbiAgICBcbiAgICAgICAgLy8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcbiAgICBcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdmFyIGRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtdO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB3aGlsZSAoIChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhVHlwZVswXSA9PT0gXCIrXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS51bnNoaWZ0KCBmdW5jICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnB1c2goIGZ1bmMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG4gICAgZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcbiAgICBcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHt9LFxuICAgICAgICAgICAgc2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgICAgaW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcbiAgICAgICAgICAgICAgICBpZiggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiYgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG4gICAgICAgICAgICAgICAgICAgIGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4gICAgLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbiAgICAvLyBGaXhlcyAjOTg4N1xuICAgIGZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuICAgICAgICB2YXIgZGVlcCwga2V5LFxuICAgICAgICAgICAgZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuICAgIFxuICAgICAgICBmb3IgKCBrZXkgaW4gc3JjICkge1xuICAgICAgICAgICAgaWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgKCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKGRlZXAgPSB7fSkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBkZWVwICkge1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgXG4gICAgalF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuICAgICAgICBpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHZhciBzZWxlY3RvciwgcmVzcG9uc2UsIHR5cGUsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcbiAgICBcbiAgICAgICAgaWYgKCBvZmYgPj0gMCApIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gdXJsLnNsaWNlKCBvZmYsIHVybC5sZW5ndGggKTtcbiAgICAgICAgICAgIHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gSWYgaXQncyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuICAgIFxuICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgIFxuICAgICAgICAvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG4gICAgICAgIH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgdHlwZSA9IFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG4gICAgICAgIGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgalF1ZXJ5LmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgIFxuICAgICAgICAgICAgICAgIC8vIGlmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImh0bWxcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFyZ3VtZW50cztcbiAgICBcbiAgICAgICAgICAgICAgICBzZWxmLmh0bWwoIHNlbGVjdG9yID9cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoXCI8ZGl2PlwiKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCApO1xuICAgIFxuICAgICAgICAgICAgfSkuY29tcGxldGUoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuICAgICAgICAgICAgICAgIHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXG4gICAgLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbiAgICBqUXVlcnkuZWFjaCggWyBcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICl7XG4gICAgICAgIGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBcbiAgICBqUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuICAgICAgICBqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG4gICAgICAgICAgICAvLyBzaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgXG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuICAgICAgICBhY3RpdmU6IDAsXG4gICAgXG4gICAgICAgIC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3RcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB7fSxcbiAgICAgICAgZXRhZzoge30sXG4gICAgXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgICAgICAgdXJsOiBhamF4TG9jYXRpb24sXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgaXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcbiAgICAgICAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBudWxsLFxuICAgICAgICAgICAgdXNlcm5hbWU6IG51bGwsXG4gICAgICAgICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgICAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgICAgICAgdGhyb3dzOiBmYWxzZSxcbiAgICAgICAgICAgIHRyYWRpdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgKi9cbiAgICBcbiAgICAgICAgICAgIGFjY2VwdHM6IHtcbiAgICAgICAgICAgICAgICBcIipcIjogYWxsVHlwZXMsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgICAgICAgICAgaHRtbDogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgICAgICAgICB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuICAgICAgICAgICAgICAgIGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBjb250ZW50czoge1xuICAgICAgICAgICAgICAgIHhtbDogL3htbC8sXG4gICAgICAgICAgICAgICAgaHRtbDogL2h0bWwvLFxuICAgICAgICAgICAgICAgIGpzb246IC9qc29uL1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIHJlc3BvbnNlRmllbGRzOiB7XG4gICAgICAgICAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJyZXNwb25zZVRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIERhdGEgY29udmVydGVyc1xuICAgICAgICAgICAgLy8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgY29udmVydGVyczoge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuICAgICAgICAgICAgICAgIFwiKiB0ZXh0XCI6IHdpbmRvdy5TdHJpbmcsXG4gICAgXG4gICAgICAgICAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuICAgICAgICAgICAgICAgIFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcbiAgICAgICAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG4gICAgICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcbiAgICAgICAgICAgIGZsYXRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLy8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcbiAgICAgICAgLy8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuICAgICAgICAvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuICAgICAgICBhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzID9cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG4gICAgICAgICAgICAgICAgYWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuICAgICAgICBhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcbiAgICBcbiAgICAgICAgLy8gTWFpbiBtZXRob2RcbiAgICAgICAgYWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcbiAgICBcbiAgICAgICAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXG4gICAgICAgICAgICB2YXIgLy8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG4gICAgICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgLy8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuICAgICAgICAgICAgICAgIGNhY2hlVVJMLFxuICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnMgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuICAgICAgICAgICAgICAgIC8vIHRpbWVvdXQgaGFuZGxlXG4gICAgICAgICAgICAgICAgdGltZW91dFRpbWVyLFxuICAgIFxuICAgICAgICAgICAgICAgIC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgICAgIGZpcmVHbG9iYWxzLFxuICAgIFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgICAgICBzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcbiAgICAgICAgICAgICAgICAvLyBDYWxsYmFja3MgY29udGV4dFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudCxcbiAgICAgICAgICAgICAgICAvLyBEZWZlcnJlZHNcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuICAgICAgICAgICAgICAgIC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnMgPSB7fSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG4gICAgICAgICAgICAgICAgLy8gVGhlIGpxWEhSIHN0YXRlXG4gICAgICAgICAgICAgICAgc3RhdGUgPSAwLFxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuICAgICAgICAgICAgICAgIC8vIEZha2UgeGhyXG4gICAgICAgICAgICAgICAganFYSFIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhdyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXN0YXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXN0YXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMubWltZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgPCAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBjb2RlIGluIG1hcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSggMCwgZmluYWxUZXh0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAvLyBBdHRhY2ggZGVmZXJyZWRzXG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG4gICAgICAgICAgICBqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcbiAgICAgICAgICAgIGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcbiAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuICAgICAgICAgICAgLy8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAoIzU4NjY6IElFNyBpc3N1ZSB3aXRoIHByb3RvY29sLWxlc3MgdXJscylcbiAgICAgICAgICAgIC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG4gICAgICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBhamF4TG9jYXRpb24gKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApLnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuICAgICAgICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcbiAgICBcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcbiAgICAgICAgICAgIHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBjb3JlX3Jub3R3aGl0ZSApIHx8IFtcIlwiXTtcbiAgICBcbiAgICAgICAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB3ZSBoYXZlIGEgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoXG4gICAgICAgICAgICBpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuICAgICAgICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKCBwYXJ0c1sgMSBdICE9PSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9PSBhamF4TG9jUGFydHNbIDIgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMgKSApICE9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhamF4TG9jUGFydHNbIDMgXSB8fCAoIGFqYXhMb2NQYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyA4MCA6IDQ0MyApICkgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gQXBwbHkgcHJlZmlsdGVyc1xuICAgICAgICAgICAgaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG4gICAgXG4gICAgICAgICAgICAvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuICAgICAgICAgICAgZmlyZUdsb2JhbHMgPSBzLmdsb2JhbDtcbiAgICBcbiAgICAgICAgICAgIC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gVXBwZXJjYXNlIHRoZSB0eXBlXG4gICAgICAgICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcbiAgICBcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG4gICAgICAgICAgICBzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuICAgICAgICAgICAgLy8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG4gICAgICAgICAgICBjYWNoZVVSTCA9IHMudXJsO1xuICAgIFxuICAgICAgICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICggIXMuaGFzQ29udGVudCApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG4gICAgICAgICAgICAgICAgaWYgKCBzLmRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVVJMID0gKCBzLnVybCArPSAoIGFqYXhfcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcy5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcy51cmwgPSBydHMudGVzdCggY2FjaGVVUkwgKSA/XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIGFqYXhfbm9uY2UrKyApIDpcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlVVJMICsgKCBhamF4X3JxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgYWpheF9ub25jZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG4gICAgICAgICAgICBpZiAoIHMuaWZNb2RpZmllZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuICAgICAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcbiAgICAgICAgICAgIGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcbiAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgICAgICAgXCJBY2NlcHRcIixcbiAgICAgICAgICAgICAgICBzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSA/XG4gICAgICAgICAgICAgICAgICAgIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSArICggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG4gICAgICAgICAgICAgICAgICAgIHMuYWNjZXB0c1sgXCIqXCIgXVxuICAgICAgICAgICAgKTtcbiAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuICAgICAgICAgICAgZm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcbiAgICAgICAgICAgIGlmICggcy5iZWZvcmVTZW5kICYmICggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIGFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuICAgICAgICAgICAgc3RyQWJvcnQgPSBcImFib3J0XCI7XG4gICAgXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcbiAgICAgICAgICAgIGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcbiAgICAgICAgICAgICAgICBqcVhIUlsgaSBdKCBzWyBpIF0gKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEdldCB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuICAgIFxuICAgICAgICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG4gICAgICAgICAgICBpZiAoICF0cmFuc3BvcnQgKSB7XG4gICAgICAgICAgICAgICAgZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IDE7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU2VuZCBnbG9iYWwgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAoIGZpcmVHbG9iYWxzICkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGltZW91dFxuICAgICAgICAgICAgICAgIGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCBzLnRpbWVvdXQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlIDwgMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoIC0xLCBlICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQ2FsbGVkIG9uY2VcbiAgICAgICAgICAgICAgICBpZiAoIHN0YXRlID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICggdGltZW91dFRpbWVyICkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlYWR5U3RhdGVcbiAgICAgICAgICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIEdldCByZXNwb25zZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKCByZXNwb25zZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuICAgICAgICAgICAgICAgIGlmICggc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcy5pZk1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtb2RpZmllZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0dXMgPT09IDIwNCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gaXNTdWNjZXNzLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGlzU3VjY2Vzcy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBpc1N1Y2Nlc3MuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSAhZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBleHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIG5vcm1hbGl6ZSBzdGF0dXNUZXh0IGFuZCBzdGF0dXMgZm9yIG5vbi1hYm9ydHNcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXR1cyA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxuICAgICAgICAgICAgICAgIGlmICggaXNTdWNjZXNzICkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGZpcmVHbG9iYWxzICkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGZpcmVHbG9iYWxzICkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZ2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAgICAgKiAtIHNldHMgYWxsIHJlc3BvbnNlWFhYIGZpZWxkcyBhY2NvcmRpbmdseVxuICAgICAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gICAgICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcbiAgICAgICAgdmFyIGZpcnN0RGF0YVR5cGUsIGN0LCBmaW5hbERhdGFUeXBlLCB0eXBlLFxuICAgICAgICAgICAgY29udGVudHMgPSBzLmNvbnRlbnRzLFxuICAgICAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMsXG4gICAgICAgICAgICByZXNwb25zZUZpZWxkcyA9IHMucmVzcG9uc2VGaWVsZHM7XG4gICAgXG4gICAgICAgIC8vIEZpbGwgcmVzcG9uc2VYWFggZmllbGRzXG4gICAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VGaWVsZHMgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgIGpxWEhSWyByZXNwb25zZUZpZWxkc1t0eXBlXSBdID0gcmVzcG9uc2VzWyB0eXBlIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgd2hpbGUoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcbiAgICAgICAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcbiAgICAgICAgaWYgKCBjdCApIHtcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuICAgICAgICBpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgIGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCAhZmlyc3REYXRhVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcbiAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICAgICAgICBpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG4gICAgICAgICAgICBpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICAgIGZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSApIHtcbiAgICAgICAgdmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsXG4gICAgICAgICAgICBjb252ZXJ0ZXJzID0ge30sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cbiAgICAgICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCksXG4gICAgICAgICAgICBwcmV2ID0gZGF0YVR5cGVzWyAwIF07XG4gICAgXG4gICAgICAgIC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICggcy5kYXRhRmlsdGVyICkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG4gICAgICAgIGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG4gICAgICAgICAgICBmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlLCB0b2xlcmF0aW5nIGxpc3QgbW9kaWZpY2F0aW9uXG4gICAgICAgIGZvciAoIDsgKGN1cnJlbnQgPSBkYXRhVHlwZXNbKytpXSk7ICkge1xuICAgIFxuICAgICAgICAgICAgLy8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuICAgICAgICAgICAgaWYgKCBjdXJyZW50ICE9PSBcIipcIiApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG4gICAgICAgICAgICAgICAgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhY29udiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gY29udjIuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdG1wWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnNwbGljZSggaS0tLCAwLCBjdXJyZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ICE9PSB0cnVlICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ICYmIHNbXCJ0aHJvd3NcIl0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcHJldiBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG4gICAgfVxuICAgIC8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XG4gICAgICAgIGFjY2VwdHM6IHtcbiAgICAgICAgICAgIHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgICAgICBzY3JpcHQ6IC8oPzpqYXZhfGVjbWEpc2NyaXB0L1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGdsb2JhbFxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcbiAgICAgICAgaWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBzLmNhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBzLmNyb3NzRG9tYWluICkge1xuICAgICAgICAgICAgcy50eXBlID0gXCJHRVRcIjtcbiAgICAgICAgICAgIHMuZ2xvYmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbiAgICBqUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24ocykge1xuICAgIFxuICAgICAgICAvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG4gICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiApIHtcbiAgICBcbiAgICAgICAgICAgIHZhciBzY3JpcHQsXG4gICAgICAgICAgICAgICAgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgalF1ZXJ5KFwiaGVhZFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgIFxuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKCBfLCBjYWxsYmFjayApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzLnNjcmlwdENoYXJzZXQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQuY2hhcnNldCA9IHMuc2NyaXB0Q2hhcnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc3JjID0gcy51cmw7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgYWxsIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzQWJvcnQgfHwgIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoIHNjcmlwdC5yZWFkeVN0YXRlICkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1lbW9yeSBsZWFrIGluIElFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzY3JpcHQucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsYmFjayBpZiBub3QgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0Fib3J0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggMjAwLCBcInN1Y2Nlc3NcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2lyY3VtdmVudCBJRTYgYnVncyB3aXRoIGJhc2UgZWxlbWVudHMgKCMyNzA5IGFuZCAjNDM3OCkgYnkgcHJlcGVuZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcbiAgICAgICAgICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoIHNjcmlwdCwgaGVhZC5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NyaXB0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCggdW5kZWZpbmVkLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuICAgICAgICByanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuICAgIFxuICAgIC8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbiAgICBqUXVlcnkuYWpheFNldHVwKHtcbiAgICAgICAganNvbnA6IFwiY2FsbGJhY2tcIixcbiAgICAgICAganNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBhamF4X25vbmNlKysgKSApO1xuICAgICAgICAgICAgdGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcbiAgICBcbiAgICAgICAgdmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuICAgICAgICAgICAganNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cbiAgICAgICAgICAgICAgICBcInVybFwiIDpcbiAgICAgICAgICAgICAgICB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmICEoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgJiYgcmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG4gICAgICAgICAgICApO1xuICAgIFxuICAgICAgICAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG4gICAgICAgIGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuICAgIFxuICAgICAgICAgICAgLy8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuICAgICAgICAgICAgY2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cbiAgICAgICAgICAgICAgICBzLmpzb25wQ2FsbGJhY2soKSA6XG4gICAgICAgICAgICAgICAgcy5qc29ucENhbGxiYWNrO1xuICAgIFxuICAgICAgICAgICAgLy8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuICAgICAgICAgICAgaWYgKCBqc29uUHJvcCApIHtcbiAgICAgICAgICAgICAgICBzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcy51cmwgKz0gKCBhamF4X3JxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuICAgICAgICAgICAgcy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcbiAgICAgICAgICAgIHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcbiAgICBcbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tcbiAgICAgICAgICAgIG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcbiAgICAgICAgICAgIHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcbiAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgd2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFNhdmUgYmFjayBhcyBmcmVlXG4gICAgICAgICAgICAgICAgaWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG4gICAgICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgICAgICAgICAgICBvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuICAgICAgICAgICAgICAgIGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuICAgICAgICAgICAgcmV0dXJuIFwic2NyaXB0XCI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgeGhyQ2FsbGJhY2tzLCB4aHJTdXBwb3J0ZWQsXG4gICAgICAgIHhocklkID0gMCxcbiAgICAgICAgLy8gIzUyODA6IEludGVybmV0IEV4cGxvcmVyIHdpbGwga2VlcCBjb25uZWN0aW9ucyBhbGl2ZSBpZiB3ZSBkb24ndCBhYm9ydCBvbiB1bmxvYWRcbiAgICAgICAgeGhyT25VbmxvYWRBYm9ydCA9IHdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQWJvcnQgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKCBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuICAgICAgICAgICAgICAgIHhockNhbGxiYWNrc1sga2V5IF0oIHVuZGVmaW5lZCwgdHJ1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgIC8vIEZ1bmN0aW9ucyB0byBjcmVhdGUgeGhyc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkWEhSKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVhIUigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAvLyAoVGhpcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBhamF4U2V0dGluZ3MgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCA/XG4gICAgICAgIC8qIE1pY3Jvc29mdCBmYWlsZWQgdG8gcHJvcGVybHlcbiAgICAgICAgICogaW1wbGVtZW50IHRoZSBYTUxIdHRwUmVxdWVzdCBpbiBJRTcgKGNhbid0IHJlcXVlc3QgbG9jYWwgZmlsZXMpLFxuICAgICAgICAgKiBzbyB3ZSB1c2UgdGhlIEFjdGl2ZVhPYmplY3Qgd2hlbiBpdCBpcyBhdmFpbGFibGVcbiAgICAgICAgICogQWRkaXRpb25hbGx5IFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBpbiBJRTcvSUU4IHNvXG4gICAgICAgICAqIHdlIG5lZWQgYSBmYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzTG9jYWwgJiYgY3JlYXRlU3RhbmRhcmRYSFIoKSB8fCBjcmVhdGVBY3RpdmVYSFIoKTtcbiAgICAgICAgfSA6XG4gICAgICAgIC8vIEZvciBhbGwgb3RoZXIgYnJvd3NlcnMsIHVzZSB0aGUgc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIGNyZWF0ZVN0YW5kYXJkWEhSO1xuICAgIFxuICAgIC8vIERldGVybWluZSBzdXBwb3J0IHByb3BlcnRpZXNcbiAgICB4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuICAgIGpRdWVyeS5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG4gICAgeGhyU3VwcG9ydGVkID0galF1ZXJ5LnN1cHBvcnQuYWpheCA9ICEheGhyU3VwcG9ydGVkO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0cmFuc3BvcnQgaWYgdGhlIGJyb3dzZXIgY2FuIHByb3ZpZGUgYW4geGhyXG4gICAgaWYgKCB4aHJTdXBwb3J0ZWQgKSB7XG4gICAgXG4gICAgICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBzICkge1xuICAgICAgICAgICAgLy8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuICAgICAgICAgICAgaWYgKCAhcy5jcm9zc0RvbWFpbiB8fCBqUXVlcnkuc3VwcG9ydC5jb3JzICkge1xuICAgIFxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjaztcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgeGhyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlLCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhociA9IHMueGhyKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIHRoZSBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3NpbmcgbnVsbCB1c2VybmFtZSwgZ2VuZXJhdGVzIGEgbG9naW4gcG9wdXAgb24gT3BlcmEgKCMyODY1KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzLnVzZXJuYW1lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jLCBzLnVzZXJuYW1lLCBzLnBhc3N3b3JkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHMueGhyRmllbGRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gcy54aHJGaWVsZHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoclsgaSBdID0gcy54aHJGaWVsZHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoIHMubWltZVR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCBhbiBleHRyYSB0cnkvY2F0Y2ggZm9yIGNyb3NzIGRvbWFpbiByZXF1ZXN0cyBpbiBGaXJlZm94IDNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSBpbiBoZWFkZXJzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCggZXJyICkge31cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIHNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbiB3aGljaCBpcyBhY3R1YWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlZCBpbiBqUXVlcnkuYWpheCAoc28gbm8gdHJ5L2NhdGNoIGhlcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCggKCBzLmhhc0NvbnRlbnQgJiYgcy5kYXRhICkgfHwgbnVsbCApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cywgcmVzcG9uc2VIZWFkZXJzLCBzdGF0dXNUZXh0LCByZXNwb25zZXM7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgZXhjZXB0aW9ucyB3aGVuIGFjY2Vzc2luZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYW4geGhyIHdoZW4gYSBuZXR3b3JrIGVycm9yIG9jY3VycmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2hlbHBmdWwua25vYnMtZGlhbHMuY29tL2luZGV4LnBocC9Db21wb25lbnRfcmV0dXJuZWRfZmFpbHVyZV9jb2RlOl8weDgwMDQwMTExXyhOU19FUlJPUl9OT1RfQVZBSUxBQkxFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhcyBuZXZlciBjYWxsZWQgYW5kIGlzIGFib3J0ZWQgb3IgY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayAmJiAoIGlzQWJvcnQgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDQgKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY2FsbGVkIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGtlZXAgYXMgYWN0aXZlIGFueW1vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaGFuZGxlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBqUXVlcnkubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHhock9uVW5sb2FkQWJvcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB4aHJDYWxsYmFja3NbIGhhbmRsZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYW4gYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNBYm9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBpdCBtYW51YWxseSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmVxdWVzdGluZyBiaW5hcnkgZGF0YSwgSUU2LTkgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgcmVzcG9uc2VUZXh0ICgjMTE0MjYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzLnRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0dXNUZXh0IGZvciBmYXVsdHkgY3Jvc3MtZG9tYWluIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5vcm1hbGl6ZSB3aXRoIFdlYmtpdCBnaXZpbmcgYW4gZW1wdHkgc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIHN0YXR1cyBmb3Igbm9uIHN0YW5kYXJkIGJlaGF2aW9yc1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzIGxvY2FsIGFuZCB3ZSBoYXZlIGRhdGE6IGFzc3VtZSBhIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoc3VjY2VzcyB3aXRoIG5vIGRhdGEgd29uJ3QgZ2V0IG5vdGlmaWVkLCB0aGF0J3MgdGhlIGJlc3Qgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gZG8gZ2l2ZW4gY3VycmVudCBpbXBsZW1lbnRhdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3RhdHVzICYmIHMuaXNMb2NhbCAmJiAhcy5jcm9zc0RvbWFpbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gcmVzcG9uc2VzLnRleHQgPyAyMDAgOiA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgLSAjMTQ1MDogc29tZXRpbWVzIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDEyMjMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKCBmaXJlZm94QWNjZXNzRXhjZXB0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0Fib3J0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoIC0xLCBmaXJlZm94QWNjZXNzRXhjZXB0aW9uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBjb21wbGV0ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc3BvbnNlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzLCByZXNwb25zZUhlYWRlcnMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcy5hc3luYyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBpbiBzeW5jIG1vZGUgd2UgZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKElFNiAmIElFNykgaWYgaXQncyBpbiBjYWNoZSBhbmQgaGFzIGJlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZWQgZGlyZWN0bHkgd2UgbmVlZCB0byBmaXJlIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGNhbGxiYWNrICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9ICsreGhySWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4aHJPblVubG9hZEFib3J0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGFjdGl2ZSB4aHJzIGNhbGxiYWNrcyBsaXN0IGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYXR0YWNoIHRoZSB1bmxvYWQgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICF4aHJDYWxsYmFja3MgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJDYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSggd2luZG93ICkudW5sb2FkKCB4aHJPblVubG9hZEFib3J0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGxpc3Qgb2YgYWN0aXZlIHhocnMgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhockNhbGxiYWNrc1sgaGFuZGxlIF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCB1bmRlZmluZWQsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZnhOb3csIHRpbWVySWQsXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgICAgICByZnhudW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBjb3JlX3BudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICksXG4gICAgICAgIHJydW4gPSAvcXVldWVIb29rcyQvLFxuICAgICAgICBhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG4gICAgICAgIHR3ZWVuZXJzID0ge1xuICAgICAgICAgICAgXCIqXCI6IFtmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCwgdW5pdCxcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSArdGFyZ2V0IHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlID0gMSxcbiAgICAgICAgICAgICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDIwO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggcGFydHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9ICtwYXJ0c1syXTtcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHBhcnRzWzNdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgc3RhcnRpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB1bml0ICE9PSBcInB4XCIgJiYgc3RhcnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBjdXJyZW50IHByb3BlcnR5LCBiZWNhdXNlIHRoaXMgcHJvY2VzcyB3aWxsIGJlIHRyaXZpYWwgaWYgaXQgdXNlcyB0aGUgc2FtZSB1bml0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZW5kIG9yIGEgc2ltcGxlIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHByb3AsIHRydWUgKSB8fCBlbmQgfHwgMTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIHN0cmluZyBmb3IgZG91YmxpbmcgZmFjdG9yIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IGFuZCBhcHBseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHByb3AsIHN0YXJ0ICsgdW5pdCApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCBicmVha2luZyB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICggc2NhbGUgIT09IChzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0KSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi51bml0ID0gdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSArPS8tPSB0b2tlbiB3YXMgcHJvdmlkZWQsIHdlJ3JlIGRvaW5nIGEgcmVsYXRpdmUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVuZCA9IHBhcnRzWzFdID8gc3RhcnQgKyAoIHBhcnRzWzFdICsgMSApICogZW5kIDogZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIFxuICAgIC8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbiAgICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ4Tm93ID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gY3JlYXRlVHdlZW5zKCBhbmltYXRpb24sIHByb3BzICkge1xuICAgICAgICBqUXVlcnkuZWFjaCggcHJvcHMsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIHN0b3BwZWQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBhbmltYXRpb25QcmVmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBkZWxldGUgdGljay5lbGVtO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzdG9wcGVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIDEgLSAoIDAuNSB8fCAwICkgKCMxMjQ5NylcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMSAtIHRlbXAsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICAgICAgICAgIHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuICAgICAgICAgICAgICAgIG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHsgc3BlY2lhbEVhc2luZzoge30gfSwgb3B0aW9ucyApLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR3ZWVuczogW10sXG4gICAgICAgICAgICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdG9wcGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICggZ290b0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcbiAgICBcbiAgICAgICAgcHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcbiAgICBcbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG4gICAgICAgICAgICBpZiAoIHJlc3VsdCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNyZWF0ZVR3ZWVucyggYW5pbWF0aW9uLCBwcm9wcyApO1xuICAgIFxuICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgalF1ZXJ5LmZ4LnRpbWVyKFxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCggdGljaywge1xuICAgICAgICAgICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgICAgICAgICAgYW5pbTogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICBcbiAgICAgICAgLy8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuICAgICAgICAgICAgLmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcbiAgICAgICAgICAgIC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcbiAgICAgICAgICAgIC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcbiAgICAgICAgdmFyIHZhbHVlLCBuYW1lLCBpbmRleCwgZWFzaW5nLCBob29rcztcbiAgICBcbiAgICAgICAgLy8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG4gICAgICAgIGZvciAoIGluZGV4IGluIHByb3BzICkge1xuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG4gICAgICAgICAgICBlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbmFtZSApIHtcbiAgICAgICAgICAgICAgICBwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcbiAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbIG5hbWUgXTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBub3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29udCBvdmVyd3JpdGUga2V5cyBhbHJlYWR5IHByZXNlbnQuXG4gICAgICAgICAgICAgICAgLy8gYWxzbyAtIHJldXNpbmcgJ2luZGV4JyBmcm9tIGFib3ZlIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuICAgICAgICAgICAgICAgIGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcbiAgICBcbiAgICAgICAgdHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwcm9wcztcbiAgICAgICAgICAgICAgICBwcm9wcyA9IFsgXCIqXCIgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB2YXIgcHJvcCxcbiAgICAgICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgIFxuICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IHByb3BzWyBpbmRleCBdO1xuICAgICAgICAgICAgICAgIHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG4gICAgICAgICAgICBpZiAoIHByZXBlbmQgKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25QcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBmdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIHByb3AsIGluZGV4LCBsZW5ndGgsXG4gICAgICAgICAgICB2YWx1ZSwgZGF0YVNob3csIHRvZ2dsZSxcbiAgICAgICAgICAgIHR3ZWVuLCBob29rcywgb2xkZmlyZSxcbiAgICAgICAgICAgIGFuaW0gPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlLFxuICAgICAgICAgICAgb3JpZyA9IHt9LFxuICAgICAgICAgICAgaGFuZGxlZCA9IFtdLFxuICAgICAgICAgICAgaGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApO1xuICAgIFxuICAgICAgICAvLyBoYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG4gICAgICAgIGlmICggIW9wdHMucXVldWUgKSB7XG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG4gICAgICAgICAgICBpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xuICAgICAgICAgICAgICAgIG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQrKztcbiAgICBcbiAgICAgICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvaW5nIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBjb21wbGV0ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIHRoaXMgY29tcGxldGVzXG4gICAgICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVucXVldWVkLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBoZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG4gICAgICAgICAgICAvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90XG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcbiAgICAgICAgICAgIC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG4gICAgICAgICAgICBvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcbiAgICBcbiAgICAgICAgICAgIC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG4gICAgICAgICAgICAvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwiaW5saW5lXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIGlubGluZS1sZXZlbCBlbGVtZW50cyBhY2NlcHQgaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICAgIC8vIGJsb2NrLWxldmVsIGVsZW1lbnRzIG5lZWQgdG8gYmUgaW5saW5lIHdpdGggbGF5b3V0XG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCB8fCBjc3NfZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA9PT0gXCJpbmxpbmVcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuem9vbSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmICggb3B0cy5vdmVyZmxvdyApIHtcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgKSB7XG4gICAgICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgIFxuICAgICAgICAvLyBzaG93L2hpZGUgcGFzc1xuICAgICAgICBmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG4gICAgICAgICAgICBpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZWQucHVzaCggaW5kZXggKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsZW5ndGggPSBoYW5kbGVkLmxlbmd0aDtcbiAgICAgICAgaWYgKCBsZW5ndGggKSB7XG4gICAgICAgICAgICBkYXRhU2hvdyA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJmeHNob3dcIiApIHx8IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcbiAgICAgICAgICAgIGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBzdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG4gICAgICAgICAgICBpZiAoIHRvZ2dsZSApIHtcbiAgICAgICAgICAgICAgICBkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBoaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggZWxlbSApLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcDtcbiAgICAgICAgICAgICAgICBqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIFwiZnhzaG93XCIgKTtcbiAgICAgICAgICAgICAgICBmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKCBpbmRleCA9IDAgOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGhhbmRsZWRbIGluZGV4IF07XG4gICAgICAgICAgICAgICAgdHdlZW4gPSBhbmltLmNyZWF0ZVR3ZWVuKCBwcm9wLCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCApO1xuICAgICAgICAgICAgICAgIG9yaWdbIHByb3AgXSA9IGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBoaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG4gICAgfVxuICAgIGpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuICAgIFxuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFR3ZWVuLFxuICAgICAgICBpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IFwic3dpbmdcIjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuICAgICAgICB9LFxuICAgICAgICBjdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuICAgICAgICAgICAgICAgIGhvb2tzLmdldCggdGhpcyApIDpcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG4gICAgICAgICAgICB2YXIgZWFzZWQsXG4gICAgICAgICAgICAgICAgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuICAgIFxuICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuICAgIFxuICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcbiAgICAgICAgICAgICAgICBob29rcy5zZXQoIHRoaXMgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIFR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcbiAgICBcbiAgICBUd2Vlbi5wcm9wSG9va3MgPSB7XG4gICAgICAgIF9kZWZhdWx0OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0d2Vlbi5lbGVtLnN0eWxlIHx8IHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gcGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlsc1xuICAgICAgICAgICAgICAgIC8vIHNvLCBzaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdC5cbiAgICAgICAgICAgICAgICAvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzIGlzLlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cbiAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcbiAgICAgICAgICAgICAgICAvLyB1c2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdCAtIHVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZSAtIHVzZSAuc3R5bGUgaWYgaXRzXG4gICAgICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHdlZW4uZWxlbS5zdHlsZSAmJiAoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBSZW1vdmUgaW4gMi4wIC0gdGhpcyBzdXBwb3J0cyBJRTgncyBwYW5pYyBiYXNlZCBhcHByb2FjaFxuICAgIC8vIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuICAgIFxuICAgIFR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG4gICAgICAgICAgICBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgalF1ZXJ5LmVhY2goWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG4gICAgICAgIHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuICAgICAgICAgICAgICAgIGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgXG4gICAgICAgICAgICAvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG4gICAgXG4gICAgICAgICAgICAgICAgLy8gYW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgLmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuICAgICAgICB9LFxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuICAgICAgICAgICAgICAgIG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcbiAgICAgICAgICAgICAgICBkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG4gICAgICAgICAgICAgICAgICAgIGRvQW5pbWF0aW9uLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbS5zdG9wKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGVtcHR5IHx8IGpRdWVyeS5fZGF0YSggdGhpcywgXCJmaW5pc2hcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbS5zdG9wKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcbiAgICAgICAgICAgIHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIHN0b3AoIGdvdG9FbmQgKTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuICAgICAgICAgICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXF1ZXVlID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5Ll9kYXRhKCB0aGlzICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBpbmRleCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaW5kZXggaW4gZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVxdWV1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkXG4gICAgICAgICAgICAgICAgLy8gdGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaCB3aWxsIGRlcXVldWVcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxuICAgICAgICAgICAgICAgIGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgIGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBlbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG4gICAgICAgICAgICAgICAgZGF0YS5maW5pc2ggPSB0cnVlO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuICAgICAgICAgICAgICAgIGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIGhvb2tzLmN1ciAmJiBob29rcy5jdXIuZmluaXNoICkge1xuICAgICAgICAgICAgICAgICAgICBob29rcy5jdXIuZmluaXNoLmNhbGwoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gdHVybiBvZmYgZmluaXNoaW5nIGZsYWdcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5maW5pc2g7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG4gICAgZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcbiAgICAgICAgdmFyIHdoaWNoLFxuICAgICAgICAgICAgYXR0cnMgPSB7IGhlaWdodDogdHlwZSB9LFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgXG4gICAgICAgIC8vIGlmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuICAgICAgICBpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGg/IDEgOiAwO1xuICAgICAgICBmb3IoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG4gICAgICAgICAgICB3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuICAgICAgICAgICAgYXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCBpbmNsdWRlV2lkdGggKSB7XG4gICAgICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgc2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG4gICAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcbiAgICAgICAgc2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuICAgICAgICBmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcbiAgICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuICAgICAgICBmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxuICAgIH0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBcbiAgICBqUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG4gICAgICAgIHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG4gICAgICAgICAgICBkdXJhdGlvbjogc3BlZWQsXG4gICAgICAgICAgICBlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcbiAgICAgICAgICAgIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuICAgIFxuICAgICAgICAvLyBub3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcbiAgICAgICAgaWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBvcHQucXVldWUgPSBcImZ4XCI7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gUXVldWVpbmdcbiAgICAgICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcbiAgICBcbiAgICAgICAgb3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG4gICAgICAgICAgICAgICAgb3B0Lm9sZC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIG9wdC5xdWV1ZSApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHJldHVybiBvcHQ7XG4gICAgfTtcbiAgICBcbiAgICBqUXVlcnkuZWFzaW5nID0ge1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIHN3aW5nOiBmdW5jdGlvbiggcCApIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCpNYXRoLlBJICkgLyAyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBqUXVlcnkudGltZXJzID0gW107XG4gICAgalF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG4gICAgalF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpbWVyLFxuICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgIFxuICAgICAgICBmeE5vdyA9IGpRdWVyeS5ub3coKTtcbiAgICBcbiAgICAgICAgZm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbIGkgXTtcbiAgICAgICAgICAgIC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgaWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG4gICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaS0tLCAxICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCAhdGltZXJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5meC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBcbiAgICBqUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG4gICAgICAgIGlmICggdGltZXIoKSAmJiBqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICkgKSB7XG4gICAgICAgICAgICBqUXVlcnkuZnguc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgalF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG4gICAgXG4gICAgalF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICggIXRpbWVySWQgKSB7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgalF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuICAgICAgICB0aW1lcklkID0gbnVsbDtcbiAgICB9O1xuICAgIFxuICAgIGpRdWVyeS5meC5zcGVlZHMgPSB7XG4gICAgICAgIHNsb3c6IDYwMCxcbiAgICAgICAgZmFzdDogMjAwLFxuICAgICAgICAvLyBEZWZhdWx0IHNwZWVkXG4gICAgICAgIF9kZWZhdWx0OiA0MDBcbiAgICB9O1xuICAgIFxuICAgIC8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG4gICAgalF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcbiAgICBcbiAgICBpZiAoIGpRdWVyeS5leHByICYmIGpRdWVyeS5leHByLmZpbHRlcnMgKSB7XG4gICAgICAgIGpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGpRdWVyeS5mbi5vZmZzZXQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHZhciBkb2NFbGVtLCB3aW4sXG4gICAgICAgICAgICBib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXSxcbiAgICAgICAgICAgIGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuICAgIFxuICAgICAgICBpZiAoICFkb2MgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuICAgICAgICBpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcbiAgICAgICAgICAgIHJldHVybiBib3g7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBnQkNSLCBqdXN0IHVzZSAwLDAgcmF0aGVyIHRoYW4gZXJyb3JcbiAgICAgICAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxuICAgICAgICBpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gY29yZV9zdHJ1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IGJveC50b3AgICsgKCB3aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgKSAgLSAoIGRvY0VsZW0uY2xpZW50VG9wICB8fCAwICksXG4gICAgICAgICAgICBsZWZ0OiBib3gubGVmdCArICggd2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCApIC0gKCBkb2NFbGVtLmNsaWVudExlZnQgfHwgMCApXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICBqUXVlcnkub2Zmc2V0ID0ge1xuICAgIFxuICAgICAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICk7XG4gICAgXG4gICAgICAgICAgICAvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG4gICAgICAgICAgICBpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB2YXIgY3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuICAgICAgICAgICAgICAgIGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgY3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApLFxuICAgICAgICAgICAgICAgIGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApLFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJiBqUXVlcnkuaW5BcnJheShcImF1dG9cIiwgW2N1ckNTU1RvcCwgY3VyQ1NTTGVmdF0pID4gLTEsXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7fSwgY3VyUG9zaXRpb24gPSB7fSwgY3VyVG9wLCBjdXJMZWZ0O1xuICAgIFxuICAgICAgICAgICAgLy8gbmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXIgdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG4gICAgICAgICAgICBpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuICAgICAgICAgICAgICAgIGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcbiAgICAgICAgICAgICAgICBjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgY3VyT2Zmc2V0ICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyRWxlbS5jc3MoIHByb3BzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIFxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIFxuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoICF0aGlzWyAwIF0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXTtcbiAgICBcbiAgICAgICAgICAgIC8vIGZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sIGJlY2F1c2UgaXQgaXMgaXQncyBvbmx5IG9mZnNldCBwYXJlbnRcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgYXZhaWxhYmxlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcbiAgICAgICAgICAgIC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG4gICAgICAgICAgICAvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6ICBvZmZzZXQudG9wICAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgXG4gICAgLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goIHtzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwifSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcbiAgICAgICAgdmFyIHRvcCA9IC9ZLy50ZXN0KCBwcm9wICk7XG4gICAgXG4gICAgICAgIGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbiA/IChwcm9wIGluIHdpbikgPyB3aW5bIHByb3AgXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBtZXRob2QgXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBtZXRob2QgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB3aW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICF0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbExlZnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA/IHZhbCA6IGpRdWVyeSggd2luICkuc2Nyb2xsVG9wKClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtWyBtZXRob2QgXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIGZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID9cbiAgICAgICAgICAgIGVsZW0gOlxuICAgICAgICAgICAgZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG4gICAgICAgICAgICAgICAgZWxlbS5kZWZhdWx0VmlldyB8fCBlbGVtLnBhcmVudFdpbmRvdyA6XG4gICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcbiAgICAgICAgalF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcbiAgICAgICAgICAgIC8vIG1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuICAgICAgICAgICAgalF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLCB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZm9ydHVuYXRlbHksIHRoaXMgY2F1c2VzIGJ1ZyAjMzgzOCBpbiBJRTYvOCBvbmx5LCBidXQgdGhlcmUgaXMgY3VycmVudGx5IG5vIGdvb2QsIHNtYWxsIHdheSB0byBmaXggaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcbiAgICAgICAgICAgICAgICB9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gTGltaXQgc2NvcGUgcG9sbHV0aW9uIGZyb20gYW55IGRlcHJlY2F0ZWQgQVBJXG4gICAgLy8gKGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIC8vIH0pKCk7XG4gICAgLy8gRXhwb3NlIGpRdWVyeSB0byB0aGUgZ2xvYmFsIG9iamVjdFxuICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbiAgICBcbiAgICAvLyBFeHBvc2UgalF1ZXJ5IGFzIGFuIEFNRCBtb2R1bGUsIGJ1dCBvbmx5IGZvciBBTUQgbG9hZGVycyB0aGF0XG4gICAgLy8gdW5kZXJzdGFuZCB0aGUgaXNzdWVzIHdpdGggbG9hZGluZyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBqUXVlcnlcbiAgICAvLyBpbiBhIHBhZ2UgdGhhdCBhbGwgbWlnaHQgY2FsbCBkZWZpbmUoKS4gVGhlIGxvYWRlciB3aWxsIGluZGljYXRlXG4gICAgLy8gdGhleSBoYXZlIHNwZWNpYWwgYWxsb3dhbmNlcyBmb3IgbXVsdGlwbGUgalF1ZXJ5IHZlcnNpb25zIGJ5XG4gICAgLy8gc3BlY2lmeWluZyBkZWZpbmUuYW1kLmpRdWVyeSA9IHRydWUuIFJlZ2lzdGVyIGFzIGEgbmFtZWQgbW9kdWxlLFxuICAgIC8vIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXIgZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSxcbiAgICAvLyBidXQgbm90IHVzZSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0IHVuZGVyc3RhbmRzIGFub255bW91c1xuICAgIC8vIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0IHdheSB0byByZWdpc3Rlci5cbiAgICAvLyBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZSBkZXJpdmVkIGZyb21cbiAgICAvLyBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZSBmaWxlIG5hbWUuXG4gICAgLy8gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50cyB0byBjYWxsXG4gICAgLy8gbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICYmIGRlZmluZS5hbWQualF1ZXJ5ICkge1xuICAgICAgICBkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbiAoKSB7IHJldHVybiBqUXVlcnk7IH0gKTtcbiAgICB9XG4gICAgXG4gICAgfSkoIHdpbmRvdyApOyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJ1bmRlZmluZWQiLCJyZWFkeUxpc3QiLCJyb290alF1ZXJ5IiwiY29yZV9zdHJ1bmRlZmluZWQiLCJkb2N1bWVudCIsImxvY2F0aW9uIiwiX2pRdWVyeSIsImpRdWVyeSIsIl8kIiwiJCIsImNsYXNzMnR5cGUiLCJjb3JlX2RlbGV0ZWRJZHMiLCJjb3JlX3ZlcnNpb24iLCJjb3JlX2NvbmNhdCIsImNvbmNhdCIsImNvcmVfcHVzaCIsInB1c2giLCJjb3JlX3NsaWNlIiwic2xpY2UiLCJjb3JlX2luZGV4T2YiLCJpbmRleE9mIiwiY29yZV90b1N0cmluZyIsInRvU3RyaW5nIiwiY29yZV9oYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImNvcmVfdHJpbSIsInRyaW0iLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJjb3JlX3BudW0iLCJzb3VyY2UiLCJjb3JlX3Jub3R3aGl0ZSIsInJ0cmltIiwicnF1aWNrRXhwciIsInJzaW5nbGVUYWciLCJydmFsaWRjaGFycyIsInJ2YWxpZGJyYWNlcyIsInJ2YWxpZGVzY2FwZSIsInJ2YWxpZHRva2VucyIsInJtc1ByZWZpeCIsInJkYXNoQWxwaGEiLCJmY2FtZWxDYXNlIiwiYWxsIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJjb21wbGV0ZWQiLCJldmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0eXBlIiwicmVhZHlTdGF0ZSIsImRldGFjaCIsInJlYWR5IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwicHJvdG90eXBlIiwianF1ZXJ5IiwiY29uc3RydWN0b3IiLCJtYXRjaCIsImVsZW0iLCJjaGFyQXQiLCJsZW5ndGgiLCJleGVjIiwibWVyZ2UiLCJwYXJzZUhUTUwiLCJub2RlVHlwZSIsIm93bmVyRG9jdW1lbnQiLCJ0ZXN0IiwiaXNQbGFpbk9iamVjdCIsImlzRnVuY3Rpb24iLCJhdHRyIiwiZ2V0RWxlbWVudEJ5SWQiLCJwYXJlbnROb2RlIiwiaWQiLCJmaW5kIiwibWFrZUFycmF5Iiwic2l6ZSIsInRvQXJyYXkiLCJjYWxsIiwiZ2V0IiwibnVtIiwicHVzaFN0YWNrIiwiZWxlbXMiLCJyZXQiLCJwcmV2T2JqZWN0IiwiZWFjaCIsImNhbGxiYWNrIiwiYXJncyIsInByb21pc2UiLCJkb25lIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJmaXJzdCIsImVxIiwibGFzdCIsImkiLCJsZW4iLCJqIiwibWFwIiwiZW5kIiwic29ydCIsInNwbGljZSIsImV4dGVuZCIsInNyYyIsImNvcHlJc0FycmF5IiwiY29weSIsIm5hbWUiLCJvcHRpb25zIiwiY2xvbmUiLCJ0YXJnZXQiLCJkZWVwIiwiaXNBcnJheSIsIm5vQ29uZmxpY3QiLCJpc1JlYWR5IiwicmVhZHlXYWl0IiwiaG9sZFJlYWR5IiwiaG9sZCIsIndhaXQiLCJib2R5Iiwic2V0VGltZW91dCIsInJlc29sdmVXaXRoIiwidHJpZ2dlciIsIm9mZiIsIm9iaiIsIkFycmF5IiwiaXNXaW5kb3ciLCJpc051bWVyaWMiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsIlN0cmluZyIsImUiLCJrZXkiLCJpc0VtcHR5T2JqZWN0IiwiZXJyb3IiLCJtc2ciLCJFcnJvciIsImRhdGEiLCJrZWVwU2NyaXB0cyIsInBhcnNlZCIsInNjcmlwdHMiLCJjcmVhdGVFbGVtZW50IiwiYnVpbGRGcmFnbWVudCIsInJlbW92ZSIsImNoaWxkTm9kZXMiLCJwYXJzZUpTT04iLCJKU09OIiwicGFyc2UiLCJyZXBsYWNlIiwiRnVuY3Rpb24iLCJwYXJzZVhNTCIsInhtbCIsInRtcCIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsIkFjdGl2ZVhPYmplY3QiLCJhc3luYyIsImxvYWRYTUwiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm5vb3AiLCJnbG9iYWxFdmFsIiwiZXhlY1NjcmlwdCIsImNhbWVsQ2FzZSIsInN0cmluZyIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJ2YWx1ZSIsImlzQXJyYXlsaWtlIiwidGV4dCIsImFyciIsInJlc3VsdHMiLCJPYmplY3QiLCJpbkFycmF5IiwiTWF0aCIsIm1heCIsInNlY29uZCIsImwiLCJncmVwIiwiaW52IiwicmV0VmFsIiwiYXJnIiwiZ3VpZCIsInByb3h5IiwiYWNjZXNzIiwiY2hhaW5hYmxlIiwiZW1wdHlHZXQiLCJyYXciLCJidWxrIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJEZWZlcnJlZCIsImF0dGFjaEV2ZW50IiwidG9wIiwiZnJhbWVFbGVtZW50IiwiZG9TY3JvbGwiLCJkb1Njcm9sbENoZWNrIiwic3BsaXQiLCJvcHRpb25zQ2FjaGUiLCJjcmVhdGVPcHRpb25zIiwib2JqZWN0IiwiXyIsImZsYWciLCJDYWxsYmFja3MiLCJmaXJpbmciLCJtZW1vcnkiLCJmaXJlZCIsImZpcmluZ0xlbmd0aCIsImZpcmluZ0luZGV4IiwiZmlyaW5nU3RhcnQiLCJsaXN0Iiwic3RhY2siLCJvbmNlIiwiZmlyZSIsInN0b3BPbkZhbHNlIiwic2hpZnQiLCJzZWxmIiwiZGlzYWJsZSIsImFkZCIsInN0YXJ0IiwidW5pcXVlIiwiaGFzIiwiaW5kZXgiLCJlbXB0eSIsImRpc2FibGVkIiwibG9jayIsImxvY2tlZCIsImZpcmVXaXRoIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwiYWx3YXlzIiwiZGVmZXJyZWQiLCJmYWlsIiwidGhlbiIsImZucyIsIm5ld0RlZmVyIiwidHVwbGUiLCJhY3Rpb24iLCJyZXR1cm5lZCIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9ncmVzcyIsIm5vdGlmeSIsInBpcGUiLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzdWJvcmRpbmF0ZSIsInJlc29sdmVWYWx1ZXMiLCJyZW1haW5pbmciLCJ1cGRhdGVGdW5jIiwiY29udGV4dHMiLCJ2YWx1ZXMiLCJwcm9ncmVzc1ZhbHVlcyIsIm5vdGlmeVdpdGgiLCJwcm9ncmVzc0NvbnRleHRzIiwicmVzb2x2ZUNvbnRleHRzIiwic3VwcG9ydCIsImEiLCJpbnB1dCIsInNlbGVjdCIsImZyYWdtZW50Iiwib3B0IiwiZXZlbnROYW1lIiwiaXNTdXBwb3J0ZWQiLCJkaXYiLCJzZXRBdHRyaWJ1dGUiLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsInN0eWxlIiwiY3NzVGV4dCIsImdldFNldEF0dHJpYnV0ZSIsImNsYXNzTmFtZSIsImxlYWRpbmdXaGl0ZXNwYWNlIiwiZmlyc3RDaGlsZCIsInRib2R5IiwiaHRtbFNlcmlhbGl6ZSIsImdldEF0dHJpYnV0ZSIsImhyZWZOb3JtYWxpemVkIiwib3BhY2l0eSIsImNzc0Zsb2F0IiwiY2hlY2tPbiIsIm9wdFNlbGVjdGVkIiwic2VsZWN0ZWQiLCJlbmN0eXBlIiwiaHRtbDVDbG9uZSIsImNsb25lTm9kZSIsIm91dGVySFRNTCIsImJveE1vZGVsIiwiY29tcGF0TW9kZSIsImRlbGV0ZUV4cGFuZG8iLCJub0Nsb25lRXZlbnQiLCJpbmxpbmVCbG9ja05lZWRzTGF5b3V0Iiwic2hyaW5rV3JhcEJsb2NrcyIsInJlbGlhYmxlTWFyZ2luUmlnaHQiLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsUG9zaXRpb24iLCJjaGVja2VkIiwibm9DbG9uZUNoZWNrZWQiLCJvcHREaXNhYmxlZCIsInJhZGlvVmFsdWUiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiYXBwZW5kQ2hlY2tlZCIsImNoZWNrQ2xvbmUiLCJsYXN0Q2hpbGQiLCJjbGljayIsInN1Ym1pdCIsImNoYW5nZSIsImZvY3VzaW4iLCJhdHRyaWJ1dGVzIiwiZXhwYW5kbyIsImJhY2tncm91bmRDbGlwIiwiY2xlYXJDbG9uZVN0eWxlIiwiY29udGFpbmVyIiwibWFyZ2luRGl2IiwidGRzIiwiZGl2UmVzZXQiLCJvZmZzZXRIZWlnaHQiLCJkaXNwbGF5IiwicmVsaWFibGVIaWRkZW5PZmZzZXRzIiwiYm94U2l6aW5nIiwib2Zmc2V0V2lkdGgiLCJkb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCIsIm9mZnNldFRvcCIsImdldENvbXB1dGVkU3R5bGUiLCJ3aWR0aCIsIm1hcmdpblJpZ2h0Iiwiem9vbSIsInJlbW92ZUNoaWxkIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImludGVybmFsRGF0YSIsInB2dCIsImFjY2VwdERhdGEiLCJ0aGlzQ2FjaGUiLCJpbnRlcm5hbEtleSIsImdldEJ5TmFtZSIsImlzTm9kZSIsImNhY2hlIiwicG9wIiwidG9KU09OIiwiaW50ZXJuYWxSZW1vdmVEYXRhIiwiaXNFbXB0eURhdGFPYmplY3QiLCJjbGVhbkRhdGEiLCJyYW5kb20iLCJub0RhdGEiLCJoYXNEYXRhIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJhdHRycyIsImRhdGFBdHRyIiwicXVldWUiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwibmV4dCIsImN1ciIsInVuc2hpZnQiLCJzdG9wIiwic2V0dGVyIiwiZGVsYXkiLCJ0aW1lIiwiZngiLCJzcGVlZHMiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJRdWV1ZSIsImNvdW50IiwiZGVmZXIiLCJlbGVtZW50cyIsIm5vZGVIb29rIiwiYm9vbEhvb2siLCJyY2xhc3MiLCJycmV0dXJuIiwicmZvY3VzYWJsZSIsInJjbGlja2FibGUiLCJyYm9vbGVhbiIsInJ1c2VEZWZhdWx0IiwiZ2V0U2V0SW5wdXQiLCJyZW1vdmVBdHRyIiwicHJvcCIsInJlbW92ZVByb3AiLCJwcm9wRml4IiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwiY2xhenoiLCJwcm9jZWVkIiwicmVtb3ZlQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsInN0YXRlVmFsIiwiaXNCb29sIiwiY2xhc3NOYW1lcyIsImhhc0NsYXNzIiwidmFsIiwidmFsSG9va3MiLCJzZXQiLCJvcHRpb24iLCJzcGVjaWZpZWQiLCJzZWxlY3RlZEluZGV4Iiwib25lIiwibm90eG1sIiwiblR5cGUiLCJpc1hNTERvYyIsImF0dHJIb29rcyIsInByb3BOYW1lIiwiYXR0ck5hbWVzIiwicmVtb3ZlQXR0cmlidXRlIiwidGFiaW5kZXgiLCJyZWFkb25seSIsIm1heGxlbmd0aCIsImNlbGxzcGFjaW5nIiwiY2VsbHBhZGRpbmciLCJyb3dzcGFuIiwiY29sc3BhbiIsInVzZW1hcCIsImZyYW1lYm9yZGVyIiwiY29udGVudGVkaXRhYmxlIiwicHJvcEhvb2tzIiwidGFiSW5kZXgiLCJhdHRyaWJ1dGVOb2RlIiwiZ2V0QXR0cmlidXRlTm9kZSIsInBhcnNlSW50IiwiaHJlZiIsImRldGFpbCIsImRlZmF1bHRWYWx1ZSIsImJ1dHRvbiIsInNldEF0dHJpYnV0ZU5vZGUiLCJjcmVhdGVBdHRyaWJ1dGUiLCJwYXJlbnQiLCJyZm9ybUVsZW1zIiwicmtleUV2ZW50Iiwicm1vdXNlRXZlbnQiLCJyZm9jdXNNb3JwaCIsInJ0eXBlbmFtZXNwYWNlIiwicmV0dXJuVHJ1ZSIsInJldHVybkZhbHNlIiwiZ2xvYmFsIiwidHlwZXMiLCJoYW5kbGVyIiwiZXZlbnRzIiwidCIsImhhbmRsZU9iakluIiwic3BlY2lhbCIsImV2ZW50SGFuZGxlIiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJuZWVkc0NvbnRleHQiLCJleHByIiwibmFtZXNwYWNlIiwiam9pbiIsImRlbGVnYXRlQ291bnQiLCJzZXR1cCIsIm1hcHBlZFR5cGVzIiwib3JpZ0NvdW50IiwiUmVnRXhwIiwidGVhcmRvd24iLCJyZW1vdmVFdmVudCIsIm9ubHlIYW5kbGVycyIsIm9udHlwZSIsImJ1YmJsZVR5cGUiLCJldmVudFBhdGgiLCJFdmVudCIsImlzVHJpZ2dlciIsIm5hbWVzcGFjZV9yZSIsInJlc3VsdCIsIm5vQnViYmxlIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsInByZXZlbnREZWZhdWx0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiX2RlZmF1bHQiLCJmaXgiLCJtYXRjaGVkIiwiaGFuZGxlclF1ZXVlIiwiZGVsZWdhdGVUYXJnZXQiLCJwcmVEaXNwYXRjaCIsImN1cnJlbnRUYXJnZXQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsInN0b3BQcm9wYWdhdGlvbiIsInBvc3REaXNwYXRjaCIsInNlbCIsIm1hdGNoZXMiLCJvcmlnaW5hbEV2ZW50IiwiZml4SG9vayIsImZpeEhvb2tzIiwibW91c2VIb29rcyIsImtleUhvb2tzIiwicHJvcHMiLCJzcmNFbGVtZW50IiwibWV0YUtleSIsImZpbHRlciIsIm9yaWdpbmFsIiwid2hpY2giLCJjaGFyQ29kZSIsImtleUNvZGUiLCJldmVudERvYyIsImRvYyIsImZyb21FbGVtZW50IiwicGFnZVgiLCJjbGllbnRYIiwic2Nyb2xsTGVmdCIsImNsaWVudExlZnQiLCJwYWdlWSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJjbGllbnRUb3AiLCJyZWxhdGVkVGFyZ2V0IiwidG9FbGVtZW50IiwibG9hZCIsImZvY3VzIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJiZWZvcmV1bmxvYWQiLCJyZXR1cm5WYWx1ZSIsInNpbXVsYXRlIiwiYnViYmxlIiwiaXNTaW11bGF0ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwiZ2V0UHJldmVudERlZmF1bHQiLCJ0aW1lU3RhbXAiLCJjYW5jZWxCdWJibGUiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm9yaWciLCJyZWxhdGVkIiwiY29udGFpbnMiLCJzdWJtaXRCdWJibGVzIiwiZm9ybSIsIl9zdWJtaXRfYnViYmxlIiwiY2hhbmdlQnViYmxlcyIsInByb3BlcnR5TmFtZSIsIl9qdXN0X2NoYW5nZWQiLCJmb2N1c2luQnViYmxlcyIsImF0dGFjaGVzIiwib24iLCJvcmlnRm4iLCJiaW5kIiwidW5iaW5kIiwiZGVsZWdhdGUiLCJ1bmRlbGVnYXRlIiwidHJpZ2dlckhhbmRsZXIiLCJjYWNoZWRydW5zIiwiRXhwciIsImdldFRleHQiLCJpc1hNTCIsImNvbXBpbGUiLCJoYXNEdXBsaWNhdGUiLCJvdXRlcm1vc3RDb250ZXh0Iiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc1hNTCIsInJidWdneVFTQSIsInJidWdneU1hdGNoZXMiLCJzb3J0T3JkZXIiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiY2xhc3NDYWNoZSIsImNyZWF0ZUNhY2hlIiwidG9rZW5DYWNoZSIsImNvbXBpbGVyQ2FjaGUiLCJzdHJ1bmRlZmluZWQiLCJNQVhfTkVHQVRJVkUiLCJ3aGl0ZXNwYWNlIiwiY2hhcmFjdGVyRW5jb2RpbmciLCJpZGVudGlmaWVyIiwib3BlcmF0b3JzIiwicHNldWRvcyIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJwc2V1ZG8iLCJyaWRlbnRpZmllciIsIm1hdGNoRXhwciIsInJzaWJsaW5nIiwicm5hdGl2ZSIsInJpbnB1dHMiLCJyaGVhZGVyIiwicmVzY2FwZSIsInJhdHRyaWJ1dGVRdW90ZXMiLCJydW5lc2NhcGUiLCJmdW5lc2NhcGUiLCJlc2NhcGVkIiwiaGlnaCIsImZyb21DaGFyQ29kZSIsImlzTmF0aXZlIiwia2V5cyIsImNhY2hlTGVuZ3RoIiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiU2l6emxlIiwic2VlZCIsIm0iLCJncm91cHMiLCJvbGQiLCJuaWQiLCJuZXdDb250ZXh0IiwibmV3U2VsZWN0b3IiLCJnZXRCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJxc2EiLCJ0b2tlbml6ZSIsInRvU2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJub2RlIiwidGFnTmFtZU5vQ29tbWVudHMiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwicGFzcyIsImdldEVsZW1lbnRzQnlOYW1lIiwiZ2V0SWROb3ROYW1lIiwiYXR0ckhhbmRsZSIsImF0dHJJZCIsInRhZyIsIm1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImRpc2Nvbm5lY3RlZE1hdGNoIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJiIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwiYXVwIiwiYXAiLCJicCIsInNpYmxpbmdDaGVjayIsImRldGVjdER1cGxpY2F0ZXMiLCJ1bmlxdWVTb3J0IiwiZHVwbGljYXRlcyIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJ0ZXh0Q29udGVudCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwiZGlyIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJwYXR0ZXJuIiwib3BlcmF0b3IiLCJjaGVjayIsIndoYXQiLCJzaW1wbGUiLCJmb3J3YXJkIiwib2ZUeXBlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInVzZUNhY2hlIiwicHNldWRvIiwic2V0RmlsdGVycyIsImlkeCIsIm1hdGNoZXIiLCJ1bm1hdGNoZWQiLCJpbm5lclRleHQiLCJsYW5nIiwiZWxlbUxhbmciLCJoYXNoIiwiaGFzRm9jdXMiLCJyYWRpbyIsImNoZWNrYm94IiwiZmlsZSIsInBhc3N3b3JkIiwiaW1hZ2UiLCJyZXNldCIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImFkZENvbWJpbmF0b3IiLCJjb21iaW5hdG9yIiwiYmFzZSIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsImRpcmtleSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtdWx0aXBsZUNvbnRleHRzIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwibWF0Y2hlckNhY2hlZFJ1bnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsImV4cGFuZENvbnRleHQiLCJzZXRNYXRjaGVkIiwibWF0Y2hlZENvdW50Iiwib3V0ZXJtb3N0IiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJncm91cCIsInRva2VuIiwiZmlsdGVycyIsInJ1bnRpbCIsInJwYXJlbnRzcHJldiIsImlzU2ltcGxlIiwicm5lZWRzQ29udGV4dCIsImd1YXJhbnRlZWRVbmlxdWUiLCJjaGlsZHJlbiIsImNvbnRlbnRzIiwicHJldiIsInRhcmdldHMiLCJub3QiLCJ3aW5ub3ciLCJpcyIsImNsb3Nlc3QiLCJwb3MiLCJwcmV2QWxsIiwiYWRkQmFjayIsImFuZFNlbGYiLCJzaWJsaW5nIiwicGFyZW50cyIsInBhcmVudHNVbnRpbCIsInVudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsInNpYmxpbmdzIiwiY29udGVudERvY3VtZW50IiwiY29udGVudFdpbmRvdyIsInJldmVyc2UiLCJuIiwiciIsInF1YWxpZmllciIsImtlZXAiLCJmaWx0ZXJlZCIsImNyZWF0ZVNhZmVGcmFnbWVudCIsIm5vZGVOYW1lcyIsInNhZmVGcmFnIiwicmlubGluZWpRdWVyeSIsInJub3NoaW1jYWNoZSIsInJsZWFkaW5nV2hpdGVzcGFjZSIsInJ4aHRtbFRhZyIsInJ0YWdOYW1lIiwicnRib2R5Iiwicmh0bWwiLCJybm9Jbm5lcmh0bWwiLCJtYW5pcHVsYXRpb25fcmNoZWNrYWJsZVR5cGUiLCJyY2hlY2tlZCIsInJzY3JpcHRUeXBlIiwicnNjcmlwdFR5cGVNYXNrZWQiLCJyY2xlYW5TY3JpcHQiLCJ3cmFwTWFwIiwibGVnZW5kIiwiYXJlYSIsInBhcmFtIiwidGhlYWQiLCJ0ciIsImNvbCIsInRkIiwic2FmZUZyYWdtZW50IiwiZnJhZ21lbnREaXYiLCJvcHRncm91cCIsInRmb290IiwiY29sZ3JvdXAiLCJjYXB0aW9uIiwidGgiLCJhcHBlbmQiLCJjcmVhdGVUZXh0Tm9kZSIsIndyYXBBbGwiLCJodG1sIiwid3JhcCIsIndyYXBJbm5lciIsInVud3JhcCIsInJlcGxhY2VXaXRoIiwiZG9tTWFuaXAiLCJwcmVwZW5kIiwiYmVmb3JlIiwiYWZ0ZXIiLCJrZWVwRGF0YSIsImdldEFsbCIsInNldEdsb2JhbEV2YWwiLCJkYXRhQW5kRXZlbnRzIiwiZGVlcERhdGFBbmRFdmVudHMiLCJpc0Z1bmMiLCJ0YWJsZSIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsImRpc2FibGVTY3JpcHQiLCJmaW5kT3JBcHBlbmQiLCJyZXN0b3JlU2NyaXB0IiwiYWpheCIsInVybCIsImRhdGFUeXBlIiwicmVmRWxlbWVudHMiLCJjbG9uZUNvcHlFdmVudCIsImRlc3QiLCJvbGREYXRhIiwiY3VyRGF0YSIsImZpeENsb25lTm9kZUlzc3VlcyIsImRlZmF1bHRDaGVja2VkIiwiZGVmYXVsdFNlbGVjdGVkIiwiYXBwZW5kVG8iLCJwcmVwZW5kVG8iLCJpbnNlcnRBZnRlciIsInJlcGxhY2VBbGwiLCJpbnNlcnQiLCJmb3VuZCIsImZpeERlZmF1bHRDaGVja2VkIiwiZGVzdEVsZW1lbnRzIiwic3JjRWxlbWVudHMiLCJpblBhZ2UiLCJzZWxlY3Rpb24iLCJzYWZlIiwibm9kZXMiLCJpZnJhbWUiLCJnZXRTdHlsZXMiLCJjdXJDU1MiLCJyYWxwaGEiLCJyb3BhY2l0eSIsInJwb3NpdGlvbiIsInJkaXNwbGF5c3dhcCIsInJtYXJnaW4iLCJybnVtc3BsaXQiLCJybnVtbm9ucHgiLCJycmVsTnVtIiwiZWxlbWRpc3BsYXkiLCJCT0RZIiwiY3NzU2hvdyIsInBvc2l0aW9uIiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0IiwiY3NzRXhwYW5kIiwiY3NzUHJlZml4ZXMiLCJ2ZW5kb3JQcm9wTmFtZSIsImNhcE5hbWUiLCJvcmlnTmFtZSIsImlzSGlkZGVuIiwiZWwiLCJjc3MiLCJzaG93SGlkZSIsInNob3ciLCJoaWRkZW4iLCJjc3NfZGVmYXVsdERpc3BsYXkiLCJzdHlsZXMiLCJoaWRlIiwidG9nZ2xlIiwiYm9vbCIsImNzc0hvb2tzIiwiY29tcHV0ZWQiLCJjc3NOdW1iZXIiLCJjc3NQcm9wcyIsImV4dHJhIiwic3dhcCIsIl9jb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiY3VycmVudFN0eWxlIiwibGVmdCIsInJzIiwicnNMZWZ0IiwicnVudGltZVN0eWxlIiwicGl4ZWxMZWZ0Iiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsImF1Z21lbnRXaWR0aE9ySGVpZ2h0IiwiaXNCb3JkZXJCb3giLCJnZXRXaWR0aE9ySGVpZ2h0IiwidmFsdWVJc0JvcmRlckJveCIsImFjdHVhbERpc3BsYXkiLCJ3cml0ZSIsImNsb3NlIiwiJDEiLCJ2aXNpYmxlIiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsInByZWZpeCIsInN1ZmZpeCIsImV4cGFuZCIsImV4cGFuZGVkIiwicGFydHMiLCJyMjAiLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJ0cmFkaXRpb25hbCIsInMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJhamF4U2V0dGluZ3MiLCJidWlsZFBhcmFtcyIsInYiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwiYWpheExvY1BhcnRzIiwiYWpheExvY2F0aW9uIiwiYWpheF9ub25jZSIsImFqYXhfcnF1ZXJ5Iiwicmhhc2giLCJydHMiLCJyaGVhZGVycyIsInJsb2NhbFByb3RvY29sIiwicm5vQ29udGVudCIsInJwcm90b2NvbCIsInJ1cmwiLCJfbG9hZCIsInByZWZpbHRlcnMiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZXMiLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsIm9yaWdpbmFsT3B0aW9ucyIsImpxWEhSIiwiaW5zcGVjdGVkIiwic2Vla2luZ1RyYW5zcG9ydCIsImluc3BlY3QiLCJwcmVmaWx0ZXJPckZhY3RvcnkiLCJkYXRhVHlwZU9yVHJhbnNwb3J0IiwiYWpheEV4dGVuZCIsImZsYXRPcHRpb25zIiwicGFyYW1zIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJjb21wbGV0ZSIsInN0YXR1cyIsIm1ldGhvZCIsInN1Y2Nlc3MiLCJhY3RpdmUiLCJsYXN0TW9kaWZpZWQiLCJldGFnIiwiaXNMb2NhbCIsInByb2Nlc3NEYXRhIiwiY29udGVudFR5cGUiLCJhY2NlcHRzIiwianNvbiIsInJlc3BvbnNlRmllbGRzIiwiY29udmVydGVycyIsImFqYXhTZXR1cCIsInNldHRpbmdzIiwiYWpheFByZWZpbHRlciIsImFqYXhUcmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInRpbWVvdXRUaW1lciIsImZpcmVHbG9iYWxzIiwidHJhbnNwb3J0IiwicmVzcG9uc2VIZWFkZXJzIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0IiwiY29tcGxldGVEZWZlcnJlZCIsInN0YXR1c0NvZGUiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3RIZWFkZXJzTmFtZXMiLCJzdHJBYm9ydCIsImdldFJlc3BvbnNlSGVhZGVyIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsImxuYW1lIiwib3ZlcnJpZGVNaW1lVHlwZSIsIm1pbWVUeXBlIiwiY29kZSIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsImNyb3NzRG9tYWluIiwiaGFzQ29udGVudCIsImlmTW9kaWZpZWQiLCJoZWFkZXJzIiwiYmVmb3JlU2VuZCIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwicmVzcG9uc2VzIiwiaXNTdWNjZXNzIiwibW9kaWZpZWQiLCJhamF4SGFuZGxlUmVzcG9uc2VzIiwiYWpheENvbnZlcnQiLCJyZWplY3RXaXRoIiwiZ2V0U2NyaXB0IiwiZ2V0SlNPTiIsImZpcnN0RGF0YVR5cGUiLCJjdCIsImZpbmFsRGF0YVR5cGUiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwiZGF0YUZpbHRlciIsInNjcmlwdCIsImhlYWQiLCJzY3JpcHRDaGFyc2V0IiwiY2hhcnNldCIsIm9ubG9hZCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImlzQWJvcnQiLCJvbGRDYWxsYmFja3MiLCJyanNvbnAiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJvcmlnaW5hbFNldHRpbmdzIiwiY2FsbGJhY2tOYW1lIiwib3ZlcndyaXR0ZW4iLCJyZXNwb25zZUNvbnRhaW5lciIsImpzb25Qcm9wIiwieGhyQ2FsbGJhY2tzIiwieGhyU3VwcG9ydGVkIiwieGhySWQiLCJ4aHJPblVubG9hZEFib3J0IiwiY3JlYXRlU3RhbmRhcmRYSFIiLCJYTUxIdHRwUmVxdWVzdCIsImNyZWF0ZUFjdGl2ZVhIUiIsInhociIsImNvcnMiLCJ1c2VybmFtZSIsIm9wZW4iLCJ4aHJGaWVsZHMiLCJlcnIiLCJmaXJlZm94QWNjZXNzRXhjZXB0aW9uIiwidW5sb2FkIiwiZnhOb3ciLCJ0aW1lcklkIiwicmZ4dHlwZXMiLCJyZnhudW0iLCJycnVuIiwiYW5pbWF0aW9uUHJlZmlsdGVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJ0d2VlbmVycyIsInVuaXQiLCJ0d2VlbiIsImNyZWF0ZVR3ZWVuIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3JlYXRlRnhOb3ciLCJjcmVhdGVUd2VlbnMiLCJhbmltYXRpb24iLCJjb2xsZWN0aW9uIiwiQW5pbWF0aW9uIiwicHJvcGVydGllcyIsInN0b3BwZWQiLCJ0aWNrIiwiY3VycmVudFRpbWUiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsInBlcmNlbnQiLCJ0d2VlbnMiLCJydW4iLCJvcHRzIiwic3BlY2lhbEVhc2luZyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIlR3ZWVuIiwiZWFzaW5nIiwiZ290b0VuZCIsInByb3BGaWx0ZXIiLCJ0aW1lciIsImFuaW0iLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwiZGF0YVNob3ciLCJvbGRmaXJlIiwiaGFuZGxlZCIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJlYXNlZCIsInN0ZXAiLCJjc3NGbiIsInNwZWVkIiwiYW5pbWF0ZSIsImdlbkZ4IiwiZmFkZVRvIiwidG8iLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImluY2x1ZGVXaWR0aCIsImhlaWdodCIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwibGluZWFyIiwicCIsInN3aW5nIiwiY29zIiwiUEkiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInNsb3ciLCJmYXN0IiwiYW5pbWF0ZWQiLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJ3aW4iLCJib3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRXaW5kb3ciLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0IiwiY3VyRWxlbSIsImN1ck9mZnNldCIsImN1ckNTU1RvcCIsImN1ckNTU0xlZnQiLCJjYWxjdWxhdGVQb3NpdGlvbiIsImN1clBvc2l0aW9uIiwiY3VyVG9wIiwiY3VyTGVmdCIsInVzaW5nIiwib2Zmc2V0UGFyZW50IiwicGFyZW50T2Zmc2V0Iiwic2Nyb2xsVG8iLCJIZWlnaHQiLCJXaWR0aCIsImNvbnRlbnQiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsImRlZmluZSIsImFtZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/jquery.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/jquery.js");
/******/ 	
/******/ })()
;